<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
	<meta name='renderer' content='webkit'>
	<meta name='viewport' content='width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no'>
	<meta name='description' content='记录学习的点点滴滴'>
	<meta name='keywords' content='前端,PHP,GO,编程博客'>
	<title>苏苏的博客 &middot; 苏苏的博客</title>
	<link rel="stylesheet" type="text/css" href="/css/style.min.css">
	<link href="http://blog.suconghou.cn/index.xml" rel="alternate" type="application/rss+xml" title="苏苏的博客" />
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
	<link rel="shortcut icon" href="/favicon.png">
</head>
<body>
<header class="header">
	<div class="header-main">
		<a href="/"><img src="/img/avatar.jpg" class="header-avatar"></a>
		<h1>苏苏的博客</h1>
		<p class="sub-title">简约至极</p>
		<ul class="contact">
			<a href="https://github.com/suconghou" target="_blank"><i class="fa fa-github"></i></a>
			<a href="javascript:music.show(1)"><i class="fa fa-music"></i></a>
		</ul>
	</div>
</header>

<aside></aside>

<div class="content container">
	<div class="posts">
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/some-good-useful-things/"> 网摘</a>
			</h1>
			<p class="post-date">Wed, Jan 6, 2016</p>
			<div class="post-text">
				

<h2 id="云计算-存储-分发等:49483a20fa0a8bb8347c64e9ee523801">云计算,存储,分发等</h2>

<p><a href="http://baichuan.taobao.com/">阿里百川</a>
<a href="http://open.taobao.com/">淘宝开放平台</a></p>

<blockquote>
<p>包含容器引擎（TAE）, 多媒体存储处理分发, 可免费使用一年</p>
</blockquote>

<p><a href="https://c.163.com/">网易的Docker服务</a></p>

<blockquote>
<p>最近上线,价格略贵最低29/月</p>
</blockquote>

<p><a href="http://bmob.cn/">bmob</a>移动后端云,网友示例项目<a href="https://github.com/bestony/BandwaghonhostAPP">BandwaghonhostAPP</a>,结合<a href="http://dev.dcloud.net.cn/mui/">mui移动开发框架</a>开发手机APP</p>

<h2 id="短信-推动消息等:49483a20fa0a8bb8347c64e9ee523801">短信,推动消息等</h2>

<ul>
<li><a href="http://www.alidayu.com/">阿里大鱼</a></li>
</ul>

<blockquote>
<p>阿里巴巴旗下的短信验证码通知服务,价格实惠,短信通知≤0.045元／条,还有文本转语音通知≤0.055元／条</p>
</blockquote>

<ul>
<li><a href="http://sendcloud.sohu.com/price.html">SendCloud</a></li>
</ul>

<blockquote>
<p>短信和邮件发送服务,邮件有每日免费200封,短信5.5分每条</p>
</blockquote>

<h2 id="图像压缩软件:49483a20fa0a8bb8347c64e9ee523801">图像压缩软件</h2>

<p><a href="https://imageoptim.com/">ImageOptim无损压缩</a></p>

<p><a href="http://mozjpeg.codelove.de/">mozjpeg</a> Mozilla的jpg压缩技术,支持无损,有损压缩在线压缩,最大2M.</p>

<p><a href="https://tinypng.com/">tinypng</a> 众多压缩软件中压缩效果较好的,支持png,jpg在线批量压缩</p>

<p><a href="https://kraken.io">kraken</a> 类似于tinypng,也提供在线压缩</p>

<p><a href="https://pngquant.org/">pngquant</a> 开源的压缩png,据说tinypng基于此项目</p>

<p><a href="https://www.npmjs.com/package/imagemin">nodejs imagemin</a> NodeJs模块,压缩jpg,png,压缩效果一般</p>

<h2 id="移动混合应用-hhtml5开发:49483a20fa0a8bb8347c64e9ee523801">移动混合应用/HHTML5开发</h2>

<p><a href="http://dev.dcloud.net.cn/mui/">国产mui</a> 最接近原生APP体验的高性能前端框架,不依赖任何第三方JS库,压缩后的JS和CSS文件仅有100+K和60+K</p>

<p><a href="http://m.sui.taobao.org/">SUI Mobile</a> 淘宝移动UI框架,轻量，小巧且精美的UI库 方便迅速搭建手机H5应用,兼容iOS 6.0+ 和 Android 4.0+，非常适合开发跨平台Web App。</p>

<p><a href="http://mobiscroll.com/">mobiscroll</a> 移动开发UI,丰富的时间选择器控件还有一些WEBAPP展示,<a href="https://github.com/acidb/mobiscroll">https://github.com/acidb/mobiscroll</a></p>

<h2 id="桌面开发:49483a20fa0a8bb8347c64e9ee523801">桌面开发</h2>

<p><a href="http://nwjs.io/">nwjs</a> Mac版钉钉使用的就是这个技术,界面还算漂亮</p>

<h2 id="网页动画:49483a20fa0a8bb8347c64e9ee523801">网页动画</h2>

<p><a href="http://ecomfe.github.io/zrender/index.html">百度zrender</a> 基于Canvas的图形仓库交互工具,可以方便的画出很多图形</p>

<h2 id="游戏引擎:49483a20fa0a8bb8347c64e9ee523801">游戏引擎</h2>

<p><a href="http://hiloteam.github.io/">阿里Hilo</a> 游戏渲染引擎,实现2048,切水果等.</p>

<p><a href="http://www.egret.com/">http://www.egret.com/</a> 白鹭也是做这个的</p>

<p><a href="https://github.com/iioinc/iio.js">https://github.com/iioinc/iio.js</a> 也是canvas的游戏</p>

<h2 id="网页富文本编辑器:49483a20fa0a8bb8347c64e9ee523801">网页富文本编辑器</h2>

<p><a href="http://wangeditor.github.io/">wangeditor</a> 轻量简介的富文本编辑器,使用容易,相比百度umeditor更简洁</p>

<h2 id="网页markdown编辑器:49483a20fa0a8bb8347c64e9ee523801">网页Markdown编辑器</h2>

<p><a href="https://github.com/pandao/editor.md">Editor.md</a> 一款开源的、可嵌入的 Markdown 在线编辑器（组件），基于 CodeMirror、jQuery 和 Marked 构建。</p>

<p><a href="https://github.com/tylingsoft/markdown-plus">markdown-plus</a> Markdown Plus,界面不是很漂亮,也有收费的桌面APP</p>

<h2 id="字体相关:49483a20fa0a8bb8347c64e9ee523801">字体相关</h2>

<p><a href="http://www.youziku.com/">有字库中文字体</a> 在线字体,CDN引用</p>

<p><a href="http://font-spider.org/">字蛛</a> 中文字体压缩器,让网页自由引入中文字体成为可能</p>

<p><a href="http://www.iconfont.cn/">阿里iconfont</a> 阿里巴巴的网页矢量图标在线生成工具,中文字体和矢量图标</p>

<h2 id="镜像网站-cdn:49483a20fa0a8bb8347c64e9ee523801">镜像网站/CDN</h2>

<p><a href="http://npm.taobao.org/">淘宝NPM镜像</a></p>

<p><a href="https://css.net/">常用前端公共库css.net</a> 包括Gravatar,Google 字体库等反代,支持https</p>

<p><a href="http://www.bootcdn.cn/">bootcdn</a> 支持https</p>

<h2 id="云端ide:49483a20fa0a8bb8347c64e9ee523801">云端IDE</h2>

<p><a href="https://coderpad.io/">coderpad</a> 在线运行多种语言代码,保存分享,不过是收费的,我创建的<a href="https://coderpad.io/GP2KRHQQ">演示</a></p>

<h2 id="视频解析:49483a20fa0a8bb8347c64e9ee523801">视频解析</h2>

<p><a href="http://keepvid.com/">keepvid</a> 支持多种国外视频网站解析,转码</p>

<p><a href="http://www.clipconverter.cc/">clipconverter</a> 支持youtube视频解析,转码,多分辨率,速度又快.</p>

<p><a href="http://www.youtube-dl.org/">youtube-dl</a> 全平台的YouTube视频下载工具</p>

<h2 id="图床:49483a20fa0a8bb8347c64e9ee523801">图床</h2>

<p><a href="https://sm.ms/">smms</a></p>

<p><a href="https://get-link.xyz/">get-link</a></p>

<p><a href="http://v2ex.com/t/278912#reply24">two.yt</a></p>

<h2 id="前端-node:49483a20fa0a8bb8347c64e9ee523801">前端/Node</h2>

<p>Ajax库<a href="https://github.com/visionmedia/superagent">superagent</a> 同时兼容IE9+和NodeJs的Ajax小工具,Gzip后仅为4.4kb</p>

<p>轮播图插件<a href="http://slidesjs.com/">slidesjs</a> 纯js的jQuery轮播图插件,简单易用响应式支持触摸,压缩后大小仅12kb,Gzip后3.3kb,但是单张图片存在bug,很久没有更新</p>

<p>模板引擎<a href="http://aui.github.io/artTemplate/">artTemplate</a> 性能卓越的Js模板引擎,同时有NodeJs版本,压缩后5kb大小,Gzip后2.9kb</p>

<p>url解析工具<a href="https://github.com/websanova/js-url">js-url</a> 解析url的query_string hostname protocol 等等,~1.7 Kb minified, ~0.7Kb gzipped</p>

<p>获取你的内网IP和外网IP<a href="https://github.com/diafygi/webrtc-ips">webrtc-ips</a> 通过Webrtc技术连接stun服务器,取得IP</p>

<p><a href="https://github.com/amsul/pickadate.js">https://github.com/amsul/pickadate.js</a>
<a href="https://github.com/xdan/datetimepicker">https://github.com/xdan/datetimepicker</a>
<a href="https://github.com/rmm5t/jquery-timeago">https://github.com/rmm5t/jquery-timeago</a>
<a href="http://c3js.org/">http://c3js.org/</a>
<a href="https://github.com/datejs/Datejs/blob/master/build/date.js">https://github.com/datejs/Datejs/blob/master/build/date.js</a>
<a href="https://github.com/Teamweek/instadate">https://github.com/Teamweek/instadate</a></p>

<h2 id="js插件:49483a20fa0a8bb8347c64e9ee523801">JS插件</h2>

<p><a href="http://www.swiper.com.cn/">swiper滑动插件</a></p>

<h2 id="测试工具:49483a20fa0a8bb8347c64e9ee523801">测试工具</h2>

<p><a href="http://www.alibench.com/">阿里测</a> 测试你的服务器在全国各地的响应速度
<a href="http://www.cloudping.info/">cloudping</a> 测试亚马逊云各节点到你电脑的延时
<a href="http://requestb.in/">requestb</a> 测试你发送的HTTP请求</p>

<h2 id="代码转换:49483a20fa0a8bb8347c64e9ee523801">代码转换</h2>

<p>将python代码转化为可执行文件<a href="http://nuitka.net/pages/download.html">nuitka</a></p>

<h2 id="服务器vps:49483a20fa0a8bb8347c64e9ee523801">服务器VPS</h2>

<p><a href="http://cheapwindowsvps.com/">cheapwindowsvps</a> G口亚洲越南和新加坡不限流量支持Windows
<a href="https://dedistation.com/billing/order.php?step=0&amp;productGroup=13">dedistation</a>
<a href="http://www.winode.org/cart.php?gid=15&amp;language=chinese">winode</a></p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/mac-chrome-input-submit/"> MacOs上Chrome中的submit按钮默认样式问题</a>
			</h1>
			<p class="post-date">Tue, Jan 5, 2016</p>
			<div class="post-text">
				<p>发现MacOs的Chrome中,input为submit的按钮,添加其他样式不生效,任然是默认样式,
解决方法是为其添加一个border或者backgroud就好了</p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/using-docker/"> 开启docker之旅</a>
			</h1>
			<p class="post-date">Tue, Jan 5, 2016</p>
			<div class="post-text">
				

<h2 id="安装docker:6d93a80e55dc760775379b4fadc005db">安装Docker</h2>

<p>docker 安装需要Linux内核在3.10.0以上,仅支持Linux,在Windows和MacOs上也是基于虚拟机方式运行,需要提前安装虚拟机</p>

<p>OpenVZ的VPS内核版本较低,且不能升级,并不能作为docker server,但是可以使用docker client</p>

<ul>
<li>通过<code>df -lhT</code> 看到Type为simfs,而不是ext3,ext4,一般就代表使用的是OpenVZ虚拟化的</li>
<li>查看系统内核版本<code>uname -r</code></li>
</ul>

<p>查看安装的系统版本
<code>lsb_release -a</code> 或者 <code>cat /etc/issue</code></p>

<p>以下二种方法适用于RedHat,CentOS</p>

<ul>
<li><code>cat /etc/redhat-release</code> 或者 <code>cat /etc/centos-release</code></li>
<li><code>rpm -q centos-release</code> 或者 <code>rpm -q redhat-release</code></li>
</ul>

<p>查看是否是64位系统<code>uname -i</code></p>

<h3 id="下载安装:6d93a80e55dc760775379b4fadc005db">下载安装</h3>

<p><strong>docker-1-11-1</strong> <a href="http://www.oschina.net/news/72899/docker-1-11-1">各平台下载地址</a></p>

<p>或者<code>http://get.daocloud.io/docker/builds/</code>查看</p>

<p>docker采用Go语言编写,编译以后生成一个无依赖的可执行文件.</p>

<p>安装完整以后,可以移动到<code>/usr/bin</code>,即可使用<code>docker</code>和<code>sudo docker</code>命令</p>

<pre><code>wget https://get.docker.com/builds/Linux/x86_64/docker-1.11.1.tgz
tar zxvf docker-1.11.1.tgz
cd docker
ls -lh
</code></pre>

<p>得到如下:</p>

<pre><code>total 66M
-rwxr-xr-x 1 root root  34M Apr 27 08:38 docker
-rwxr-xr-x 1 root root  12M Apr 27 08:38 docker-containerd
-rwxr-xr-x 1 root root 9.1M Apr 27 08:38 docker-containerd-ctr
-rwxr-xr-x 1 root root 3.6M Apr 27 08:38 docker-containerd-shim
-rwxr-xr-x 1 root root 8.2M Apr 27 08:38 docker-runc
</code></pre>

<p>移动到<code>/usr/bin/</code> 即可替换旧版本 <code>mv * /usr/bin/</code></p>

<h2 id="基本使用:6d93a80e55dc760775379b4fadc005db">基本使用</h2>

<p>运行<code>docker -v</code>即可查看当前docker版本
docker 分为两部分,一分部是docker server , 一部分是docker client
在Linux下是一个可执行文件,在Windows上则是分开的.</p>

<p>搜索 <code>docker search 镜像名字</code>
下载 <code>docker pull learn/tutorial</code>, 下载时要写完整名字</p>

<p><a href="https://hub.docker.com/explore/">官方Docker镜像一览</a></p>

<p>下载官方ubuntu <code>docker pull ubuntu</code></p>

<p>运行此ubuntu <code>docker run ubuntu echo &quot;hello&quot;</code></p>

<p>运行完以后docker容器就退出了.</p>

<p>进入此ubuntu的shell
<code>docker run -i -t ubuntu /bin/bash</code> 也可以写为 <code>docker run -it ubuntu /bin/bash</code>
期间如果有需要退出按 <code>Ctrl+P+Q</code>,退出后,容器任然是运行的,<code>Ctrl+D</code>退出后容器停止</p>

<p><code>docker ps</code> 查看正在运行的docker容器,可以看到后台的docker
重新进入容器需要<code>docker attach CONTAINER</code> 此命令代表<code>Attach to a running container</code>.
CONTAINER可以是最前面的CONTAINER ID ,也可以是最后面的NAMES</p>

<p>你还可以使用 <code>docker run -it --name myname ubuntu /bin/bash</code> 来指定它使用的名字,否则名字的随机的</p>

<p>你可以用不同的名字同时运行多个此种镜像</p>

<p>使用 <code>docker rename hello hello2</code> 将原先名字为hello的容器改名为hello2</p>

<p>使用 <code>docker top hello2</code> 查看运行在hello2中的所有进程</p>

<p>使用 <code>docker pause hello2</code> 将docker hello2 中的所有进程暂停,使用<code>docker ps</code> 可以看到容器已经暂停了</p>

<p>使用 <code>docker unpass hello2</code> 恢复暂停的容器</p>

<p>使用 <code>docker stop hello2</code> 将名字为hello2的容器停止</p>

<p>使用 <code>docker ps -a</code> 查看所有的容器,将会看到很多容器,因为每次执行<code>docker run</code>命令都是<code>Run a command in a new container</code>新建了一个容器,
可以考虑使用 <code>docker start 容器名称</code> 然后再<code>docker attach</code> 进去,你上次的改动依然在那.</p>

<p>也可以考虑使用<code>docker rm 容器名称</code> 删除容器以节约资源,rm后可用空格分隔多个容器名称,此命令执行较慢
也可以在创建的时候指明结束运行时清除docker容器<code>docker run --rm ubuntu echo &quot;hello&quot;</code>
或者将要执行的命令附加到正在运行的容器上<code>docker exec hello2  echo &quot;hihi&quot;</code></p>

<p>使用<code>docker start -ia vps</code> 当<code>docker start</code>后立即退出,来不及attach时,采用这种方式</p>

<p>使用<code>docker rmi</code>来删除镜像
<code>docker ps</code> 默认显示当前正在运行中的container
<code>docker ps -a</code> 查看包括已经停止的所有容器
<code>docker ps -l</code> 显示最新启动的一个容器（包括已停止的）</p>

<p>使用<code>docker info</code>查看机器的配置,docker版本,容器和镜像的数量,存储驱动等</p>

<p>技巧:
attach是可以带上<code>--sig-proxy=false</code>来确保<code>CTRL-D</code>或<code>CTRL-C</code>不会关闭容器</p>

<ul>
<li>删除所有停止运行的容器 <code>docker rm $(docker ps -a -q)</code></li>
<li>获取最后(-l)一个启动的容器id(-q) <code>docker ps -l -q</code></li>
</ul>

<p>这是一些经常使用的镜像相关的数据：</p>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>大小</th>
</tr>
</thead>

<tbody>
<tr>
<td>scratch</td>
<td>基础镜像</td>
<td>大小为0</td>
</tr>

<tr>
<td>busybox</td>
<td>最小Unix系统 (uClibc)</td>
<td>1.1MB</td>
</tr>

<tr>
<td>Alpine</td>
<td>基于busybox(musl)</td>
<td>4.8MB</td>
</tr>

<tr>
<td>CirrOS</td>
<td>最小化的Linux发行版</td>
<td>7.7MB</td>
</tr>

<tr>
<td>ubuntu:16.04</td>
<td>Ubuntu</td>
<td>121MB</td>
</tr>

<tr>
<td>debian:jessie</td>
<td>Debian最新版</td>
<td>125MB</td>
</tr>

<tr>
<td>centos:latest</td>
<td>Centos最新版</td>
<td>196MB</td>
</tr>
</tbody>
</table>

<h2 id="文件系统:6d93a80e55dc760775379b4fadc005db">文件系统</h2>

<p>把一个宿主机上的目录挂载到镜像里</p>

<p><strong>通过挂载的方式</strong></p>

<blockquote>
<p>通过-v参数,冒号前为宿主机目录,必须为绝对路径,冒号后为镜像内挂载的路径.</p>
</blockquote>

<p><code>docker run -it --name tmp -v /data/tmp:/home ubuntu /bin/bash</code></p>

<p>宿主目录不存在会自动创建,但是镜像内挂载路径必须存在,挂载后双向可写,实时生效
此镜像将一直保持挂载,stop,exit后重新进入,依然是挂载状态.</p>

<p>默认挂载的路径权限为读写.如果指定为只读可以用：ro
<code>docker run -it --name tmp -v /data/tmp:/home:ro ubuntu /bin/bash</code>
挂载后,镜像内对挂载的数据不可写</p>

<p>docker还提供了一种高级的用法,叫数据卷.
数据卷：&rdquo;其实就是一个正常的容器,专门用来提供数据卷供其它容器挂载的&rdquo;.感觉像是由一个容器定义的一个数据挂载信息.其他的容器启动可以直接挂载数据卷容器中定义的挂载信息.</p>

<p>创建一个普通容器,定义一个名称,挂载目录. 数据容器是不需要运行的.</p>

<p><code>docker run -v /data/tmp:/home  --name datafs busybox</code></p>

<p>其他容器使用这个数据卷
<code>docker run -it --name tmp --volumes-from datafs ubuntu /bin/bash</code></p>

<p><strong>通过volume方式(建议使用这种最新的方式)</strong></p>

<p>docker1.9可以使用<code>docker volume create --name datafs</code>创建<code>volume</code>
使用时类似<code>docker run --name=yourcontainername -p 10022:22 -p 10080:3000 -v datafs:/data ubuntu</code></p>

<p><code>docker volume ls</code> 查看创建的<code>volume</code></p>

<p><code>docker volume rm</code>用来删除</p>

<p><code>docker volume inspect datafs</code>查看详情</p>

<p>这些数据是放在<code>/var/lib/docker/volumes/</code>下面的</p>

<p>docker的container是无状态的,也就是说标记状态的数据,例如：数据库数据,应用程序的log等等,是不应该放到container里的,而是放到 Data Volume Container里</p>

<p>建议使用Data Volume Container不要使用过去的方法了</p>

<h2 id="网络系统:6d93a80e55dc760775379b4fadc005db">网络系统</h2>

<p>使用<code>-p</code>进行映射端口,第一个是外部端口,第二个是内部端口</p>

<p>默认的规则是TCP,如果需要UDP,采用类似<code>-p 1234:1234/udp</code></p>

<p><code>-p 80:8080</code>容器内部的8080端口,对外暴漏于80端口
<code>-p 22</code>内部是22端口映射,外部则为一个随机可用的端口,<code>-P</code>则是将Dockerfile里EXPOSE的所有端口分配到宿主机的动态端口上,EXPOSE的端口不创建和宿主机的映射,是不能直接访问的</p>

<p>-p参数只能在<code>docker run</code>时指明,一旦生成了container就不能修改端口映射
可以采用如下方式生成新的容器修改</p>

<pre><code>docker stop vps
docker commit vps vpsimage
docker rm vps
docker run -it -p 8080:8000 --name vps vpsimage bash
</code></pre>

<p>多个端口类似<code>docker run -it --name vps -p 443:443 -p 80:8080 -p 8000:80 vpsimage bash</code></p>

<p>使用<code>docker port vps</code>可以查看此容器当前的端口映射,容器停止后,<code>docker port vps</code>不会显示出来,他显示的是正在工作的.</p>

<p><code>docker inspect vps</code> 查看容器的详细配置信息,包括端口映射,来源镜像,日志存储路径,内存,CPU等</p>

<h2 id="容器与镜像:6d93a80e55dc760775379b4fadc005db">容器与镜像</h2>

<p><code>docker export</code> <code>docker import</code>  与  <code>docker save</code>  <code>docker load</code></p>

<p>导出后再导入<code>exported-imported</code>的镜像会丢失所有的历史.
而保存后再加载<code>saveed-loaded</code>的镜像没有丢失历史和层(layer).
这意味着使用导出后再导入的方式,你将无法回滚到之前的层(layer),
同时,使用保存后再加载的方式持久化整个镜像,就可以做到层回滚（可以执行<code>docker tag &lt;LAYER ID&gt; &lt;IMAGE NAME&gt;</code>来回滚之前的层）
<code>docker history vpsimage</code> 查看镜像的变迁历史</p>

<blockquote>
<p>Export命令用于持久化容器[Export a container&rsquo;s filesystem as a tar archive]</p>

<p>Save命令用于持久化镜像[Save an image(s) to a tar archive]</p>
</blockquote>

<p><strong>容器</strong></p>

<p><code>docker ps -a</code> 查看所有的容器,包含已经停止的,暂停的,在运行的等,可以恢复运行,停止等,删除使用<code>docker rm xx</code></p>

<p>修改容器名字:<code>docker rename old new</code></p>

<p>导出:<code>docker export vps &gt; vpsdata.tar</code></p>

<p>导入:<code>cat /home/vpsdata.tar | docker import – yourname</code>,也可以通过指定 URL 或者某个目录来导入<code>docker import http://example.com/exampleimage.tgz example/imagerepo</code></p>

<p><strong>镜像</strong></p>

<p><code>docker images</code> 显示本机上存在的资源,大部分是<code>docker pull</code>下来的,可以使用 <code>docker rmi xx</code> 删除</p>

<p>修改镜像名字:<code>docker tag old new</code> 然后 <code>docker rmi old</code></p>

<p>导出:<code>docker save vpsimage &gt; image.tar</code></p>

<p>导入:<code>docker load &lt; /home/image.tar</code></p>

<p>docker server 与 client 分离时,save,export等操作会非常慢,因为会通过网络把生成的文件下载到本地.</p>

<blockquote>
<p><code>docker rm $(docker ps -q -a)</code> 一次性删除所有的容器</p>

<p><code>docker rmi $(docker images -q)</code> 一次性删除所有的镜像</p>
</blockquote>

<h2 id="国内加速:6d93a80e55dc760775379b4fadc005db">国内加速</h2>

<p><code>docker pull</code> 默认采用https通信,国内一般提供镜像,或者自己的registry,可以采用
例如<code>docker pull registry.aliyuncs.com/suconghou/http</code> 这种方式指明registry</p>

<p><a href="https://dev.aliyun.com/search.html">阿里云的registry</a>,提供私有,公开docker镜像,但是并不是dockerhub的镜像</p>

<p>Daocloud提供的Docker服务地址 daocloud.io
并提供单独域名的加速器, <code>--registry-mirror=http://xxx.m.daocloud.io</code> 可以指定docker启动时使用的registry</p>

<p>网易提供的镜像 <a href="https://hub-mirror.c.163.com/">https://hub-mirror.c.163.com/</a></p>

<h2 id="使用流程:6d93a80e55dc760775379b4fadc005db">使用流程</h2>

<p>配置为<code>service</code> 见
<a href="https://docs.docker.com/v1.7/articles/systemd/">https://docs.docker.com/v1.7/articles/systemd/</a></p>

<p><a href="https://github.com/docker/docker/tree/master/contrib/init/systemd">https://github.com/docker/docker/tree/master/contrib/init/systemd</a></p>

<p><code>vim /etc/systemd/system/docker.service</code></p>

<pre><code>[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network.target docker.socket
Requires=docker.socket

[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker
ExecStart=/usr/bin/docker daemon -H fd://
MountFlags=slave
LimitNOFILE=1048576
LimitNPROC=1048576
LimitCORE=infinity
# Uncomment TasksMax if your systemd version supports it.
# Only systemd 226 and above support this version.
#TasksMax=infinity
TimeoutStartSec=0
# set delegate yes so that systemd does not reset the cgroups of docker containers
Delegate=yes

[Install]
WantedBy=multi-user.target
</code></pre>

<p><code>vim /etc/systemd/system/docker.socket</code></p>

<pre><code>[Unit]
Description=Docker Socket for the API
PartOf=docker.service

[Socket]
ListenStream=/var/run/docker.sock
SocketMode=0660
SocketUser=root
SocketGroup=docker

[Install]
WantedBy=sockets.target
</code></pre>

<pre><code>sudo groupadd docker
</code></pre>

<p>重新加载配置 <code>sudo systemctl daemon-reload</code>
<code>sudo systemctl restart docker</code>
当你的docker不支持<code>devicemapper</code>存储驱动时,会报错
可以使用<code>-s overlay</code> 参数指定存储驱动</p>

<p><code>ExecStart=/usr/bin/docker daemon -s overlay -H fd://</code></p>

<p>如果已经启动<code>docker daemon</code>但是任然无法连接上,查看<code>systemctl status  docker.service</code>
监听是否正确,如正确,查看当前登录的用户是否和docker用户一个组内
假设当前登录用户是root</p>

<pre><code>sudo usermod -aG docker root
newgrp docker
</code></pre>

<p>再次重启docker daemon,退出当前用户再次登录</p>

<h2 id="根据dockerfile创建:6d93a80e55dc760775379b4fadc005db">根据Dockerfile创建</h2>

<p><code>sudo docker build -t=&quot;user/imgname:tag&quot; .</code></p>

<p>其中-t标记来添加 tag,指定新的镜像的用户信息.</p>

<p>&rdquo;.&rdquo; 是 Dockerfile 所在的路径（当前目录）,也可以替换为一个具体的 Dockerfile 的路径.</p>

<h2 id="文件结构:6d93a80e55dc760775379b4fadc005db">文件结构</h2>

<p>进入目录查看 <code>/var/lib/docker</code></p>

<p><code>volumes</code> 目录里存放着创建的<code>Data Volume Container</code></p>

<p><code>containers</code> 目录存储启动的容器配置信息,查看<code>docker ps -a</code>里的CONTAINER ID和此文件夹下某些目录的前几位是相同的</p>

<p><code>graph</code> pull的镜像信息保存在了graph文件夹下,镜像的内容存在了<code>devicemapper/devicemapper/data</code> 下,根据存储驱动不同,也可能存放在<code>overlay</code>目录,这些目录都比较大</p>

<p><code>ls -lh /var/lib/docker/graph/</code>,进入一个文件夹,文件夹内保存着:</p>

<blockquote>
<p>json -保存着关于这个镜像的元数据, <code>cat json | python -mjson.tool</code></p>

<p>layersize – 一个整数,表示layer的大小.</p>

<p>checksum - 一个sha256值</p>
</blockquote>

<p><code>image</code></p>

<h3 id="存储驱动:6d93a80e55dc760775379b4fadc005db">存储驱动</h3>

<p>做paas一般使用aufs驱动,用于存储大量的docker,但是aufs只在ubuntu系的内核才自带此功能.</p>

<p>devicemapper驱动将所有文件存储在一个100G的虚拟磁盘,但是静态编译好的二进制文件不支持此驱动</p>

<p>overlay驱动将镜像里的各个文件还是存储在磁盘的各个文件,镜像过多存储的文件数量也很多,一般兼容性较好</p>

<h2 id="构建镜像:6d93a80e55dc760775379b4fadc005db">构建镜像</h2>

<p>build images 使用
<code>docker build -t=&quot;http&quot; .</code></p>

<p>-t 指明tag
后面的.指明Dockerfile所在的目录</p>

<h2 id="关联远端docker-hub仓库:6d93a80e55dc760775379b4fadc005db">关联远端Docker Hub仓库</h2>

<p><code>docker login</code>
输入用户名,密码,邮箱登陆</p>

<p><code>docker push yourname/imagename</code></p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/linux-download-tools/"> Linux下常用的下载利器</a>
			</h1>
			<p class="post-date">Fri, Jan 1, 2016</p>
			<div class="post-text">
				

<h2 id="wget:d42214d24013398e63cb86bbdfbd2d55">wget</h2>

<p><code>wget -c -O filename &quot;http://xx.com&quot;</code> 下载存储到指定文件,并指定断点续传
<code>wget -nc -c -i url.txt</code> 批量下载文件中指定的资源(每行一个连接),跳过已下载的(同名的),并且断点续传.</p>

<h2 id="curl:d42214d24013398e63cb86bbdfbd2d55">curl</h2>

<p>常用的命令</p>

<p><code>curl http://xx.com</code> 只获取http消息正文</p>

<p><code>curl -I http://xx.com</code> 只获取http消息头</p>

<p><code>curl -i http://xx.com</code> 获取http消息头和正文</p>

<p><code>curl -d &quot;name=abc&amp;pass=123&quot; http://xx.com</code> 发送<code>http post</code>请求,采用的是<code>application/x-www-form-urlencoded</code>形式</p>

<p><code>curl -F &quot;name=abc&quot; -F &quot;pass=123&quot; http://xx.com</code> 发送<code>http post</code>请求,采用的是<code>multipart/form-data</code> 形式,此两种方式都可以由 $_POST 接收</p>

<p><code>curl -F &quot;name=abc&quot; -F &quot;file=@/tmp/1.jpg&quot; http://xx.com</code> 发送 <code>http post</code>请求, <code>multipart/form-data</code> 形式还可以上传文件,只需改为@加路径</p>

<p>curl 不仅能用来下载,还是网络调试的利器,Chrome的网络请求也可以直接另存为curl请求格式</p>

<p>批量下载规则的URL资源</p>

<pre><code>curl -O &quot;http://www.example.com/[0001-9999].jpg&quot;

</code></pre>

<p>在shell中可以这样用,实现同样功能</p>

<pre><code>for i in {10001..19999}; do
wget www.example.com/${i:1}.jpg;
done
</code></pre>

<p>或</p>

<pre><code>for i in {0001..9999}; do
echo www.example.com/${i}.jpg;
done
</code></pre>

<h2 id="axel:d42214d24013398e63cb86bbdfbd2d55">Axel</h2>

<p>下载速度最快,分段下载速度优异
<code>axel -n 30 -a -o localfilename http://xx.com/downloadfile</code> 30个线程分段下载,存储为localfilename
参数<code>-a</code>更新进度条而不是每次都输出
参数<code>-H</code> 添加header,参数<code>-U</code>设定<code>user-agent</code>
<strong>Downloads patch from 4 ftp mirrors</strong>
axel <a href="ftp://ftp.{us,uk,br,fr}.kernel.org/pub/linux/kernel/v2.6/patch-2.6.39.gz">ftp://ftp.{us,uk,br,fr}.kernel.org/pub/linux/kernel/v2.6/patch-2.6.39.gz</a></p>

<p>axel <a href="http://itmp.suconghou.cn">http://itmp.suconghou.cn</a> hypriot-rpi-20160306-192317.img.zip <a href="http://wtmp.suconghou.cn">http://wtmp.suconghou.cn</a> hypriot-rpi-20160306-192317.img.zip <a href="http://btmp.suconghou.cn">http://btmp.suconghou.cn</a> hypriot-rpi-20160306-192317.img.zip</p>

<h2 id="aria2c:d42214d24013398e63cb86bbdfbd2d55">Aria2c</h2>

<p>aria2c支持多种协议,<code>URI</code> <code>MAGNET</code> <code>TORRENT_FILE</code> <code>METALINK_FILE</code>,也支持axel类似的分段下载</p>

<p><code>aria2c -s 30 -c -o localfilename http://xx.com/downloadfile</code> 30个线程分段下载,存储为localfilename,并断点续传</p>

<p><code>aria2c file1.torrent file2.torrent</code></p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/install-nginx-php-mysql-redis/"> 安装PHP7和NGINX</a>
			</h1>
			<p class="post-date">Fri, Jan 1, 2016</p>
			<div class="post-text">
				

<h2 id="编译安装nginx:aa93c013153cd0b80f2e19308ae27e8a">编译安装NGINX</h2>

<p>首先安装一些依赖</p>

<pre><code>yum -y install gcc make autoconf automake install zlib zlib-devel openssl openssl-devel pcre-devel
</code></pre>

<pre><code>apt-get update
apt-get -y install gcc make  openssl libssl-dev libpcre3 libpcre3-dev
</code></pre>

<p>编译安装</p>

<pre><code>cd /tmp
wget http://nginx.org/download/nginx-1.11.0.tar.gz
tar -zxvf nginx-1.11.0.tar.gz
cd nginx-1.11.0
export CFLAGS=&quot;-O3&quot;
./configure
make &amp;&amp; make install
</code></pre>

<p>还可以添加<a href="https://github.com/cuber/ngx_http_google_filter_module">Google反代模块</a>,按下面操作编译</p>

<pre><code>cd /tmp
git clone https://github.com/cuber/ngx_http_google_filter_module
git clone https://github.com/yaoweibin/ngx_http_substitutions_filter_module
wget http://nginx.org/download/nginx-1.11.0.tar.gz
tar -zxvf nginx-1.11.0.tar.gz
cd nginx-1.11.0
export CFLAGS=&quot;-O3&quot;
./configure  --with-http_ssl_module  --add-module=/tmp/ngx_http_google_filter_module  --add-module=/tmp/ngx_http_substitutions_filter_module
make &amp;&amp; make install
</code></pre>

<p>注意:重复执行,需要清理上次编译数据<code>make clean</code></p>

<p><code>nginx -V</code> 查看编译的参数和已加载的模块</p>

<pre><code>server {
	listen       80;
	server_name  g.suconghou.cn google.com www.google.com;
	resolver 8.8.8.8;
	expires 1d;
	gzip on;
	gzip_min_length 1024;
	gzip_proxied any;
	gzip_comp_level 3;
	gzip_types text/plain text/javascript text/css text/json application/javascript  application/json image/jpeg image/gif image/png;
	proxy_hide_header Set-Cookie;
	proxy_hide_header Alt-Svc;
	proxy_hide_header Alternate-Protocol;
	location / {
			google on;
			google_scholar on;
	}

}

</code></pre>

<blockquote>
<p>使用我编译的google代理的docker版本更易部署 <a href="https://hub.docker.com/r/suconghou/nginx-google/">https://hub.docker.com/r/suconghou/nginx-google/</a></p>
</blockquote>

<h3 id="各模块说明:aa93c013153cd0b80f2e19308ae27e8a">各模块说明</h3>

<p>http_gzip_module提供了对gzip的基本的支持，默认是编译到nginx的发行版本里面的。</p>

<p>http_gzip_static_module则是针对nginx serve的静态文件，需要编译进去才能有。比如a.html，如果启用了<code>gzip_static on</code>，如果同一目录下还有a.html.gz作为a.html压缩版本存在，那么nginx会以a.html.gz作为a.html的gzip version来serve。</p>

<h3 id="配置gzip:aa93c013153cd0b80f2e19308ae27e8a">配置Gzip</h3>

<p><code>gzip on</code> 开启Gzip</p>

<p><code>gzip_proxied any</code></p>

<h3 id="可能需要移动配置目录:aa93c013153cd0b80f2e19308ae27e8a">可能需要移动配置目录</h3>

<p>在<code>nginx.conf</code>中配置<code>include /usr/local/nginx/conf/conf.d/*.conf;</code></p>

<p>建立目录<code>mkdir /etc/nginx/conf.d</code></p>

<p>使用<code>ln -s /etc/nginx/conf.d /usr/local/nginx/conf/conf.d</code>建立软连接</p>

<h3 id="修改nginx配置:aa93c013153cd0b80f2e19308ae27e8a">修改Nginx配置</h3>

<p><strong>设置最大上传文件大小</strong>,配置<code>nginx.conf</code></p>

<p><code>client_max_body_size 50m</code> Default value for client_max_body_size is 1 MiB,超过大小报错<code>413 Request Entity Too Large</code></p>

<p>静态由Nginx,动态转到后端</p>

<pre><code>root /home/demo/goproj/src/Test/public;
try_files $uri/index.html $uri.html $uri @goapp;

location @goapp {
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header Host $http_host;
  proxy_redirect off;
  proxy_pass http://localhost:8080;
}
</code></pre>

<h3 id="卸载apache:aa93c013153cd0b80f2e19308ae27e8a">卸载apache</h3>

<p>1.完全卸载使用apt-get安装的apache
1、sudo apt-get remove apache2
2、sudo apt-get remove apache2.2-common
3、sudo apt-get autoremove (此命令会自动卸载PHP)
卸载完成</p>

<p>2.rpm 方式安装的</p>

<pre><code>rpm -qa|grep httpd
</code></pre>

<p>得出结果
httpd-2.2.15-39.el6.centos.i686
httpd-tools-2.2.15-39.el6.centos.i686</p>

<p>从上往下一个一个卸载</p>

<pre><code>rpm -e httpd-2.2.15
rpm -e httpd-tools
</code></pre>

<p>ab压力测试在httpd-tools,可以不卸载;
CenterOS 安装 ab 压力测试</p>

<pre><code>yum install httpd-tools
</code></pre>

<h2 id="编译安装php7:aa93c013153cd0b80f2e19308ae27e8a">编译安装PHP7</h2>

<p>最好先<code>yum update</code>一下,再安装以下依赖</p>

<pre><code>yum install -y git wget curl curl-devel gcc gcc-c++ libmarypt cmake  autoconf libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libpng libpng-devel libxml2 libxml2-devel zlib zlib-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses curl openssl-devel gdbm-devel db4-devel libXpm-devel libX11-devel gd-devel gmp-devel readline-devel libxslt-devel expat-devel xmlrpc-c xmlrpc-c-devel
</code></pre>

<p>下载PHP7最新版本,解压,有多重压缩格式可选,其中xz最小</p>

<pre><code>wget http://php.net/distributions/php-7.0.7.tar.xz
tar -xJf php-7.0.7.tar.xz
cd php-7.0.7
</code></pre>

<p>编译之前,可以开启O3编译优化,生成的可执行文件更小,性能更好
<code>export CFLAGS=&quot;-O3&quot;</code></p>

<p>包含部分常用扩展的编译</p>

<pre><code>./configure --enable-inline-optimization --enable-static=yes --prefix=/tmp --with-config-file-path=/etc --disable-cgi  --enable-posix --enable-pcntl --enable-sockets --enable-ftp --enable-bcmath --enable-zip --enable-mbstring --with-iconv --with-mysqli --with-pdo-mysql --with-curl --with-gd --with-openssl --with-mcrypt
</code></pre>

<p>功能更全的编译</p>

<pre><code>export CFLAGS=&quot;-O3&quot;
./configure --enable-inline-optimization --enable-static=yes --prefix=/usr/local --with-config-file-path=/etc --disable-cgi --enable-opcache --enable-fpm  --enable-posix --enable-pcntl --enable-sockets --enable-ftp --enable-bcmath  --enable-zip --enable-mbstring --with-iconv --with-mysqli --with-pdo-mysql --with-curl --with-gd  --with-openssl --with-mcrypt
make &amp;&amp; make install
</code></pre>

<p>其他扩展
<code>--enable-exif --enable-calendar --with-libzip --with-xsl --with-bz2</code></p>

<p>其中部分步骤可能需要root权限</p>

<h3 id="可能出现的错误:aa93c013153cd0b80f2e19308ae27e8a">可能出现的错误</h3>

<p>1.curl未安装
执行
<code>yum install curl-devel</code>
或者 <code>sudo apt-get install curl libcurl3 libcurl3-dev</code>
然后再次尝试编译</p>

<p>2.需要安装libcrytpt</p>

<pre><code>wget ftp://mcrypt.hellug.gr/pub/crypto/mcrypt/attic/libmcrypt/libmcrypt-2.5.7.tar.gz
</code></pre>

<p>安装：</p>

<pre><code>tar -zxvf libmcrypt-2.5.7.tar.gz
cd libmcrypt-2.5.7
mkdir -p /usr/local/libmcrytpt
./configure prefix=/usr/local/libmcrytpt/
make &amp;&amp; make install
</code></pre>

<p>然后重新编译,设定编译参数mcrypt指定路径:
<code>--with-mcrypt=/usr/local/libmcrytpt/</code></p>

<ol>
<li>OpenSSL相关错误</li>
</ol>

<p><code>Cannot find OpenSSL's &lt;evp.h&gt;</code>
或者</p>

<pre><code>Undefined symbols for architecture x86_64:
  &quot;_PKCS5_PBKDF2_HMAC&quot;, referenced from:
      _zif_openssl_pbkdf2 in openssl.o
  &quot;_SSL_CTX_set_alpn_protos&quot;, referenced from:
      _php_openssl_setup_crypto in xp_ssl.o
  &quot;_SSL_CTX_set_alpn_select_cb&quot;, referenced from:
      _php_openssl_setup_crypto in xp_ssl.o
  &quot;_SSL_get0_alpn_selected&quot;, referenced from:
      _php_openssl_sockop_set_option in xp_ssl.o
  &quot;_SSL_select_next_proto&quot;, referenced from:
      _server_alpn_callback in xp_ssl.o
  &quot;_TLSv1_1_client_method&quot;, referenced from:
      _php_openssl_setup_crypto in xp_ssl.o
  &quot;_TLSv1_1_server_method&quot;, referenced from:
      _php_openssl_setup_crypto in xp_ssl.o
  &quot;_TLSv1_2_client_method&quot;, referenced from:
      _php_openssl_setup_crypto in xp_ssl.o
  &quot;_TLSv1_2_server_method&quot;, referenced from:
      _php_openssl_setup_crypto in xp_ssl.o
</code></pre>

<p>解决:
Linux上 <code>yum install openssl openssl-devel</code></p>

<p>Mac上编译须做如下配置</p>

<p><code>brew install openssl</code> 然后执行 <code>brew link openssl --force</code> 并添加环境变量
<code>export LDFLAGS=&quot;/usr/local/opt/openssl/lib/libssl.dylib /usr/local/opt/openssl/lib/libcrypto.dylib&quot;</code></p>

<p>4.configure: error: xml2-config not found. Please check your libxml2 installation.</p>

<pre><code>apt-get install libxml2 libxml2-dev libmcrypt-dev openssl libssl-dev libcurl4-openssl-dev
</code></pre>

<p>5.Cannot find OpenSSL&rsquo;s libraries</p>

<pre><code>apt-get install libmcrypt-dev openssl libssl-dev libcurl4-openssl-dev
</code></pre>

<p>6.configure: error: png.h not found.</p>

<pre><code>apt-get install libjpeg-dev libpng-dev
</code></pre>

<ol>
<li>make: *** [ext/fileinfo/libmagic/apprentice.lo] Error 1</li>
</ol>

<p>这是由于内存小于1G所导致.可以<code>--disable-fileinfo</code>,或者添加添加零时的swap</p>

<pre><code>#创建一个大小为256M的文件
dd if=/dev/zero of=/swapfile bs=1024 count=262144
#把这个文件变成swap文件
mkswap /swapfile
#启用这个swap文件
swapon /swapfile
</code></pre>

<p>如果要每次开机就加载</p>

<pre><code>#编辑/etc/fstab文件，使在每次开机时自动加载swap文件
/swapfile    swap    swap    default   0 0
</code></pre>

<blockquote>
<p>注意:XEN KVM 可以创建SWAP,OVZ本身就是Virtual Environmen,不支持创建SWAP</p>

<p>通过<code>df -lhT</code> 看到Type为simfs,而不是ext3,ext4,一般就不支持</p>
</blockquote>

<p><strong>提示: make 可使用多核提升编译性能</strong></p>

<p>用make -j带一个参数，可以把项目进行并行编译，比如在一台双核的机器上，完全可以用<code>make -j4</code>，让make最多允许4个编译命令同时执行，这样可以更有效的利用CPU资源。</p>

<p>-O这个选项控制所有的优化等级。使用优化选项会使编译过程耗费更多的时间，并且占用更多的内存，尤其是在提高优化等级的时候。
-O2是推荐的优化等级,O3是最高等级。如果编译软件出现错误，请先检查是否启用了-O3</p>

<p>php编译完成以后,无缝升级php
只需<code>kill -USR2 php-fpm master 进程的PID</code>,向php-fpm master进程发送重启指令,php-fpm的master和worker都会重新加载配置,重新运行起来.
<code>curl -I 127.0.0.1</code>查看,新版本的fpm已经在工作了.</p>

<p>PHP的数据库长连接有没有效,
实际测试,采用香港服务器远程连接mysql,非长连接模式下耗时约600ms,使用PDO长连接,耗时下降到260ms左右,是有一定作用的.
但是长连接不适用于CLI模式,CLI模式下,php进程退出,连接即断开.</p>

<h2 id="安装一些其他扩展:aa93c013153cd0b80f2e19308ae27e8a">安装一些其他扩展</h2>

<p>php redis 扩展</p>

<pre><code>wget -c -O php-redis.zip https://github.com/phpredis/phpredis/archive/php7.zip
unzip php-redis.zip
cd phpredis-php7
phpize
./configure --enable-redis-igbinary
make &amp;&amp; make install

</code></pre>

<p>安装libmemcached,memcached依赖此项</p>

<pre><code>wget -c https://launchpad.net/libmemcached/1.0/1.0.18/+download/libmemcached-1.0.18.tar.gz
tar -xzf libmemcached-1.0.18.tar.gz -C /tmp
cd /tmp/libmemcached-1.0.18
./configure
make &amp;&amp; make install
</code></pre>

<p>php memcached 扩展</p>

<pre><code>wget -c -O php-memcached.zip https://github.com/php-memcached-dev/php-memcached/archive/php7.zip
unzip php-memcached.zip
cd php-memcached-php7
phpize
make &amp;&amp; make install
</code></pre>

<p>安装memcached,见<a href="http://memcached.org/downloads">http://memcached.org/downloads</a></p>

<pre><code>wget http://memcached.org/latest
tar -zxvf memcached-1.x.x.tar.gz
cd memcached-1.x.x
./configure &amp;&amp; make &amp;&amp; make test &amp;&amp; sudo make install
</code></pre>

<p>安装swoole扩展</p>

<pre><code>wget -c -O php-swoole.zip https://github.com/swoole/swoole-src/archive/master.zip
unzip php-swoole.zip
cd swoole-src-master
phpize
./configure
make &amp;&amp; make install
</code></pre>

<h2 id="静态编译redis-memcached-opcache到php7:aa93c013153cd0b80f2e19308ae27e8a">静态编译redis,memcached,opcache到php7</h2>

<pre><code>wget -c http://php.net/distributions/php-7.0.7.tar.xz
wget -c -O php-redis.zip https://github.com/phpredis/phpredis/archive/php7.zip
wget -c -O php-memcached.zip https://github.com/php-memcached-dev/php-memcached/archive/php7.zip
tar -xJf php-7.0.7.tar.xz
unzip php-redis.zip -d php-7.0.7/ext
unzip php-memcached.zip -d php-7.0.7/ext
export CFLAGS=&quot;-O3&quot;
cd php-7.0.7
rm -rf configure
./buildconf --force
./configure --help
./configure --enable-inline-optimization --enable-static=yes --prefix=/tmp --with-config-file-path=/etc --enable-opcache --enable-redis --enable-memcached --disable-memcached-sasl --enable-pcntl --enable-sockets --enable-ftp --enable-bcmath --enable-zip --enable-mbstring --with-iconv --with-mysqli --with-pdo-mysql --with-curl --with-gd --with-openssl
make
make install
</code></pre>

<p>可能出现的错误</p>

<p>1.<code>configure: error: no, sasl.h is not available. Run configure with --disable-memcached-sasl to disable this check</code></p>

<p>解决:</p>

<p><code>yum install cyrus-sasl-devel</code> 或 <code>sudo apt-get install libsasl2-dev</code></p>

<p>或者禁用掉</p>

<p>搭配PHP的配置</p>

<pre><code>server{
	listen 8080;
	server_name 127.0.0.1;
	index index.html index.php;
	root /data/sites/default;
	location / {
			try_files $uri $uri/ /index.php?$args;
	}
	location ~ \.php$ {
			try_files $uri /index.php?$args;
			fastcgi_pass  unix:/var/run/php-fpm.sock;
			fastcgi_index index.php;
			fastcgi_param SCRIPT_FILENAME  $document_root$fastcgi_script_name;
			include        fastcgi_params;
	}
}

</code></pre>

<p>一个Server实现多个域名,多个主机</p>

<pre><code>server{
	listen 8080;
	server_name *.git.suconghou.cn;
	index index.html index.php;
	if ($host ~* ^((\w+)\.git\.suconghou\.cn)$) {
			set $subdomain $2;
	}
	root /data/git/$subdomain;
	add_header X-Root &quot;$subdomain&quot;;
	location / {
			try_files $uri $uri/ /index.php?$args;
	}
	location ~ \.php$ {
			try_files $uri /index.php?$args;
			fastcgi_pass  unix:/var/run/php-fpm.sock;
			fastcgi_index index.php;
			fastcgi_param SCRIPT_FILENAME  $document_root$fastcgi_script_name;
			include        fastcgi_params;
	}

}
</code></pre>

<p>Nginx里同<code>fastcgi_params</code>文件一样,还存在一份配置<code>fastcgi.conf</code>,只不过后者多了一行<code>fastcgi_param  SCRIPT_FILENAME    $document_root$fastcgi_script_name;</code>
我们可以直接使用它来替换<code>fastcgi_params</code>文件配置,同时我们也都添加了try_files检测,也可以略去<code>fastcgi_index</code>,故可以简写为:</p>

<pre><code>location ~ \.php$ {
	try_files $uri /index.php?$args;
	fastcgi_pass  unix:/var/run/php-fpm.sock;
	include fastcgi.conf;
}
</code></pre>

<p>注意<code>fastcgi_param</code>指令是数组型的,内层替换外层,但是同级多次使用的时候，是新增而不是替换。注意不要重复使用.</p>

<p>php-fpm 运行时错误
1. [pool www] cannot get gid for group &lsquo;nobody&rsquo;
<code>groupadd nobody</code>或者
 修改php-fpm.conf</p>

<pre><code>user = www-data
group = www-data
</code></pre>

<h2 id="安装mariadb:aa93c013153cd0b80f2e19308ae27e8a">安装MariaDB</h2>

<pre><code>apt-get install mariadb-server
</code></pre>

<p>MySql</p>

<pre><code>apt-get install mysql-server
</code></pre>

<p>安装过程中要求设定一个root密码,安装完<code>service mysql status</code>查看运行状态,<code>sudo service mysql restart</code>可以重启</p>

<h2 id="开机启动脚本:aa93c013153cd0b80f2e19308ae27e8a">开机启动脚本</h2>

<p>Debian and Ubuntu function at <code>/lib/lsb/init-functions</code>
<code>ln -s  /lib/lsb/init-functions /etc/init.d/functions</code></p>

<p>nginx</p>

<pre><code>#!/bin/sh
#chkconfig: 2345 90 91

binpath=`which nginx`
prog=$(basename $binpath)
. /etc/init.d/functions
. /etc/sysconfig/network
[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0
[ -x $binpath ] || exit 0
[ -f /etc/sysconfig/$prog ] &amp;&amp; . /etc/sysconfig/$prog

start(){
	echo -n $&quot;Starting $prog: &quot;
	$prog || echo -n &quot;$prog already running&quot;
}
stop(){
	echo -n $&quot;Stopping $prog: &quot;
	$prog -s quit
}
restart(){
	stop
	sleep 1
	start
}
reload() {
	echo -n $&quot;Reloading $prog: &quot;
	$prog -s reload
}
case &quot;$1&quot; in
start)
    $1
    ;;
stop)
    $1
    ;;
restart)
    $1
    ;;
reload)
    $1
    ;;
*)
echo $&quot;Usage: $0 {start|stop|restart|reload}&quot;
exit 2
esac
</code></pre>

<h3 id="php-fpm:aa93c013153cd0b80f2e19308ae27e8a">php-fpm</h3>

<p><code>sudo vim /etc/init.d/php-fpm</code></p>

<pre><code>#!/bin/sh
#chkconfig: 2345 90 91

binpath=`which php-fpm`
prog=$(basename $binpath)
. /etc/init.d/functions
. /etc/sysconfig/network
[ &quot;$NETWORKING&quot; = &quot;no&quot; ] &amp;&amp; exit 0
[ -x $binpath ] || exit 0
[ -f /etc/sysconfig/$prog ] &amp;&amp; . /etc/sysconfig/$prog
pidfile=/var/run/php-fpm.pid


start(){
	echo -n $&quot;Starting $prog: &quot;
	$prog || echo -n &quot;$prog already running&quot;
}
stop(){
	echo -n $&quot;Stopping $prog: &quot;
	kill -INT `cat $pidfile`
}
restart(){
	stop
	sleep 1
	start
}
reload() {
	echo -n $&quot;Reloading $prog: &quot;
	kill -USR2 `cat $pidfile`
}
case &quot;$1&quot; in
start)
    $1
    ;;
stop)
    $1
    ;;
restart)
    $1
    ;;
reload)
    $1
    ;;
*)
echo $&quot;Usage: $0 {start|stop|restart|reload}&quot;
exit 2
esac
</code></pre>

<pre><code>##  添加执行权限
sudo chmod a+x /etc/init.d/nginx
sudo chmod a+x /etc/init.d/php-fpm

##  加入服务
sudo chkconfig --add nginx
sudo chkconfig --add php-fpm

##   开机自启
sudo chkconfig nginx on
sudo chkconfig php-fpm on

## 查看是否开机启动

sudo chkconfig --list nginx
</code></pre>

<p>Ubuntu里没有chkconfig
可以使用sysv-rc-conf
<code>sudo apt-get install sysv-rc-conf</code>
然后直接使用 sysv-rc-conf 来管理,或者<code>sudo sysv-rc-conf nginx on</code>直接把<code>/etc/init.d/nginx</code> 加入到系统自动 启动列表中</p>

			</div>
		</div>
		
	</div>
	<nav>
		
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/3/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        class="active"><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        >
        <a href="/page/5/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/5/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
	</nav>
</div>
	<div class="music-container">
	<div class="music-header">
	    <a class="fa-button home" href="javascript:music.show(0)"><i class="fa fa-home" title="Home"></i></a>
	    <a class="fa-button next" href="javascript:music.next()"><i class="fa fa-chevron-right" title="Next"></i></a>
	</div>
	<div class="backdrop"></div>
	<div class="music-player">
		<div class="cover">
            <img src="http://p4.music.126.net/ckfEE9UUGcnGHylQJ12ENA==/670702092966093.jpg?param=350y350">
            <div class="foredrag"><i class="fa fa-play"></i></div>
        </div>
        <div class="progress">
            <div class="elapse"></div>
        </div>
        <div class="detail">
            <div class="title">音乐标题</div>
            <div class="artist">歌手</div>
        </div>
	</div>
</div>
<div id="loader" style="z-index:99999;" class="pageload-overlay" data-opening="M 40 -21.875 C 11.356078 -21.875 -11.875 1.3560784 -11.875 30 C -11.875 58.643922 11.356078 81.875 40 81.875 C 68.643922 81.875 91.875 58.643922 91.875 30 C 91.875 1.3560784 68.643922 -21.875 40 -21.875 Z">
    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 80 60" preserveAspectRatio="xMidYMid slice"> <path d="M40,30 c 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 Z"/></svg>
</div>

	<footer class="footer">
		<div class="footer-nav">
			<ul>
				<li><a href="/post/">归档</a></li>
				<li><a href="/">专题</a></li>
				<li><a href="/life/">生活</a></li>
				<li><a href="/about/">关于</a></li>
			</ul>
		</div>
	</footer>
	<script type="text/javascript" src="/js/main.min.js" data-no-instant></script>
</body>
</html>


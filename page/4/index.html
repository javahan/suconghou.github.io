<!DOCTYPE html>
<html lang="en">
<head>
	<meta name="generator" content="Hugo 0.17" />
	<meta charset="UTF-8">
	<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
	<meta name='renderer' content='webkit'>
	<meta name='viewport' content='width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no'>
	<meta name='description' content='记录学习的点点滴滴'>
	<meta name='keywords' content='前端,PHP,GO,编程博客'>
	<title>苏苏的博客 &middot; 苏苏的博客</title>
	<link rel="stylesheet" type="text/css" href="/css/style.min.css">
	<link href="http://blog.suconghou.cn/index.xml" rel="alternate" type="application/rss+xml" title="苏苏的博客" />
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
	<link rel="shortcut icon" href="/favicon.png">
</head>
<body>
<header class="header">
	<div class="header-main">
		<a href="/"><img src="/img/avatar.jpg" class="header-avatar"></a>
		<h1>苏苏的博客</h1>
		<p class="sub-title">简约至极</p>
		<ul class="contact">
			<a href="https://github.com/suconghou" target="_blank"><i class="fa fa-github"></i></a>
			<a href="javascript:music.show(1)"><i class="fa fa-music"></i></a>
		</ul>
	</div>
</header>

<aside></aside>

<div class="content container">
	<div class="posts">
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/use-apache-traffic-server/"> 编译安装Apache Traffic Server</a>
			</h1>
			<p class="post-date">Mon, May 9, 2016</p>
			<div class="post-text">
				

<h2 id="编译安装">编译安装</h2>

<p>Centos下编译安装</p>

<pre><code>yum update -y &amp;&amp; yum install wget gcc g++ gcc-c++ glibc-headers perl openssl openssl-devel tcl-devel libxml2-devel pcre-devel
wget http://apache.fayea.com/trafficserver/trafficserver-6.1.1.tar.bz2
tar xvjf trafficserver-6.1.1.tar.bz2
cd trafficserver-6.1.1
./configure
make &amp;&amp; make install
useradd -s /sbin/nologin trafficserver
</code></pre>

<p>Apache镜像<a href="http://archive.apache.org/dist/">http://archive.apache.org/dist/</a></p>

<p>国内Apache镜像<a href="http://apache.fayea.com/">http://apache.fayea.com/</a></p>

<p>编译完成后,就可以使用了,默认是安装在<code>/usr/local/bin</code>,编译后是比较大</p>

<pre><code>total 98M
-rwxr-xr-x 1 root root 692K May  9 14:30 header_rewrite_test
-rwxr-xr-x 1 root root 520K May  9 14:30 traffic_cop
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_crashlog
-rwxr-xr-x 1 root root 259K May  9 14:30 traffic_ctl
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_layout
-rwxr-xr-x 1 root root  41K May  9 14:30 traffic_line
-rwxr-xr-x 1 root root 4.4M May  9 14:30 traffic_logcat
-rwxr-xr-x 1 root root 5.0M May  9 14:30 traffic_logstats
-rwxr-xr-x 1 root root 4.7M May  9 14:30 traffic_manager
-rwxr-xr-x 1 root root  37M May  9 14:30 traffic_sac
-rwxr-xr-x 1 root root  43M May  9 14:30 traffic_server
-rwxr-xr-x 1 root root  42K May  9 14:30 traffic_via
-rwxr-xr-x 1 root root  18K May  9 14:30 trafficserver
-rwxr-xr-x 1 root root 2.1K May  9 14:30 tspush
-rwxr-xr-x 1 root root 5.7K May  9 14:30 tsxs

</code></pre>

<p>运行<code>traffic_server -R 1</code>执行测试,经过一系列测试后,显示</p>

<pre><code>Tests Passed: 177
Tests Failed: 0
    REGRESSION_RESULT PARENTSELECTION:                          PASSED
REGRESSION_TEST DONE: PASSED
</code></pre>

<p>全部测试通过</p>

<h2 id="使用">使用</h2>

<p>默认的配置文件存放在<code>/usr/local/etc/trafficserver</code></p>

<pre><code>drwxr-xr-x 3 nobody nobody 1.0K May  9 14:30 body_factory
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 cache.config
-rw-r--r-- 1 nobody nobody  657 May  9 14:30 cluster.config
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 congestion.config
-rw-r--r-- 1 nobody nobody  746 May  9 14:30 hosting.config
-rw-r--r-- 1 nobody nobody 1.8K May  9 14:30 icp.config
-rw-r--r-- 1 nobody nobody 1.2K May  9 14:30 ip_allow.config
-rw-r--r-- 1 nobody nobody  328 May  9 14:30 log_hosts.config
-rw-r--r-- 1 nobody nobody  17K May  9 14:30 logs_xml.config
-rw-r--r-- 1 nobody nobody 1.4K May  9 14:30 parent.config
-rw-r--r-- 1 nobody nobody  261 May  9 14:30 plugin.config
-rw-r--r-- 1 nobody nobody  13K May  9 14:30 records.config
-rw-r--r-- 1 nobody nobody 8.6K May  9 14:30 remap.config
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 socks.config
-rw-r--r-- 1 nobody nobody 2.1K May  9 14:30 splitdns.config
-rw-r--r-- 1 nobody nobody 2.7K May  9 14:30 ssl_multicert.config
-rw-r--r-- 1 nobody nobody  76K May  9 14:30 stats.config.xml
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 storage.config
-rw-r--r-- 1 root   root     19 May  9 14:30 trafficserver-release
-rw-r--r-- 1 nobody nobody  649 May  9 14:30 vaddrs.config
-rw-r--r-- 1 nobody nobody 1.3K May  9 14:30 volume.config

</code></pre>

<p><code>records.config</code>负责大部分全局的选项设置，即主要配置文件</p>

<pre><code>CONFIG proxy.config.reverse_proxy.enabled INT 1                           # 开启反向代理
CONFIG proxy.config.url_remap.remap_required INT 1                        # 1 代理反向代理，0代表正向+反向代理
CONFIG proxy.config.http.cache.http INT 1                                 # 打开http缓存功能
CONFIG proxy.config.cache.ram_cache.size INT 512M                         # RAM 缓存大小
CONFIG proxy.config.http.keep_alive_no_activity_timeout_out INT 120       # 当一个事务结束后同原服务器保持连接的时间
CONFIG proxy.config.cluster.ethernet_interface STRING eth0                # 修改成需要侦听的interface名称

</code></pre>

<p><code>remap.config</code>定义映射规则，用于请求的重定向（rewrite）,反向代理即在此配置</p>

<p><code>storage.config</code> 用于指定磁盘存储</p>

<p>启动<code>trafficserver start</code></p>

<h3 id="varnish编译">varnish编译</h3>

<p>alpine中编译</p>

<pre><code>apk update &amp;&amp; apk upgrade
apk --update add gcc g++ make wget curl m4 automake autoconf libtool linux-headers py-docutils ncurses-dev pcre-dev libedit-dev
cd /tmp
VARNISH_VERSION=varnish-4.1.3
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget https://repo.varnish-cache.org/source/${VARNISH_VERSION}.tar.gz
tar xzf ${VARNISH_VERSION}.tar.gz
cd ${VARNISH_VERSION}
./configure
make CFLAGS=&quot;-Os&quot; CPPFLAGS=-D__NEED_mode_t -j$CPU_NUM &amp;&amp; make install
strip -s /usr/local/bin/* /usr/local/sbin/* /usr/local/lib/varnish/*.so /usr/local/lib/varnish/vmods/*.so
varnishd  -V
</code></pre>

<h4 id="varnish基本使用">varnish基本使用</h4>

<p>varnish / squid / nginx 优缺点讨论 见 <a href="http://www.zhihu.com/question/20143441">http://www.zhihu.com/question/20143441</a></p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/use-docker-on-raspberry/"> 在树莓派上使用Docker</a>
			</h1>
			<p class="post-date">Sun, May 8, 2016</p>
			<div class="post-text">
				

<h2 id="安装支持docker的系统">安装支持Docker的系统</h2>

<p>树莓派官方系统并不支持Docker,需要安装.</p>

<p>查看 <a href="http://blog.hypriot.com/downloads/">集成Dcoker的树莓派系统</a></p>

<pre><code>aria2c -s 50 -c https://downloads.hypriot.com/hypriotos-rpi-v0.8.0.img.zip


diskutil list
diskutil unmountdisk /dev/disk2
</code></pre>

<p>用以下命令前必须卸载u盘<code>diskutil unmountdisk /dev/disk2</code></p>

<pre><code>sudo dd if=hypriotos-rpi-v0.8.0.img of=/dev/disk2 bs=8k
</code></pre>

<p>安装完成重启就可以啦,启动后登陆的用户是pirate,密码hypriot</p>

<p>修改密码:执行<code>passwd</code>,输入当前密码,输入新密码,再输入新密码,更新完成</p>

<p>执行<code>exit</code>退出,或者<code>sudo reboot</code>重启</p>

<p>创建用户:<code>useradd -g test -d /home/test1 -s /etc/bash -m test1</code>
注解：-g 所属组 -d 家目录 -s 所用的SHELL
passwd abc</p>

<p>获得sudo权限:编辑<code>/etc/sudoers</code> 加入新添加的用户名</p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/software/android-studio/"> Android Studio</a>
			</h1>
			<p class="post-date">Fri, Apr 8, 2016</p>
			<div class="post-text">
				

<h2 id="下载-android-studio">下载 Android Studio</h2>

<p><a href="http://www.oschina.net/news/77839/android-studio-2-2-1">http://www.oschina.net/news/77839/android-studio-2-2-1</a></p>

<pre><code>Windows: https://dl.google.com/dl/android/studio/ide-zips/2.2.1.0/android-studio-ide-145.3330264-windows.zip (437.1 MiB)
Mac: https://dl.google.com/dl/android/studio/ide-zips/2.2.1.0/android-studio-ide-145.3330264-mac.zip (437.7 MiB)
Linux: https://dl.google.com/dl/android/studio/ide-zips/2.2.1.0/android-studio-ide-145.3330264-linux.zip (436.8 MiB)
</code></pre>

<h2 id="安装android-sdk">安装android-sdk</h2>

<p><code>brew install android-sdk</code> 或者使用Android Studio SDK Manager</p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/project/air/"> air</a>
			</h1>
			<p class="post-date">Thu, Feb 18, 2016</p>
			<div class="post-text">
				

<h1 id="serve-static-files-in-the-air">serve static files in the air</h1>

<p>在线解析压缩合并Less,打包压缩Javascript.</p>

<p>手动压缩打包,执行Lint,静态服务器,缓存版本控制,完美结合CDN</p>

<h1 id="安装">安装</h1>

<p><code>npm install airs -g</code></p>

<h1 id="基本参数">基本参数</h1>

<ul>
<li>纯静态项目,在项目根目录直接执行<code>air</code></li>
</ul>

<blockquote>
<p>即可开启http服务,直接输出编译后的结果</p>
</blockquote>

<ul>
<li>PHP项目,项目根目录执行<code>air develop</code></li>
</ul>

<blockquote>
<p>会开启静态服务器,同时开启一个PHP Server</p>

<p>PHP Server 端口号为静态服务器端口号+1</p>
</blockquote>

<ul>
<li>服务器模式 <code>air server</code></li>
</ul>

<blockquote>
<p>编译将做优化和代码压缩</p>
</blockquote>

<p><strong>指令</strong></p>

<blockquote>
<p>使用<code>air lint</code> 执行Jslint,而不开启http服务,文件修改实时触发</p>

<p>使用<code>air lint jsfile1.js jsfile2.js jsfile3.js</code> 可对指定文件进行Jslint,可对一个或多个文件</p>

<p>使用<code>air compress</code> 在static目录下执行,将会根据static.json文件描述,压缩合并输出到指定文件</p>

<p>使用<code>air compress lessfile1.less lessfile2.less</code> 将对less文件解析压缩,多个less文件将会压缩合并为一个css文件</p>

<p>使用<code>air compress jsfile1.js jsfile2.js</code> 将对js文件压缩,多个js文件将合并为一个js文件</p>

<p>可以参数中同时存在less文件和js文件,<code>air compress less1.less file1.js file2.less file3.js</code>
工具自动按类型分组,less文件和js文件,各自压缩合并,其他文件类型忽略.</p>

<p>支持jpg,png图片压缩<code>air compress file1.jpg file2.png</code> 采用<code>tinypng</code>API接口压缩,效果出众
使用参数<code>--key=your-tinypng-api-key</code>设定apikey,例如<code>air compress file1.png file2.png --key=abcedf</code></p>

<p><code>air compress</code> 除了<code>--less</code>参数,可接受<code>--debug</code>参数,生成未压缩的代码方便调试</p>

<p><code>air compress --debug</code> 以debug模式压缩,less文件只解析合并,并不压缩代码,JS文件压缩合并,并不混淆优化</p>

<p><code>air compress --watch</code> 还可以监视文件变化,自动执行压缩合并</p>

<p><code>air compress --o</code> 开启极限优化压缩,去除console,debugger,优化常量表达式,循环,条件表达式优化等,同样适用于server模式<code>air server --o</code></p>
</blockquote>

<p><strong>参数</strong></p>

<blockquote>
<p>参数-w,使用Jslint,文件修改实时触发,本地开发建议加上</p>

<p>参数-g,每分钟定时拉取git更新,可用于测试服务器上</p>

<p>参数-k,设定webhook的密码,服务器模式建议加上</p>

<p>参数-p,指定服务监听的端口,PHP Server 端口号也会依此变化.</p>

<p>参数-v,打印出版本并退出</p>

<p>参数-d,以daemon模式运行</p>

<p>同时可添加参数 <code>--less=/data/pathto/lesslib</code> 指定lessLib路径,可接受相对路径和绝对路径</p>
</blockquote>

<h1 id="目录结构">目录结构</h1>

<p>目录结构采用类似 <code>项目名/static/css/style.less</code></p>

<p>项目名可选,Javascript路径类似 <code>项目名/static/js/main.js</code></p>

<p>Http访问 <code>/项目名/static/css/style.css</code> 即可得出style.less编译后的css.</p>

<p>注意:如果文件夹内确实存在此文件,则此文件则会如实输出</p>

<p>因此Http直接访问 <code>/项目名/static/js/main.js</code> 则会如实输出main.js文件</p>

<p>工具支持<code>-连接符</code>配置,因此可以Http访问 <code>/项目名/static/js/main-page.js</code></p>

<p>则会按顺序合并main.js和page.js两个文件</p>

<p>less文件同样可以按照此种模式,此外less文件还可以使用索引模式</p>

<p>使用less自身语法,style.less作为入口,import其他less文件</p>

<p>此外,如果文件过多,使用连字符麻烦,工具还支持配置文件模式</p>

<p>在static目录内建立static.json文件,配置Less和Javascript映射</p>

<p>static.json</p>

<pre><code>{
	&quot;static&quot;:
	{
		&quot;js&quot;:
		{
			&quot;all&quot;:[&quot;jquery.min.js&quot;,&quot;etpl.js&quot;,&quot;tpl.js&quot;,&quot;iscroll.js&quot;,&quot;chat.js&quot;,&quot;aside.js&quot;]
		}
		&quot;css&quot;:
		{
			&quot;style&quot;:[&quot;page.less&quot;,&quot;less/admin.less&quot;]
		}
	}
}
</code></pre>

<p>此时,在static目录下执行<code>air compress</code> 将会将上述js文件压缩为all.min.js</p>

<p>less文件解析合并压缩为style.min.css</p>

<p>在static目录下执行<code>air server</code>,http访问<code>/static/js/all.js</code> <code>/static/css/style.css</code> 同样得出上述压缩合并的结果</p>

<pre><code>.
|____blog
| |____static
| | |____css
| | | |____less
| | | |____style.less
| | |____img
| | |____js
| | | |____lib
|____less
| |____base.less
| |____mixins.less
</code></pre>

<h1 id="webhook">Webhook</h1>

<ul>
<li><code>/webhook/gitpull</code> 执行 <code>git pull origin master</code> 立刻拉取代码更新.</li>
<li><code>/webhook/viewlog</code> 查看运行日志</li>
<li><code>/webhook/clear</code> 执行清理内存操作,立即清除所有日志和编译缓存</li>
</ul>

<blockquote>
<p>添加-k参数后,webhook需要密码才能查看.</p>

<p>在网址后面添加?key=密码即可</p>
</blockquote>

<h1 id="性能">性能</h1>

<p>所有的Less编译和压缩,Javascript合并与压缩均在第一次访问的时候执行</p>

<p>并且结果被缓存到内存,下次直接内存读取并输出,直到有文件发生修改才会再次执行编译.</p>

<p>编译缓存储存到一定数量将会执行GC,存储了2000个编译后的文件后,再次存储将会清除旧的缓存以释放内存</p>

<p>运行日志积累到一定数量也会清除旧的日志,以节省内存.</p>

<p>本地开发和线上服务都完全无需担心.</p>

<h1 id="缓存">缓存</h1>

<p>内存缓存保存最近一次编译的版本号.</p>

<p>资源版本号以类似<code>style.css?ver=v1</code>的形式.</p>

<p>修改版本号后,less内部所有引用资源如<code>background-image</code>等,都会立即更新引用地址,防止旧的缓存.</p>

<p>可以放心开启强缓存.</p>

<h1 id="共享">共享</h1>

<p>根目录下<code>less</code>文件夹作为共享文件夹.</p>

<p>其他任何项目里的less文件都可以任意 <code>@import</code> 此文件夹下的文件,无需指明具体路径.</p>

<p>可放置mixins等.</p>

<h1 id="示例">示例</h1>

<blockquote>
<p>本地开发 <code>air develop -w</code></p>

<p>服务器模式 <code>air server -k 123456 -d</code></p>
</blockquote>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/linux/"> linux相关操作</a>
			</h1>
			<p class="post-date">Thu, Jan 21, 2016</p>
			<div class="post-text">
				

<h2 id="linux用户管理">Linux用户管理</h2>

<h3 id="添加用户adduser">添加用户adduser</h3>

<p>假如用户名为<code>work</code></p>

<p><code>adduser work -M</code></p>

<pre><code># add rslsync user without home dir and cannot login
sudo adduser --shell /bin/nologin --no-create-home --group rslsync
</code></pre>

<p>-M, &ndash;no-create-home        不创建用户的主目录
-s, &ndash;shell SHELL       新账户的登录 shell,nologin就是登陆不了
-G, &ndash;groups GROUPS 新账户的附加组列表</p>

<p><code>adduser -h</code>查看完整帮助</p>

<pre><code>用法：adduser [选项] 登录
      adduser -D
      adduser -D [选项]

选项：
  -b, --base-dir BASE_DIR	新账户的主目录的基目录
  -c, --comment COMMENT         新账户的 GECOS 字段
  -d, --home-dir HOME_DIR       新账户的主目录
  -D, --defaults		显示或更改默认的 useradd 配置
  -e, --expiredate EXPIRE_DATE  新账户的过期日期
  -f, --inactive INACTIVE       新账户的密码不活动期
  -g, --gid GROUP		新账户主组的名称或 ID
  -G, --groups GROUPS	新账户的附加组列表
  -h, --help                    显示此帮助信息并推出
  -k, --skel SKEL_DIR	使用此目录作为骨架目录
  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
  -l, --no-log-init	不要将此用户添加到最近登录和登录失败数据库
  -m, --create-home	创建用户的主目录
  -M, --no-create-home		不创建用户的主目录
  -N, --no-user-group	不创建同名的组
  -o, --non-unique		允许使用重复的 UID 创建用户
  -p, --password PASSWORD		加密后的新账户密码
  -r, --system                  创建一个系统账户
  -R, --root CHROOT_DIR         chroot 到的目录
  -s, --shell SHELL		新账户的登录 shell
  -u, --uid UID			新账户的用户 ID
  -U, --user-group		创建与用户同名的组
  -Z, --selinux-user SEUSER		为 SELinux 用户映射使用指定 SEUSER
</code></pre>

<h3 id="修改密码">修改密码</h3>

<p><code>passwd work</code></p>

<h3 id="修改用户名">修改用户名</h3>

<p>alarm为旧用户名</p>

<pre><code>new_user=lao
# change user name
usermod -l $new_user -d /home/$new_user -m alarm
# chenge user group
groupmod -n $new_user alarm
</code></pre>

<p><a href="http://www.cnblogs.com/xd502djj/archive/2011/11/23/2260094.html">http://www.cnblogs.com/xd502djj/archive/2011/11/23/2260094.html</a></p>

<h2 id="linux实用命令">Linux实用命令</h2>

<h2 id="w">w</h2>

<p><code>w</code>命令能容清晰的显示,服务器在线时间,负载以及当前登陆的用户</p>

<h2 id="vmstat">vmstat</h2>

<p><code>vmstat</code> 显示开机以来的平均值，而不是前一秒的值
<code>vmstat 1</code>命令指定一个参数 1 运行，来打印每一秒的统计摘要.
这些列代表的信息:</p>

<blockquote>
<p>r：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：&rdquo;r&rdquo;的值大于了 CPU 的数量就表示已经饱和了。
free：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。&rdquo;free -m&rdquo; 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。
si, so：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。
us, sy, id, wa, st：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。</p>
</blockquote>

<p>CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。
对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。</p>

<p>SIZE(VIRT): 进程使用的地址空间, 如果进程映射了100M的内存, 进程的地址空间将报告为100M内存. 事实上, 这个大小不是一个程序实际使用的内存数.</p>

<p>RSS(RES): &ldquo;Resident Set Size&rdquo;, 实际驻留&rdquo;在内存中&rdquo;的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.</p>

<p>SHARE(SHR): RSS中与其它进程共享的内存部分大小.</p>

<p>VMSIZE: 一个进程占用的总的地址空间大小. 它包括了没有映射到内存中的页面。</p>

<p>SZ（DATA）: 映射到内存中的页面, 这些页面仅由进程单独使用. 这也是我们最关心地方: 进程实际占用的内存数。</p>

<h2 id="top">top</h2>

<p><code>top -b -n1</code> 可以只执行一次,用于将结果重定向到文件.</p>

<h2 id="free">free</h2>

<p><code>free -m</code> <code>free -h</code></p>

<p>按内存占用排序</p>

<pre><code>
ps -eo rss,vsz,pid,ppid,time,etime,command --sort=rss   # 按内存
ps -eo rss,vsz,pid,ppid,time,etime,command --sort=time  # 按CPU时间,etime启动时间,comm等都可以.

# MAC无法使用`--sort`上需要使用`| sort -n`

ps -eo rss,vsz,pid,ppid,time,etime,command |sort -n

# alpine 里这样用,不支持--sort, 同样也可以 `top -b -n1`
ps -o rss,vsz,pid,ppid,time,etime,args
</code></pre>

<h2 id="ssh">ssh</h2>

<p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@host</code></p>

<p><code>ssh-copy-id -i ~/.ssh/id_rsa.pub -p 26671 root@host</code></p>

<h2 id="pgrep">pgrep</h2>

<p>根据名字或其他属性查询出进程的PID</p>

<p>如:<code>pgrep nginx -fl</code></p>

<h2 id="pkill">pkill</h2>

<p>和<code>pgrep</code>类似,不同的是向进程发送信号,默认发送<code>SIGTERM</code>信号,查看都有哪些信号可用,可以使用<code>kill -l</code>查看</p>

<p>类似<code>pkill</code>的命令是<code>killall</code>,后面都是可以直接加进程名字批量杀死进程</p>

<h2 id="pstree">pstree</h2>

<p>用树的形式显示正在运行的进程,树的节点为指定的PID(忽略则为init进程)</p>

<h2 id="ss">ss</h2>

<p>用于显示socket的统计信息,<code>-s</code>用于显示汇总</p>

<p><code>-l</code>用于列出正在监听的<code>socket</code></p>

<p><code>-p</code>显示进程信息,<code>ss -pl</code> 可以查看使用网络端口的进程名字</p>

<h2 id="磁盘相关">磁盘相关</h2>

<h3 id="dd">dd</h3>

<p><code>dd</code>把指定的输入文件拷贝到指定的输出文件中,并且在拷贝的过程中可以进行格式转换。</p>

<p>if =输入文件(或设备名称)
of =输出文件(或设备名称)
bs = bytes 同时设置读/写缓冲区的字节数(等于设置obs和obs)
count = blocks 只拷贝输入的blocks块</p>

<p>创建一个100M的空文件
<code>dd if=/dev/zero of=hello.txt bs=100m count=1</code></p>

<h2 id="查看当前目录下所有一级子目录文件夹大小">查看当前目录下所有一级子目录文件夹大小</h2>

<p><code>du -h --max-depth=1</code></p>

<h2 id="查看当前目录下所有一级子目录文件夹大小-并排序">查看当前目录下所有一级子目录文件夹大小 并排序</h2>

<p><code>du -h --max-depth=1 |sort</code></p>

<p>以上两条命令不适用于MacOs,可以使用<code>du -sh *</code></p>

<h2 id="ps">ps</h2>

<p>ps ef  查看进程的状态</p>

<p>ps auxw 查看进程的CPU,内存占用</p>

<p>ps 默认是按照PID排序的,若要按内存使用排序<code>ps auxw --sort=rss</code>,同理按虚拟内存排序<code>ps auxw --sort=vsz</code></p>

<p>mac上无法使用<code>--sort</code>,可以采用<code>sort</code>排序,如rss在第六列,则<code>ps auxw | sort -k6,6n</code></p>

<p>lscpu</p>

<h2 id="nc">nc</h2>

<p>nc 命令默认没有安装,需要自己安装,<code>yum install nc</code></p>

<p><strong>传送字符与文件</strong></p>

<p>一端<code>nc -l 9090</code>监听端口9090</p>

<p>一端<code>nc host 9090</code>连接host的9090端口,通信建立后,可以双向通信,实现文字聊天等,也可以传送文件</p>

<p>一端<code>nc -l 9090 &gt; file</code> ,另一端发送文件<code>nc host 9090 &lt; file</code></p>

<p>传送文件夹(压缩文件) <code>nc -l 9090 |tar xzvf -</code> , 另一端发送文件<code>tar czvf – dir | nc host 9090</code></p>

<p>同样可以拷贝硬盘 <code>nc -l 9090 | dd of=/dev/sda</code>,另一端发送<code>dd if=/dev/sda | nc host 9090</code></p>

<p><strong>端口扫描</strong></p>

<p><code>nc -vz -w 1 someIp 1-1000</code></p>

<p><strong>模拟调试http请求</strong></p>

<p><code>GET / HTTP/1.0</code></p>

<p><strong>端口转发</strong></p>

<p>使用之前需要了解其他的命令</p>

<p><code>tee</code>命令将标准输入的数据写入标准输出和tee命令指定的文件参数</p>

<p><code>mkfifo</code>命令用于创建一个FIFO（先进先出）方式的命名管道</p>

<p>标准流:</p>

<pre><code>stdin	0
stdout	1
stderr	2
</code></pre>

<p>** listener-to-client模式(用于外网访问内网) **</p>

<p>见 <a href="http://onestraw.net/cybersecurity/netcat-advanced-usage/">http://onestraw.net/cybersecurity/netcat-advanced-usage/</a></p>

<h2 id="一份linux别名和函数库">一份Linux别名和函数库</h2>

<pre><code>alias tree=&quot;find . -print | sed -e 's;[^/]*/;|____;g;s;____|; |;g' &quot;;
alias cls=&quot;cd $1;ls -lh;&quot;;
# 获得你的公网IP地址和主机名。
alias ipinfo=&quot;curl ifconfig.me &amp;&amp; curl ifconfig.me/host&quot;;
# 显示出哪个应用程序连接到网络。
alias listen=&quot;lsof -P -i -n&quot;;
# 显示出活动的端口。
alias port='netstat -uanltp'
# 统计TCP连接个数
alias tcpstatus=&quot;netstat -n|awk '/^tcp/{++S[\$NF]} END {for(a in S) print a,S[a]}'&quot;
# 回到上层目录
alias ..='cd ..'
# 去到上两层目录
alias ...='cd ../..'
# 按列格式化输出mount信息。
alias cmount=&quot;mount | column -t&quot;
# 查看你还有剩下多少内存
alias meminfo='free -m -l -t'
# 按照文件在磁盘存储的大小排序，显示当前目录的文件列表。
sbs() { du -b --max-depth 1 | sort -nr | perl -pe 's{([0-9]+)}{sprintf &quot;%.1f%s&quot;, $1&gt;=2**30? ($1/2**30, &quot;G&quot;): $1&gt;=2**20? ($1/2**20, &quot;M&quot;): $1&gt;=2**10? ($1/2**10, &quot;K&quot;): ($1, &quot;&quot;)}e';}
# 找出指定目录中最大的10个文件
largefile() { find . -type f -exec du -k {} \; | sort  -nrk 1 | head; }
# 查看当前目录大于[多少]kb的文件,速度更快
bigthan() { size=${1:-100}; find . -type f -size +&quot;$size&quot;k |xargs  ls  -lh ; }
# 返回你的当前IP地址的地理位置。
getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep 'city|state|country'|awk '{print $3,$4,$5,$6,$7,$8}'|sed 's\ip address flag \\'|sed 's\My\\';}
# 删除.log.1.gz 或者 .log.1.bz2
delog(){ ls | grep &quot;log.\d\+.\(bz2\|gz\)&quot; | xargs rm}

# 查看最占用内存的前五个进程(根据第几列可修改k6)
topmem()
{
	ps aux | sort -k6nr | head -n5;
}


</code></pre>

<p>部分快捷键</p>

<pre><code>
CTRL + U -剪切光标前的内容

CTRL + K -剪切光标至行末的内容

CTRL + Y -粘贴

CTRL + E -移动光标到行末

CTRL + A -移动光标到行首

ALT + F -跳向下一个空格

ALT + B -跳回上一个空格

ALT + Backspace -删除前一个单词

CTRL + W -剪切光标后一个单词

Shift + Insert -向终端内粘贴文本

</code></pre>

<p>压缩率 xz &gt; 7z &gt; bzip2 &gt; gzip &gt; zip</p>

<p>gzexe 创建自解压文件</p>

<p>xz5.2以上版本支持多线程压缩,xz -T0 就可以自动按机器线程数多线程执行了,xz 支持 env 环境变量，XZ_OPT=-T0 xz xxx.file 就行啦</p>

<p>多线程的压缩速度几乎与gzip相当</p>

<pre><code># 查看你机器的CPU个数,超线程信息
sysinfo() {
physicalNumber=0
coreNumber=0
logicalNumber=0
HTNumber=0
logicalNumber=$(grep &quot;processor&quot; /proc/cpuinfo|sort -u|wc -l)
physicalNumber=$(grep &quot;physical id&quot; /proc/cpuinfo|sort -u|wc -l)
coreNumber=$(grep &quot;cpu cores&quot; /proc/cpuinfo|uniq|awk -F':' '{print $2}'|xargs)
HTNumber=$((logicalNumber / (physicalNumber * coreNumber)))
echo &quot;****** CPU Information ******&quot;
echo &quot;Logical CPU Number  : ${logicalNumber}&quot;
echo &quot;Physical CPU Number : ${physicalNumber}&quot;
echo &quot;CPU Core Number     : ${coreNumber}&quot;
echo &quot;HT Number           : ${HTNumber}&quot;
echo &quot;*****************************&quot;
}

</code></pre>

<h2 id="使用脚本清理一些文件">使用脚本清理一些文件</h2>

<p>删除当前目录超过30天未变动过的log文件</p>

<pre><code>find . -mtime +30 -type f -name '*.log*' | xargs rm
</code></pre>

<p>或者</p>

<pre><code>find . -mtime +30 -type f -name '*.log*' -exec rm -i {} \;
</code></pre>

<p>所有的操作都包含子目录</p>

<p>-exec  参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。</p>

<p>{}   花括号代表前面find查找出来的文件名。</p>

<p>如<code>find . -type f -exec ls -l {} \;</code></p>

<p>使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。</p>

<p>如<code>find . -name &quot;*.log&quot; -mtime +60 -ok rm {} \;</code></p>

<p>-mtime +30 设定时间为30天前</p>

<p>-type f 查找的类型为文件</p>

<p>-name 文件路径需要匹配的</p>

<p><strong>使用全文查找</strong></p>

<p>grep -lr &lsquo;string&rsquo; /etc/</p>

<p>这个命令就可以搞定。搜索etc下面的文件，包含所有目录下的文件。这样就搞定了。</p>

<p>-i，乎略大小写
-l，找出含有这个字符串的文件
-r，不放过子目录</p>

<h2 id="解决can-t-set-the-locale-make-sure-lc-and-lang-are-correct">解决can&rsquo;t set the locale; make sure $LC_* and $LANG are correct</h2>

<p><a href="https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian">https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian</a>
<code>照着全部做下来</code></p>

<h2 id="sed使用">sed使用</h2>

<p>更新版本号</p>

<pre><code>sed -i &quot;s/?ver=\w\+/?ver=`date +%s`/g&quot; *.html
</code></pre>

<pre><code>o=http://cdn.ourwill.cn/fed-static r=http://cdn.ourwill.cn/fed-static/fedv2 sed -i &quot;s#$o#$r#g&quot; *.html
</code></pre>

<h2 id="vim乱码解决">Vim乱码解决</h2>

<p><code>vim ~/.vimrc</code></p>

<pre><code>set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
</code></pre>

<h2 id="开机启动的">开机启动的</h2>

<p>检视和控制systemd的主要命令是systemctl</p>

<p>详细使用见<a href="https://wiki.archlinux.org/index.php/systemd_(简体中文)">https://wiki.archlinux.org/index.php/systemd_(简体中文)</a></p>

<p>CentOS7 用<code>systemctl</code>取代了<code>service</code>
旧版本的 <code>service docker start</code> 改为<code>systemctl start docker</code>
设置开机启动
旧版本的 <code>chkconfig docker on</code> 改为 <code>systemctl enable docker</code></p>

<p><code>/usr/lib/systemd/system/</code>
<code>/etc/systemd/system/</code>
后者有较高优先级会覆盖前者</p>

<p>/etc/profile 和 ~/.bash_profile 是在启动 一个交互登陆shell的时候 被调用。
/etc/bashrc 和 ~/.bashrc 是在一个交互的非登陆shell启动 的时候 被调用。
~/.bash_logout 在用户注销登陆的时候 被读取</p>

<p>系统脚本 可以放置在/etc/rc.d/init.d中并建立/etc/rc.d/rc?.d链接，也可以直接放置在/etc/rc.d/rc.local中。
init.d脚本 包含完整的start,stop,status,reload等参数，是标准做法，推荐使用。</p>

<h2 id="linux-家族">Linux 家族</h2>

<p>一般来说著名的linux系统基本上分两大类：</p>

<p>1.RedHat系列：Redhat、Centos、Fedora等</p>

<p>2.Debian系列：Debian、Ubuntu等</p>

<p>RedHat 系列</p>

<p>1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”</p>

<p>2 包管理工具 yum</p>

<p>3 支持tar包</p>

<p>Debian系列
1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”</p>

<p>2 包管理工具 apt-get</p>

<p>3 支持tar包</p>

<p><code>soft rlimits too low. Number of files is 256, should be at least 1000</code></p>

<p>见 <a href="https://www.fdzh.org/slides/2015/06/20/linux-distr/">https://www.fdzh.org/slides/2015/06/20/linux-distr/</a></p>

<p><img src="http://static.suconghou.cn/document/linux.jpg" alt="家族示意图" /></p>

<h2 id="判断一个命令是否存在">判断一个命令是否存在</h2>

<p>如判断<code>nc</code>是否存在</p>

<pre><code>command -v nc &gt;/dev/null 2&gt;&amp;1 || { echo &gt;&amp;2 &quot;I require nc but it's not installed.  Aborting.&quot;; exit 1; }

</code></pre>

<pre><code>if ! command -v pip &gt; /dev/null 2&gt;&amp;1;then
    echo &quot;YES&quot;
fi
</code></pre>

<pre><code>PIP=$(which pip)
if [ ! -x &quot;${PIP}&quot; ];then
	echo &quot;NO&quot;
else
	echo &quot;YES&quot;
fi
</code></pre>

<pre><code>[[ ! -x $(which pip) ]] &amp;&amp; echo &quot;No&quot; || echo &quot;Yes&quot;

</code></pre>

<pre><code>if (( ${+commands[pip]} )); then
	echo &quot;YES&quot;
fi
</code></pre>

<h2 id="判断一个进程pid是否还存在">判断一个进程PID是否还存在</h2>

<p>例如检查pid为143的进程 <code>ps ax | awk '{ print $1 }' | grep -e &quot;^143$&quot;</code></p>

<h2 id="shell基本语法">Shell基本语法</h2>

<p>声明数组</p>

<p><code>arr=(item1 item2 item3)</code> 使用空格分开</p>

<p>使用<code>echo ${arr[*]}</code> 或者 <code>echo ${arr[@]}</code> 可以查看数组内的元素,<code>echo $arr</code>只能取得第一个元素</p>

<p>要取得数组长度,只需在名字前面加一个#,如<code>echo ${#arr[*]}</code> 或者 <code>echo ${#arr[@]}</code></p>

<p>数组下标以0开始,取得第二个元素为<code>echo ${arr[1]}</code></p>

<p>赋值使用<code>arr[5]=5555</code></p>

<h2 id="测试vps宽带">测试VPS宽带</h2>

<p><a href="https://github.com/sivel/speedtest-cli">https://github.com/sivel/speedtest-cli</a></p>

<p><a href="http://man.linuxde.net/speedtest-cli">http://man.linuxde.net/speedtest-cli</a></p>

<p>还可以使用wget下载各大型机房的测试文件</p>

<p>芝加哥机房/100M测试包</p>

<p><code>wget http://cachefly.cachefly.net/100mb.test</code></p>

<p><code>wget http://cachefly.cachefly.net/10mb.test</code></p>

<p>directspace机房/10M.100M测试包</p>

<p>Portland, Oregon Data Center</p>

<p><code>wget http://bandwidth.directspace.net/100MBtest.zip</code></p>

<p><code>wget http://bandwidth.directspace.net/10MBtest.zip</code></p>

<p>Los Angeles, California Data Center</p>

<p><code>wget http://45.34.158.82/speedtest/100MBtest.zip</code></p>

<p>访问 cachefly.cachefly.net 可以测试你电脑当前的网络速度</p>

<p><a href="http://www.fyzhuji.com/speed.html">http://www.fyzhuji.com/speed.html</a> 提供的测速文件.</p>

<p>香港SV新力讯机房,测试20M光纤能跑满2.6MB/s</p>

<p><a href="https://www.starrydns.com/tc/speedtest">https://www.starrydns.com/tc/speedtest</a></p>

<p>Mega-I, Hong Kong,测试能跑到3MB/s</p>

<h2 id="lvm">LVM</h2>

<p>使用<code>pvcreate</code>创建PV</p>

<p>pvcreate 物理分区名字</p>

<p>使用<code>vgcreate</code>创建VG</p>

<p>vgcreate vgname pv1 pv2 pv3</p>

<p>pvdisplay 查看当前的PV</p>

<p>vgdisplay 查看VG</p>

<p>lvdisplay 查看LV</p>

<p>-L：指定LV的大小 -n：指定LV的名。Vo1Group00：表示从这个VG中划分LV；</p>

<p>LV创建好后格式化为想要的格式,然后挂载指定目录,就能使用了.(可以使用<code>df -lhT</code>查看了)</p>

<p><code>lsblk</code></p>

<pre><code>[root@will ~]# lsblk
NAME            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda               8:0    0 931.5G  0 disk
├─sda1            8:1    0   200M  0 part /boot/efi
├─sda2            8:2    0   500M  0 part /boot
└─sda3            8:3    0 930.8G  0 part
  ├─centos-root 253:0    0    50G  0 lvm  /
  ├─centos-swap 253:1    0   5.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 874.9G  0 lvm  /home
sr0              11:0    1  1024M  0 rom

</code></pre>

<p>##</p>

<p><a href="http://home.tiscali.cz/~cz210552/webbench.html">http://home.tiscali.cz/~cz210552/webbench.html</a></p>

<p><a href="http://www.cppblog.com/merlinfang/archive/2014/12/26/209311.html">http://www.cppblog.com/merlinfang/archive/2014/12/26/209311.html</a></p>

<p><a href="http://cloudwu.github.io/lua53doc/">http://cloudwu.github.io/lua53doc/</a></p>

<pre><code>cd /tmp
LUA_VERSION=lua-5.3.3
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.lua.org/ftp/${LUA_VERSION}.tar.gz
tar zxf ${LUA_VERSION}.tar.gz
cd ${LUA_VERSION}
make linux
</code></pre>

<p><a href="http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/#srlua">http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/#srlua</a></p>

<p><a href="http://luabinaries.sourceforge.net/download.html">http://luabinaries.sourceforge.net/download.html</a></p>

<p><a href="http://cloudwu.github.io/lua53doc/manual.html">http://cloudwu.github.io/lua53doc/manual.html</a></p>

<p>socat是一個netcat(nc)的替代產品，可以稱得上nc++。
<a href="http://www.dest-unreach.org/socat/">http://www.dest-unreach.org/socat/</a></p>

<p><a href="http://www.dest-unreach.org/socat/download/">http://www.dest-unreach.org/socat/download/</a></p>

<p>iotop htop
mtr</p>

<p>netpipes 和socat一样，主要是用来在命令行来进行socket操作的命令，这样你就可以在Shell脚本下行进socket网络通讯了。</p>

<p>iftop和iptraf可以用来查看当前网络链接的一些流量情况。</p>

<p>iostat, vmstat, ifstat 三合一的工具，用来查看系统性能。</p>

<p>rtorrent aria2c
lftp
ack是一个perl脚本，是grep的一个可选替换品</p>

			</div>
		</div>
		
	</div>
	<nav>
		
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        >
        <a href="/page/3/" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        ><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        class="active"><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        >
        <a href="/page/5/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/8/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
	</nav>
</div>
	<div class="music-container">
	<div class="music-header">
	    <a class="fa-button home" href="javascript:music.show(0)"><i class="fa fa-home" title="Home"></i></a>
	    <a class="fa-button next" href="javascript:music.next()"><i class="fa fa-chevron-right" title="Next"></i></a>
	</div>
	<div class="backdrop"></div>
	<div class="music-player">
		<div class="cover">
            <img src="http://p4.music.126.net/ckfEE9UUGcnGHylQJ12ENA==/670702092966093.jpg?param=350y350">
            <div class="foredrag"><i class="fa fa-play"></i></div>
        </div>
        <div class="progress">
            <div class="elapse"></div>
        </div>
        <div class="detail">
            <div class="title">音乐标题</div>
            <div class="artist">歌手</div>
        </div>
	</div>
</div>
<div id="loader" style="z-index:99999;" class="pageload-overlay" data-opening="M 40 -21.875 C 11.356078 -21.875 -11.875 1.3560784 -11.875 30 C -11.875 58.643922 11.356078 81.875 40 81.875 C 68.643922 81.875 91.875 58.643922 91.875 30 C 91.875 1.3560784 68.643922 -21.875 40 -21.875 Z">
    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 80 60" preserveAspectRatio="xMidYMid slice"> <path d="M40,30 c 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 Z"/></svg>
</div>

	<footer class="footer">
		<div class="footer-nav">
			<ul>
				<li><a href="/post/">归档</a></li>
				<li><a href="/">专题</a></li>
				<li><a href="/life/">生活</a></li>
				<li><a href="/about/">关于</a></li>
			</ul>
		</div>
	</footer>
	<script type="text/javascript" src="/js/main.min.js" data-no-instant></script>
</body>
</html>


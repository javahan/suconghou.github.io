<!DOCTYPE html>
<html lang="en">
<head>
	<meta name="generator" content="Hugo 0.19" />
	<meta charset="UTF-8">
	<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
	<meta name='renderer' content='webkit'>
	<meta name='viewport' content='width=device-width, initial-scale=1.0,maximum-scale=1.0, user-scalable=no'>
	<meta name='description' content='记录学习的点点滴滴'>
	<meta name='keywords' content='前端,PHP,GO,编程博客'>
	<title>苏苏的博客 &middot; 苏苏的博客</title>
	<link rel="stylesheet" type="text/css" href="/css/style.min.css">
	<link href="http://blog.suconghou.cn/index.xml" rel="alternate" type="application/rss+xml" title="苏苏的博客" />
	<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/apple-touch-icon-144-precomposed.png">
	<link rel="shortcut icon" href="/favicon.png">
</head>
<body>
<header class="header">
	<div class="header-main">
		<a href="/"><img src="/img/avatar.jpg" class="header-avatar"></a>
		<h1>苏苏的博客</h1>
		<p class="sub-title">简约至极</p>
		<ul class="contact">
			<a href="https://github.com/suconghou" target="_blank"><i class="fa fa-github"></i></a>
			<a href="javascript:music.show(1)"><i class="fa fa-music"></i></a>
		</ul>
	</div>
</header>

<aside></aside>

<div class="content container">
	<div class="posts">
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/gcc/"> gcc</a>
			</h1>
			<p class="post-date">Fri, Jan 13, 2017</p>
			<div class="post-text">
				

<h2 id="gcc-静态编译">gcc 静态编译</h2>

<p><code>1.c</code></p>

<pre><code>#include &lt;stdio.h&gt;

void main()
{
	printf(&quot;hello&quot;);
}

</code></pre>

<p><code>gcc -static --verbose -fno-builtin 1.c</code></p>

<blockquote>
<p><code>--verbose</code>是为了输入编译的详细信息</p>

<p><code>-fno-builtin</code>是阻止编译器把printf变成puts</p>
</blockquote>

<p>如果出现错误</p>

<pre><code>/usr/bin/ld: cannot find -lc
collect2: 错误：ld 返回 1
</code></pre>

<p>可能你还需要安装glibc的静态库</p>

<p><code>yum update &amp;&amp; yum install glibc-static -y</code></p>

<p>优化选项</p>

<p><a href="https://www.zhihu.com/question/27090458">https://www.zhihu.com/question/27090458</a></p>

<pre><code>gcc -static -O  1.c
gcc -static -O2 1.c
gcc -static -O3 1.c
gcc -static -Os 1.c
</code></pre>

<h2 id="错误提示">错误提示</h2>

<p><code>-pedantic</code>编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，<code>-pedantic</code>选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。</p>

<p>除了<code>-pedantic</code>之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数<code>-Wall</code>了，使用它能够使GCC产生尽可能多的警告信息。</p>

<pre><code>gcc -Wall test.c -o test
</code></pre>

<p>GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：</p>

<pre><code>gcc -Werror test.c -o test
</code></pre>

<h2 id="调试选项">调试选项</h2>

<p>1) -g选项，产生供gdb调试用的可执行文件：<code>gcc -g helloworld.c</code></p>

<blockquote>
<p>产生一个叫作a.out的可执行文件，大小明显比只用-o选项编译汇编连接后的文件大。</p>
</blockquote>

<p>2) -pg选项，产生供gprof剖析用的可执行文件：<code>gcc -pg helloworld.c</code></p>

<blockquote>
<p>产生一个叫作a.out的执行文件，大小明显比用-g选项后产生的文件还大。</p>
</blockquote>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/server-safe/"> 系统安全</a>
			</h1>
			<p class="post-date">Sun, Nov 20, 2016</p>
			<div class="post-text">
				

<h2 id="nginx安全配置">Nginx安全配置</h2>

<p>如果你是用<code>git</code>或者<code>svn</code>来部署代码,默认情况下,你的网站很可能已经泄露了<code>.git</code>目录,或者<code>.svn</code>目录</p>

<p>使用nginx配置过滤一切以<code>.</code>开头的文件和文件夹,防止被用户下载.</p>

<pre><code>location ~ /\. {
	deny all;
}
</code></pre>

<p>每个网站都需要这么配置可能有些麻烦,你可以在统一的文件中定义好<code>/etc/nginx/default.d/php.conf</code></p>

<pre><code>listen 80;
index index.html index.php;
try_files $uri $uri/ /index.php?$args;
location ~ /\. {
	deny all;
}
location ~ ^.+\.php$ {
	try_files $uri =404;
	fastcgi_pass 127.0.0.1:9000;
	include fastcgi.conf;
}

</code></pre>

<p>使用时,类似与下面,还不用每次写这么多配置了.</p>

<pre><code>server{
  server_name fed-wx.xxx.cn;
  root /data/www/fed-wx;
  include /etc/nginx/default.d/php.conf;
}

</code></pre>

<p>给http段添加,开启一些gzip特性,关闭显示服务器版本</p>

<pre><code>default_type        application/octet-stream;
sendfile            on;
tcp_nopush          on;
tcp_nodelay         on;
keepalive_timeout   65;
types_hash_max_size 2048;
server_tokens off;
ssi on;
gzip on;
gzip_min_length 1024;
gzip_proxied any;
gzip_comp_level 3;
gzip_types text/plain text/javascript text/css text/json application/xml application/javascript  application/json image/jpeg image/gif image/png;

</code></pre>

<h2 id="修改你的ssh默认端口-并且使用强密码">修改你的SSH默认端口,并且使用强密码</h2>

<p>每天都有大量的端口扫描来扫描你服务器IP的22端口,如果你的22端口密码又不强,很可能已被黑客侵入.</p>

<p>如果发现已经有大量的错误登陆,请立即更换端口.必要时考虑使用<code>fail2ban</code></p>

<h2 id="所有的网络通信都应该使用-https">所有的网络通信都应该使用<code>HTTPS</code></h2>

<p><code>http</code>并不安全,很有可能你收到和发出的信息,已被中间人劫持.</p>

<p>中间人劫持能查看你发送的信息,修改返回给你的数据包.</p>

<p>为此,使用http时,务必加盐加密你的密码,以减少在传输过程中被窃取的可能.</p>

<p>更有效的是使用<code>https</code>来有效防止中间人劫持.</p>

<h2 id="你的身份认证令牌应该多方关联">你的身份认证令牌应该多方关联.</h2>

<p>即便使用<code>https</code>,你的身份认证令牌,一旦从其他渠道泄漏,黑客便能使用你的身份进行操作.</p>

<p>特别是具有管理员权限的身份令牌,更是会带来严重后果,在<code>CSRF</code>攻击中偷走令牌是常有的事.</p>

<p>因此你起码需要将cookie关键信息设置为<code>httponly</code>和<code>security</code>(使用https时),并小心过滤允许用户输入的链接地址(包含图片,视频地址)和富文本等.
必要时开启<code>csrf-token</code>认证.</p>

<p>还需要确保你的认证<code>token</code>在丢失以后也不能在黑客手中登陆.</p>

<p>这需要你在生成<code>token</code>时,进行多方关联,哈希时可包括<code>IP地址</code>,<code>User Agent</code>,当然用户ID也需要关联,这个<code>token</code>只能这个用户用.</p>

<p>服务器验证时并不是从<code>token</code>能找到用户,就验证通过,还需要对这些信息进行校验,验证还是不是那个客户端发出的.</p>

<p>除此之外,哈希时不能简单的哈希,还需要加盐哈希,防止黑客拆解出哈希包含的字段进而可以自己算出token.</p>

<p>即使黑客不能拆解你的哈希算法,也不知道哈希字段有哪些,只要他能捕获你发出的请求,(或窃取走你的token和所有可能参与哈希的字段),一样可以模拟请求,使用你的身份进行操作,除非你哈希时包含了IP.
因为来源IP黑客是无法模拟的,除非他和你在同一个外网出口IP路由下.</p>

<p>但如果客户的IP经常变动,IP参与哈希可能体验太不好了,于是还是回到最初的问题,</p>

<p><strong>使用<code>https</code>,使用<code>httponly</code>和<code>security</code>的cookie,便能有效防止黑客捕获你的请求和偷走<code>token</code></strong></p>

<p>再加上<strong><code>token</code>关联校验策略</strong>, 再加上<strong><code>token</code>有效期滚动延期策略</strong>,三道屏障保护你的身份不被黑客冒用.</p>

<h2 id="合适和正确的验证码">合适和正确的验证码</h2>

<p>一上来就给用户弹验证码未免也太不友好了,合适的做法是账户最近连续3次登陆都是错误登陆再弹出高强度的验证码.</p>

<p>这很好实现,只需一个字段就能带来好的体验.</p>

<p>毕竟正常的用户大部分时间都是一次登陆成功.</p>

<p>用户使用过的验证码一定不能再次用来验证,要保证每次身份验证都是一个新的验证码.</p>

<p>不能拿一次对的验证码去重复尝试验证用户名,密码,否则等同于没有验证码.</p>

<p>即便使用了验证码,也是不可信的,现在的打码平台已近非常成熟了,简单的验证码也很容易做到机器识别了.</p>

<p>还应该限制用户登陆错误次数,一小时10次或一天30次不能再多了.</p>

<h2 id="登陆和找回密码返回合适的信息">登陆和找回密码返回合适的信息</h2>

<p>别再返回<code>用户名不存在</code>了,或者<code>密码不正确</code>了</p>

<p>为了这一点点的客户体验,你将带来巨大的安全隐患.你的网站存在用户遍历漏洞.</p>

<p>黑客可以很轻松的知道一个用户有没有在你的网站注册.</p>

<p>黑客手中有大量的泄漏账户信息,一些有价值的账户就值得黑客深挖,通过此漏洞,黑客很容易找到哪些用户都有哪些账户.</p>

<p>更可怕的是,大部分人不同网站的密码是相同的.也许你的网站安全性很好,还使用了https,但是黑客只要攻破了防线最弱的那个网站拿到用户的密码,你所说的安全也就全瓦解了.</p>

<p>因此给出<code>用户名或密码错误</code>和找回密码每次都需要高强度验证码,并且返回<code>如果你已注册,邮件已发送到您注册时的邮箱</code>才是有效安全的方式.</p>

<h2 id="可怕的撞库">可怕的撞库</h2>

<p>大部分人不同网站的密码相同,作为使用者个人值得注意,需要为每个网站设置不同的密码,防止一个的密码泄露,其他网站的密码也不安全了.</p>

<p>作为系统设计者,也需要注意,最基本的密码不能明文存储,其次密码需要加盐存储.再者所有用户的盐不能都是一个,需要每个用户都有自己的盐.</p>

<p>做到即使被脱库,也不能直接得到密码,即使观测所有密文和盐,知道部分用户的明文密码,也不能拆解出其他用户的明文密码.(这就需要每个用户有自己的盐)</p>

<p>密文切记不要直接md5,或者md5加固定盐.这些都已不在安全.</p>

<h2 id="修改关键信息时必须验证">修改关键信息时必须验证</h2>

<p>为避免黑客盗取了身份认证信息,冒用正常用户,去修改邮箱,手机号等关键信息.</p>

<p>在修改之前一定需要二次验证.</p>

<p>否则手机号被修改,您账户里的财产在做变动时,验证码就发送到黑客修改过的手机上了,黑客顺利成章的就完成了交易.</p>

<h2 id="邮箱和手机号已不在是有效凭据">邮箱和手机号已不在是有效凭据</h2>

<p>即使使用手机号和邮箱来标示一个用户,那也不一定是正确的.</p>

<p>目前黑市上已经有很多成熟的产业链,黑客花少量的钱就能很快拥有数以万计的手机号和邮箱,能便捷的发送和接收验证码.</p>

<p>有利可图的地方就有黑客存在,在发放红利时须倍加小心.</p>

<h2 id="手势解锁安全吗">手势解锁安全吗</h2>

<p>大部分的手势解锁都是靠次数和时间限制,但是程序在客户端,黑客很容易修改程序配置文件,达到无限次尝试.</p>

<p>并且手势密码的验证大部分都是本地验证,意味着黑客根本不需要与服务器端交互,有很多方式攻破程序里的本地认证</p>

<p>因此手势密码只防君子,不妨小人,不要把它作为十分安全的验证,在做敏感操作时务必联网验证用户密码.</p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/use-kvm/"> use kvm</a>
			</h1>
			<p class="post-date">Tue, Oct 18, 2016</p>
			<div class="post-text">
				

<h1 id="安装和配置kvm">安装和配置KVM</h1>

<h2 id="kvm与xen区别">KVM与XEN区别</h2>

<p>OPENVZ就不说了,是半虚拟化,不能安装Windows操作系统</p>

<p>KVM是内核模块,从2.6.20内核开始,kvm模块就包含在Linux内核中,只需加载此模块即可</p>

<pre><code>#查看宿主机CPU是否在硬件上支持虚拟化扩展特性
cat /proc/cpuinfo | grep -E &quot;(vmx|svm)&quot;

#加载kvm模块（Intel VT）
modprobe kvm
modprobe kvm-intel
#注意：如果加载失败，说明服务器硬件不支持或BIOS中未开启虚拟化扩展
</code></pre>

<p>运行命令<code>lsmod | grep kvm</code>检查 KVM 模块是否成功安装</p>

<p>XEN是一套虚拟化方案,可以直接安装,不需要先安装操作系统.</p>

<p>KVM起步较晚,XEN起步早发展成熟,但目前KVM潜力较大.</p>

<h2 id="kvm-与-qemu">KVM 与 qemu</h2>

<p><code>yum install qemu-kvm libvirt virt-install bridge-utils</code></p>

<p>qemu-kvm 该软件包主要包含KVM内核模块和适用于KVM的QEMU模拟器。KVM模块负责CPU和内存的调度，QEMU负责虚拟机I/O设备的模拟。</p>

<p>libvirt 提供Hypervisor和虚拟机的管理功能。</p>

<p>virt-install 创建和克隆虚拟机的命令行工具包。</p>

<p>bridge-utils 网桥管理工具包，负责桥接网络的创建、配置和管理等工作。</p>

<h2 id="激活并启动libvirtd服务">激活并启动libvirtd服务</h2>

<pre><code>systemctl enable libvirtd
systemctl start libvirtd
</code></pre>

<h2 id="安装centos7">安装CentOS7</h2>

<p><code>diskutil list</code>查看所有磁盘</p>

<p><code>diskutil unmountdisk /dev/disk1</code> 解除其挂载</p>

<p>用dd将ISO文件写入</p>

<p><code>sudo dd if=/data/files/iso/CentOS-7-x86_64-Minimal-1511.iso of=/dev/disk2 bs=1m</code></p>

<p>安装好系统后,更换网易的源 <a href="http://mirrors.163.com/.help/centos.html">http://mirrors.163.com/.help/centos.html</a></p>

<pre><code>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
cd /etc/yum.repos.d
wget http://mirrors.163.com/.help/CentOS7-Base-163.repo
yum clean all
yum makecache
</code></pre>

<p>搜狐也有,但版本太老 <a href="http://mirrors.sohu.com/help/centos.html">http://mirrors.sohu.com/help/centos.html</a></p>

<p>可以使用清华大学的. <a href="https://lug.ustc.edu.cn/wiki/mirrors/help/centos">https://lug.ustc.edu.cn/wiki/mirrors/help/centos</a> 速度都十分快.</p>

<h2 id="启用kvm后-需要配置网卡">启用KVM后,需要配置网卡</h2>

<p><code>cd /etc/sysconfig/network-scripts/</code></p>

<p>桥接网卡</p>

<p><code>brctl addbr br0</code> 添加一个虚拟网卡</p>

<p><code>brctl addif br0 em2</code> 将网卡<code>br0</code>桥接到<code>em2</code> ,这一步将会导致em2断网,远程ssh将会断开</p>

<p><code>brctl stp br0 on</code> 将br0设置为启用STP协议</p>

<p><code>ifconfig em2 0</code> #将em2的IP设置为0</p>

<p><code>dhclient br0</code> #将br0网络配置好</p>

<p><code>brctl show</code></p>

<p>然后<code>systemctl restart network</code></p>

<p><code>route</code> 查看默认网关</p>

<p><a href="https://wiki.centos.org/zh/HowTos/KVM">https://wiki.centos.org/zh/HowTos/KVM</a></p>

<h2 id="创建虚拟机磁盘镜像文件">创建虚拟机磁盘镜像文件</h2>

<p>不能创建太小,建议5G-50G</p>

<p>qcow2格式是kvm支持的标准格式，raw格式为虚拟磁盘文件通用格式。有测试数据表明raw格式的I/O性能略高于qcow2格式，但是在加密，容量，快照方面qcow2格式有优势</p>

<pre><code>qemu-img create -f qcow2 test.qcow2 20G  //建立qcow2格式磁盘文件
qemu-img create -f raw test.raw 20G      //建立raw格式磁盘文件
qemu-img info test.qcow2                 //查看已经创建的虚拟磁盘文件

</code></pre>

<h2 id="创建虚拟机">创建虚拟机</h2>

<p>使用<code>osinfo-query os</code>可以查看<code>os-variant</code>都有哪些代号</p>

<p><a href="https://raymii.org/s/articles/virt-install_introduction_and_copy_paste_distro_install_commands.html">https://raymii.org/s/articles/virt-install_introduction_and_copy_paste_distro_install_commands.html</a></p>

<p>创建 Ubuntu</p>

<pre><code>virt-install \
--name ubuntu \
--ram 512 --vcpus 1 \
--boot network,cdrom,menu=on \
--disk path=/disk/kvm/disk1,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--nographics --accelerate \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--cdrom=/data/iso/ubuntu-16.04.1-server-amd64.iso \
--extra-args='console=tty0 console=ttyS0,115200n8 serial' \
--hvm --dry-run
</code></pre>

<p>创建CentOS</p>

<pre><code>virt-install \
--name centos \
--ram 512 --vcpus 1 \
--disk path=/disk/kvm/disk1,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--accelerate \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--location=/data/iso/CentOS-7-x86_64-Minimal-1511.iso \
--extra-args='console=tty0 console=ttyS0,115200n8 serial' \
--hvm --dry-run
</code></pre>

<p>virsh &ndash;connect qemu:///system</p>

<p>创建Debain</p>

<p>先挂载 <code>sudo mount -o loop,unhide -t iso9660 -r /data/iso/debian-8.6.0-amd64-CD-1.iso /mnt/cdrom</code></p>

<p>需要nfs启动 <code>service nfs start</code></p>

<p>添加<code>/mnt/cdrom    *(ro,insecure,all_squash)</code>到文件<code>/etc/exports</code></p>

<p>并刷新<code>exportfs -r</code></p>

<pre><code>virt-install \
--name debain \
--ram 512 --vcpus 1 \
--boot network,cdrom,menu=on \
--disk path=/disk/kvm/disk4,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--accelerate \
--location=/mnt/cdrom \
--extra-args='console=tty0 console=ttyS0,115200n8 serial' \
--vnc --vncport=5911 --vnclisten=0.0.0.0 \
--hvm --dry-run
</code></pre>

<p>创建Windows Server</p>

<p><code>qemu-img create -f qcow2 /disk/kvm/windisk1 50G</code></p>

<p>针对Windows需要安装一些驱动</p>

<p><code>sudo wget https://fedorapeople.org/groups/virt/virtio-win/virtio-win.repo -O /etc/yum.repos.d/virtio-win.repo</code></p>

<p><code>sudo yum install virtio-win</code></p>

<p><a href="https://fedoraproject.org/wiki/Windows_Virtio_Drivers">https://fedoraproject.org/wiki/Windows_Virtio_Drivers</a></p>

<pre><code>virt-install \
--name windows2012 \
--ram 4096 --vcpus 2 \
--disk path=/data/iso/cn_windows_server_2012_r2_with_update_x64_dvd_4048415.iso,device=cdrom \
--disk path=/disk/kvm/windisk1,size=50,format=qcow2,bus=virtio,cache=writeback \
--cdrom=/usr/share/virtio-win/virtio-win-0.1.126.iso \
--os-type windows \
--os-variant win2k12r2 \
--bridge=br0,model=virtio \
--accelerate \
--graphics vnc,port=5999,listen=0.0.0.0 \
--console pty,target_type=serial \
--hvm --dry-run
</code></pre>

<pre><code>virt-install \
--name xp1 \
--ram 1024 --vcpus 1 \
--disk path=/data/iso/Deepin_Windows_LiteXP_v6.2_SP3.iso,device=cdrom \
--disk path=/disk/kvm/winxp1,size=10,format=qcow2,bus=virtio,cache=writeback \
--cdrom=/usr/share/virtio-win/virtio-win-0.1.126.iso \
--os-type windows \
--os-variant winxp \
--bridge=br0,model=virtio \
--accelerate \
--graphics vnc,port=5999,listen=0.0.0.0 \
--console pty,target_type=serial \
--hvm --dry-run
</code></pre>

<p>出现<code>ERROR    不能混用 --graphics 和旧式的图形选项</code>可能是需要去掉<code>--keymap</code></p>

<p>关于 加载 virtio 驱动可以参考  <a href="http://www.ilanni.com/?p=5877">http://www.ilanni.com/?p=5877</a></p>

<p><strong>选择加载<code>viostor</code>磁盘驱动</strong></p>

<blockquote>
<p>disk属性就是指虚拟机使用哪一个磁盘镜像文件作为存储地方，指定刚才创建的镜像文件位置即可，size=10,format=qcow2,bus=virtio分别是指大小，格式（跟镜像格式一致），磁盘总线类型（指Value can be ’ide’, ’scsi’, ’usb’, ’virtio’ or ’xen’，virtio是专门为kvm制定的bus，比较常用），大小需要比镜像文件大小要小，相当于镜像是容器，这个disk是里面的水，水太多就溢出了。</p>

<p>bridge=br0,model=virtio –keymap=en-us分别指网卡使用，网卡模式即驱动模式，和键盘制式，桥接模式都使用br0，而虚拟机需要使用virtio这个驱动才能使用虚拟网卡，这个虚拟网卡驱动在linux下支持很好，在windows下支持一般，键盘制式如果不指定的话会出现键位错乱的情况，一般我们使用英式。</p>
</blockquote>

<p>使用<code>virsh</code>可以管理已创建的虚拟机</p>

<p>virsh shutdown demo 正常关闭虚拟机</p>

<p>virsh destroy demo 直接销毁虚拟机</p>

<p>可见 <a href="http://www.cnblogs.com/lin1/p/5776280.html">http://www.cnblogs.com/lin1/p/5776280.html</a></p>

<p>启动并进入虚拟机</p>

<pre><code>virsh start 域名 --console
</code></pre>

<p>10，彻底删除虚拟机</p>

<p>1,删除虚拟机   virsh destroy +域名</p>

<p>2，解除标记     virsh undefine +域名</p>

<p>3，删除虚拟机文件</p>

<p><code>virsh destroy windows2012 &amp;&amp;  virsh undefine windows2012</code></p>

<p>通过virt-clone命令克隆虚拟机</p>

<p><code>virt-clone -o centos -n centos2 -f /disk/kvm/disk2</code></p>

<p><code>virsh -c qemu:///system list</code> 可以查看正在运行的机器</p>

<p><code>virsh vncdisplay windows2012</code>查看vnc端口</p>

<p>可以使用其他机器上的vnc  viewer 连接</p>

<p>本机 <code>virt-viewer --connect qemu:///system windows2012</code></p>

<p>windows系统可使用 vncviewer (<a href="http://share.suconghou.cn/files/bin/vncviewer.zip">http://share.suconghou.cn/files/bin/vncviewer.zip</a>) 连接</p>

<p>全屏下用F8键可唤出菜单.</p>

<h3 id="修改相关">修改相关</h3>

<p><code>hostnamectl</code> 可以查看主机相关信息,主机名,内核版本,64位等</p>

<p>只查看静态、瞬态或灵活主机名，分别使用<code>--static</code>,<code>--transient</code>或<code>--pretty</code>选项</p>

<p>要同时修改所有三个主机名：静态、瞬态和灵活主机名：
<code>hostnamectl set-hostname Linuxidc</code></p>

<p><code>hostname -I</code> 可以获取所有网卡上配置的IP</p>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/iptables/"> iptables</a>
			</h1>
			<p class="post-date">Wed, Sep 14, 2016</p>
			<div class="post-text">
				

<h1 id="iptables相关配置">iptables相关配置</h1>

<p>配置<code>iptables</code>之前,建议添加一个crontab定时重置iptables,防止将自己阻挡.</p>

<p>建议写入<code>/usr/iptab.sh</code>,加入<code>crontab</code>,每个整点执行</p>

<pre><code>iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -F
iptables -X
iptables -Z
</code></pre>

<h2 id="查看本机关于iptables的设置情况">查看本机关于IPTABLES的设置情况</h2>

<pre><code>iptables -L -n
</code></pre>

<h2 id="清除原有规则">清除原有规则.</h2>

<p>不管你在安装linux时是否启动了防火墙,如果你想配置属于自己的防火墙,那就清除现在filter的所有规则.
清除预设表filter中的所有规则链的规则</p>

<pre><code>iptables -F
</code></pre>

<p>清除预设表filter中使用者自定链中的规则</p>

<pre><code>iptables -X
</code></pre>

<h2 id="保存配置">保存配置</h2>

<p>刚刚配置的重启以后就会丢失,想要保存使用</p>

<pre><code>iptables save
</code></pre>

<p>有的可能是<code>iptables-save</code></p>

<p>这样就写到<code>/etc/sysconfig/iptables</code> 文件里了.
写入后记得把防火墙重起一下,才能起作用.</p>

<pre><code>service iptables restart
</code></pre>

<h2 id="设定预设规则">设定预设规则</h2>

<p>默认的入口,出口,转发策略都是ACCEPT
下面要改变这种规则</p>

<p>iptables 采用黑名单加白名单的方式, 未命中白名单的将采用预设规则</p>

<p>下面操作注意,为避免ssh端口22被拦截,首先添加</p>

<pre><code>iptables -A INPUT -p tcp --dport 22 -j ACCEPT
</code></pre>

<p>保证22端口入口畅通,注意如果你的OUTPUT模式设置为DROP(上面已经清空了,默认为ACCEPT),还需要添加</p>

<pre><code>iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
</code></pre>

<p>保证出口22端口畅通
下面开始折腾吧</p>

<p>1.修改入口流量默认规则为DROP,除非命中用户规则,否则拦截所有入口流量(注意上面一定要排除ssh的端口,否则直接掉线)</p>

<pre><code>iptables -P INPUT DROP
</code></pre>

<p>如果你使用了docker,这里好像会对docker的网络造成影响</p>

<p>2.允许所有出口流量(重置iptables时,这其实就是默认的规则)</p>

<pre><code>iptables -P OUTPUT ACCEPT
</code></pre>

<p>3.禁止所有转发流量,除了命中用户规则的</p>

<pre><code>iptables -P FORWARD DROP
</code></pre>

<h3 id="常用端口开启">常用端口开启</h3>

<p>开启80,443端口,http,https服务</p>

<pre><code>iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT
</code></pre>

<p>开启21端口,ftp服务</p>

<pre><code>iptables -A INPUT -p tcp --dport 21 -j ACCEPT
</code></pre>

<h3 id="开启基本端口">开启基本端口</h3>

<p>允许icmp包通过,也就是允许ping</p>

<pre><code>iptables -A INPUT -p icmp -j ACCEPT
</code></pre>

<p>允许loopback!(不然会导致DNS无法正常关闭等问题)</p>

<p><strong>如果未启用此项,常见的fastcgi_pass 127.0.0.1 将会有问题</strong></p>

<pre><code>iptables -A INPUT -i lo -p all -j ACCEPT
</code></pre>

<p>iptables 配置实时生效,如果拦截了ssh端口,将立即掉线!</p>

<p>无论iptabes启动与否，ps -ef都不会看到iptables的进程，这是因为iptables是由内核来实现的，也就是说iptables的功能已经融入到内核里面了</p>

<p>iptables只是一个工具，将IP规则写入内核，让内核去处理。所以iptables只有在加规则的时候才会看得到进程，加完了就退出了</p>

<p>iptables并不是一个普通的daemon，只是一个普通的工具，添加一些规则到kernel的filter列表里面。</p>

<h3 id="ip-拦截">IP 拦截</h3>

<p>拦截一个IP</p>

<p><code>iptables -I INPUT -s 1.2.3.4 -j DROP</code></p>

<p>解封此IP</p>

<p><code>iptables -D INPUT -s 1.2.3.4 -j DROP</code></p>

<p>参数-I是表示Insert（添加），-D表示Delete（删除）</p>

<p>INPUT表示入站，DROP表示放弃连接</p>

<p>IP段</p>

<p>192.168.1.x 可以写 <code>192.168.1.0/24</code></p>

<p>192.168.x.x 可以写 <code>192.168.0.0/16</code></p>

<p>192.x.x.x   可以写 <code>192.0.0.0/8</code></p>

<pre><code>
#清除配置
/sbin/iptables -P INPUT ACCEPT
/sbin/iptables -F
/sbin/iptables -X
#开放本地和Ping
/sbin/iptables -A INPUT -i lo -j ACCEPT
/sbin/iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
/sbin/iptables -A INPUT -p icmp -j ACCEPT
#配置内网白名单
/sbin/iptables -A INPUT -s 10.0.0.0/8 -j ACCEPT
/sbin/iptables -A INPUT -s 172.16.0.0/12 -j ACCEPT
/sbin/iptables -A INPUT -s 192.168.0.0/16 -j ACCEPT
#配置外网白名单
/sbin/iptables -A INPUT -s 180.168.36.198 -j ACCEPT
/sbin/iptables -A INPUT -s 180.168.34.218 -j ACCEPT
/sbin/iptables -A INPUT -s 222.73.202.251 -j ACCEPT
#控制端口
/sbin/iptables -A INPUT -p tcp --dport 80 -j ACCEPT
/sbin/iptables -A INPUT -p tcp --dport 22 -j ACCEPT
#拒绝其它
/sbin/iptables -A INPUT -j DROP
/sbin/iptables -A FORWARD -j DROP
#开放出口
/sbin/iptables -A OUTPUT -j ACCEPT

</code></pre>

			</div>
		</div>
		
		<div class="post">
			<h1 class="post-title">
				<a href="/post/pc-hardware/"> pc hardware</a>
			</h1>
			<p class="post-date">Sun, Sep 4, 2016</p>
			<div class="post-text">
				

<h2 id="修电脑相关知识">修电脑相关知识</h2>

<h3 id="较好的pe">较好的PE</h3>

<p><strong>微PE</strong></p>

<p><a href="http://www.wepe.com.cn/">http://www.wepe.com.cn/</a> 自带刻录,可以一键安装到U盘,硬盘等,支持UEFI,CMS等多种启动方式.</p>

<blockquote>
<p>一般的BIOS里找不到UEFI/CMS的切换设置,可能是<code>security boot</code>的配置,禁用<code>security boot</code>试试</p>

<p>如果在BIOS里找不到U盘,可能是<code>fastboot</code>的问题,可以禁用fastboot,安装好系统后在开启.</p>

<p>硬盘的设置模式里,找不到U盘或者硬盘,可以尝试切换<code>AHCI/IDE</code>,注意安装好系统后,此选项不能够再随意切换,否知导致系统进不去.</p>
</blockquote>

<p>休眠能将现有所有工作保存到硬盘,下次开机恢复上次的会话,Windows8及以后采用了混合休眠机制</p>

<p>你可能找不到单纯的休眠按钮.</p>

<p>可以使用<code>shutdown -h</code>休眠</p>

<p>其他一些补充</p>

<pre><code>关机计算机：shutdown.exe -s -t 00
重启计算机：shutdown.exe -r -t 00
注销计算机：shutdown.exe -l -t 00
锁定计算机：rundll32.exe user32.dll,LockWorkStation
休眠计算机：rundll32.exe powrProf.dll,SetSuspendState
睡眠计算机：rundll32.exe powrprof.dll,SetSuspendState 0,1,0,
</code></pre>

<h2 id="性能天梯图">性能天梯图</h2>

<p>在新标签查看大图</p>

<p>CPU天梯图</p>

<p><img src="https://img.alicdn.com/imgextra/i4/693806815/TB2ulpikCxjpuFjSszeXXaeMVXa_!!693806815.jpg" alt="CPU天梯图1" /></p>

<p>CPU天梯图其他版本</p>

<p><img src="https://img.alicdn.com/imgextra/i3/693806815/TB2KExqkwRkpuFjy1zeXXc.6FXa_!!693806815.jpg" alt="CPU天梯图2" /></p>

<p>显卡天梯图</p>

<p><img src="https://img.alicdn.com/imgextra/i1/693806815/TB2heFDkB8lpuFjSspaXXXJKpXa_!!693806815.jpg" alt="显卡天梯图" /></p>

			</div>
		</div>
		
	</div>
	<nav>
		
    
    <ul class="pagination">
        
        <li>
            <a href="/" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
        </li>
        
        <li
        class="disabled">
        <a href="" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
        </li>
        
        <li
        class="active"><a href="/">1</a></li>
        
        <li
        ><a href="/page/2/">2</a></li>
        
        <li
        ><a href="/page/3/">3</a></li>
        
        <li
        ><a href="/page/4/">4</a></li>
        
        <li
        ><a href="/page/5/">5</a></li>
        
        <li
        ><a href="/page/6/">6</a></li>
        
        <li
        ><a href="/page/7/">7</a></li>
        
        <li
        ><a href="/page/8/">8</a></li>
        
        <li
        >
        <a href="/page/2/" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
        </li>
        
        <li>
            <a href="/page/8/" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
        </li>
        
    </ul>
    
	</nav>
</div>
	<div class="music-container">
	<div class="music-header">
	    <a class="fa-button home" href="javascript:music.show(0)"><i class="fa fa-home" title="Home"></i></a>
	    <a class="fa-button next" href="javascript:music.next()"><i class="fa fa-chevron-right" title="Next"></i></a>
	</div>
	<div class="backdrop"></div>
	<div class="music-player">
		<div class="cover">
            <img src="http://p4.music.126.net/ckfEE9UUGcnGHylQJ12ENA==/670702092966093.jpg?param=350y350">
            <div class="foredrag"><i class="fa fa-play"></i></div>
        </div>
        <div class="progress">
            <div class="elapse"></div>
        </div>
        <div class="detail">
            <div class="title">音乐标题</div>
            <div class="artist">歌手</div>
        </div>
	</div>
</div>
<div id="loader" style="z-index:99999;" class="pageload-overlay" data-opening="M 40 -21.875 C 11.356078 -21.875 -11.875 1.3560784 -11.875 30 C -11.875 58.643922 11.356078 81.875 40 81.875 C 68.643922 81.875 91.875 58.643922 91.875 30 C 91.875 1.3560784 68.643922 -21.875 40 -21.875 Z">
    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 80 60" preserveAspectRatio="xMidYMid slice"> <path d="M40,30 c 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 0,0 Z"/></svg>
</div>

	<footer class="footer">
		<div class="footer-nav">
			<ul>
				<li><a href="/post/">归档</a></li>
				<li><a href="/">专题</a></li>
				<li><a href="/life/">生活</a></li>
				<li><a href="/about/">关于</a></li>
			</ul>
		</div>
	</footer>
	<script type="text/javascript" src="/js/main.min.js" data-no-instant></script>
</body>
</html>


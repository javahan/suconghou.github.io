<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 苏苏的博客</title>
    <link>http://blog.suconghou.cn/categories/linux/index.xml</link>
    <description>Recent content in Linux on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="http://blog.suconghou.cn/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux相关操作</title>
      <link>http://blog.suconghou.cn/post/linux/</link>
      <pubDate>Thu, 21 Jan 2016 13:40:53 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux/</guid>
      <description>

&lt;h2 id=&#34;linux用户管理&#34;&gt;Linux用户管理&lt;/h2&gt;

&lt;h3 id=&#34;添加用户adduser&#34;&gt;添加用户adduser&lt;/h3&gt;

&lt;p&gt;假如用户名为&lt;code&gt;work&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;adduser work -M&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# add rslsync user without home dir and cannot login
sudo adduser --shell /bin/nologin --no-create-home --group rslsync
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-M, &amp;ndash;no-create-home        不创建用户的主目录
-s, &amp;ndash;shell SHELL       新账户的登录 shell,nologin就是登陆不了
-G, &amp;ndash;groups GROUPS 新账户的附加组列表&lt;/p&gt;

&lt;p&gt;&lt;code&gt;adduser -h&lt;/code&gt;查看完整帮助&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;用法：adduser [选项] 登录
      adduser -D
      adduser -D [选项]

选项：
  -b, --base-dir BASE_DIR	新账户的主目录的基目录
  -c, --comment COMMENT         新账户的 GECOS 字段
  -d, --home-dir HOME_DIR       新账户的主目录
  -D, --defaults		显示或更改默认的 useradd 配置
  -e, --expiredate EXPIRE_DATE  新账户的过期日期
  -f, --inactive INACTIVE       新账户的密码不活动期
  -g, --gid GROUP		新账户主组的名称或 ID
  -G, --groups GROUPS	新账户的附加组列表
  -h, --help                    显示此帮助信息并推出
  -k, --skel SKEL_DIR	使用此目录作为骨架目录
  -K, --key KEY=VALUE           不使用 /etc/login.defs 中的默认值
  -l, --no-log-init	不要将此用户添加到最近登录和登录失败数据库
  -m, --create-home	创建用户的主目录
  -M, --no-create-home		不创建用户的主目录
  -N, --no-user-group	不创建同名的组
  -o, --non-unique		允许使用重复的 UID 创建用户
  -p, --password PASSWORD		加密后的新账户密码
  -r, --system                  创建一个系统账户
  -R, --root CHROOT_DIR         chroot 到的目录
  -s, --shell SHELL		新账户的登录 shell
  -u, --uid UID			新账户的用户 ID
  -U, --user-group		创建与用户同名的组
  -Z, --selinux-user SEUSER		为 SELinux 用户映射使用指定 SEUSER
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;修改密码&#34;&gt;修改密码&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;passwd work&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;修改用户名&#34;&gt;修改用户名&lt;/h3&gt;

&lt;p&gt;alarm为旧用户名&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new_user=lao
# change user name
usermod -l $new_user -d /home/$new_user -m alarm
# chenge user group
groupmod -n $new_user alarm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cnblogs.com/xd502djj/archive/2011/11/23/2260094.html&#34;&gt;http://www.cnblogs.com/xd502djj/archive/2011/11/23/2260094.html&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;linux实用命令&#34;&gt;Linux实用命令&lt;/h2&gt;

&lt;h2 id=&#34;w&#34;&gt;w&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;w&lt;/code&gt;命令能容清晰的显示,服务器在线时间,负载以及当前登陆的用户&lt;/p&gt;

&lt;h2 id=&#34;vmstat&#34;&gt;vmstat&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 显示开机以来的平均值，而不是前一秒的值
&lt;code&gt;vmstat 1&lt;/code&gt;命令指定一个参数 1 运行，来打印每一秒的统计摘要.
这些列代表的信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;r：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：&amp;rdquo;r&amp;rdquo;的值大于了 CPU 的数量就表示已经饱和了。
free：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。&amp;rdquo;free -m&amp;rdquo; 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。
si, so：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。
us, sy, id, wa, st：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。
对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。&lt;/p&gt;

&lt;p&gt;SIZE(VIRT): 进程使用的地址空间, 如果进程映射了100M的内存, 进程的地址空间将报告为100M内存. 事实上, 这个大小不是一个程序实际使用的内存数.&lt;/p&gt;

&lt;p&gt;RSS(RES): &amp;ldquo;Resident Set Size&amp;rdquo;, 实际驻留&amp;rdquo;在内存中&amp;rdquo;的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.&lt;/p&gt;

&lt;p&gt;SHARE(SHR): RSS中与其它进程共享的内存部分大小.&lt;/p&gt;

&lt;p&gt;VMSIZE: 一个进程占用的总的地址空间大小. 它包括了没有映射到内存中的页面。&lt;/p&gt;

&lt;p&gt;SZ（DATA）: 映射到内存中的页面, 这些页面仅由进程单独使用. 这也是我们最关心地方: 进程实际占用的内存数。&lt;/p&gt;

&lt;h2 id=&#34;top&#34;&gt;top&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;top -b -n1&lt;/code&gt; 可以只执行一次,用于将结果重定向到文件.&lt;/p&gt;

&lt;h2 id=&#34;free&#34;&gt;free&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;free -m&lt;/code&gt; &lt;code&gt;free -h&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;按内存占用排序&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
ps -eo rss,vsz,pid,ppid,time,etime,command --sort=rss   # 按内存
ps -eo rss,vsz,pid,ppid,time,etime,command --sort=time  # 按CPU时间,etime启动时间,comm等都可以.

# MAC无法使用`--sort`上需要使用`| sort -n`

ps -eo rss,vsz,pid,ppid,time,etime,command |sort -n

# alpine 里这样用,不支持--sort, 同样也可以 `top -b -n1`
ps -o rss,vsz,pid,ppid,time,etime,args
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ssh&#34;&gt;ssh&lt;/h2&gt;

&lt;p&gt;配置无密码登陆
&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub root@host&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果是其他端口可以-p指定端口
&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub -p 26671 root@host&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用指定私钥登陆
&lt;code&gt;ssh –i  id_rsa root@host&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pgrep&#34;&gt;pgrep&lt;/h2&gt;

&lt;p&gt;根据名字或其他属性查询出进程的PID&lt;/p&gt;

&lt;p&gt;如:&lt;code&gt;pgrep nginx -fl&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pkill&#34;&gt;pkill&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;pgrep&lt;/code&gt;类似,不同的是向进程发送信号,默认发送&lt;code&gt;SIGTERM&lt;/code&gt;信号,查看都有哪些信号可用,可以使用&lt;code&gt;kill -l&lt;/code&gt;查看&lt;/p&gt;

&lt;p&gt;pkill -f &amp;ldquo;php index.php em&amp;rdquo;&lt;/p&gt;

&lt;p&gt;类似&lt;code&gt;pkill&lt;/code&gt;的命令是&lt;code&gt;killall&lt;/code&gt;,后面都是可以直接加进程名字批量杀死进程&lt;/p&gt;

&lt;h2 id=&#34;pstree&#34;&gt;pstree&lt;/h2&gt;

&lt;p&gt;用树的形式显示正在运行的进程,树的节点为指定的PID(忽略则为init进程)&lt;/p&gt;

&lt;h2 id=&#34;ss&#34;&gt;ss&lt;/h2&gt;

&lt;p&gt;用于显示socket的统计信息,&lt;code&gt;-s&lt;/code&gt;用于显示汇总&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt;用于列出正在监听的&lt;code&gt;socket&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;显示进程信息,&lt;code&gt;ss -pl&lt;/code&gt; 可以查看使用网络端口的进程名字&lt;/p&gt;

&lt;h2 id=&#34;磁盘相关&#34;&gt;磁盘相关&lt;/h2&gt;

&lt;h3 id=&#34;dd&#34;&gt;dd&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dd&lt;/code&gt;把指定的输入文件拷贝到指定的输出文件中,并且在拷贝的过程中可以进行格式转换。&lt;/p&gt;

&lt;p&gt;if =输入文件(或设备名称)
of =输出文件(或设备名称)
bs = bytes 同时设置读/写缓冲区的字节数(等于设置obs和obs)
count = blocks 只拷贝输入的blocks块&lt;/p&gt;

&lt;p&gt;创建一个100M的空文件
&lt;code&gt;dd if=/dev/zero of=hello.txt bs=100m count=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小&#34;&gt;查看当前目录下所有一级子目录文件夹大小&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小-并排序&#34;&gt;查看当前目录下所有一级子目录文件夹大小 并排序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1 |sort&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上两条命令不适用于MacOs,可以使用&lt;code&gt;du -sh *&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;ps&lt;/h2&gt;

&lt;p&gt;ps ef  查看进程的状态&lt;/p&gt;

&lt;p&gt;ps auxw 查看进程的CPU,内存占用&lt;/p&gt;

&lt;p&gt;ps 默认是按照PID排序的,若要按内存使用排序&lt;code&gt;ps auxw --sort=rss&lt;/code&gt;,同理按虚拟内存排序&lt;code&gt;ps auxw --sort=vsz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mac上无法使用&lt;code&gt;--sort&lt;/code&gt;,可以采用&lt;code&gt;sort&lt;/code&gt;排序,如rss在第六列,则&lt;code&gt;ps auxw | sort -k6,6n&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;lscpu&lt;/p&gt;

&lt;h2 id=&#34;nc&#34;&gt;nc&lt;/h2&gt;

&lt;p&gt;nc 命令默认没有安装,需要自己安装,&lt;code&gt;yum install nc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传送字符与文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc -l 9090&lt;/code&gt;监听端口9090&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc host 9090&lt;/code&gt;连接host的9090端口,通信建立后,可以双向通信,实现文字聊天等,也可以传送文件&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc -l 9090 &amp;gt; file&lt;/code&gt; ,另一端发送文件&lt;code&gt;nc host 9090 &amp;lt; file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;传送文件夹(压缩文件) &lt;code&gt;nc -l 9090 |tar xzvf -&lt;/code&gt; , 另一端发送文件&lt;code&gt;tar czvf – dir | nc host 9090&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同样可以拷贝硬盘 &lt;code&gt;nc -l 9090 | dd of=/dev/sda&lt;/code&gt;,另一端发送&lt;code&gt;dd if=/dev/sda | nc host 9090&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有个高性能的方法：
1.先在接收方执行:
nc -l 6677 | tar -C 接收文件的目录 -zxf - #接收目录最好是个空目录，防止覆盖的风险&lt;/p&gt;

&lt;p&gt;2.再在发送方执行:
tar -zcvf - 要发送的目录 | nc 接收方 ip 6677&lt;/p&gt;

&lt;p&gt;ssh 也可以使用 pipe 传送 &lt;code&gt;tar zcf - attaches | ssh root@ip &amp;quot;tar zxf - -C /path/to/&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;传送大量大文件 使用 &lt;code&gt;lftp&lt;/code&gt;也是一个好方案&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Use lftp, its much faster than rsync and its best for mirroring websites (many small files). It can also transfer in parallel using multiple connections:

lftp -u username,password sftp://ip-address -e &#39;mirror --only-newer --no-dereference --parallel=5 /remote/path/ /destination/;quit&#39;
If one connection breaks it will reconnect and continue. If you break the transfer it will skip existing files and continue.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;端口扫描&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nc -vz -w 1 someIp 1-1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模拟调试http请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GET / HTTP/1.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端口转发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用之前需要了解其他的命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令将标准输入的数据写入标准输出和tee命令指定的文件参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkfifo&lt;/code&gt;命令用于创建一个FIFO（先进先出）方式的命名管道&lt;/p&gt;

&lt;p&gt;标准流:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stdin	0
stdout	1
stderr	2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** listener-to-client模式(用于外网访问内网) **&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;http://onestraw.net/cybersecurity/netcat-advanced-usage/&#34;&gt;http://onestraw.net/cybersecurity/netcat-advanced-usage/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一份linux别名和函数库&#34;&gt;一份Linux别名和函数库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;alias tree=&amp;quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39; &amp;quot;;
alias cls=&amp;quot;cd $1;ls -lh;&amp;quot;;
# 获得你的公网IP地址和主机名。
alias ipinfo=&amp;quot;curl ifconfig.me &amp;amp;&amp;amp; curl ifconfig.me/host&amp;quot;;
# 显示出哪个应用程序连接到网络。
alias listen=&amp;quot;lsof -P -i -n&amp;quot;;
# 显示出活动的端口。
alias port=&#39;netstat -uanltp&#39;
# 统计TCP连接个数
alias tcpstatus=&amp;quot;netstat -n|awk &#39;/^tcp/{++S[\$NF]} END {for(a in S) print a,S[a]}&#39;&amp;quot;
# 回到上层目录
alias ..=&#39;cd ..&#39;
# 去到上两层目录
alias ...=&#39;cd ../..&#39;
# 按列格式化输出mount信息。
alias cmount=&amp;quot;mount | column -t&amp;quot;
# 查看你还有剩下多少内存
alias meminfo=&#39;free -m -l -t&#39;
# 按照文件在磁盘存储的大小排序，显示当前目录的文件列表。
sbs() { du -b --max-depth 1 | sort -nr | perl -pe &#39;s{([0-9]+)}{sprintf &amp;quot;%.1f%s&amp;quot;, $1&amp;gt;=2**30? ($1/2**30, &amp;quot;G&amp;quot;): $1&amp;gt;=2**20? ($1/2**20, &amp;quot;M&amp;quot;): $1&amp;gt;=2**10? ($1/2**10, &amp;quot;K&amp;quot;): ($1, &amp;quot;&amp;quot;)}e&#39;;}
# 找出指定目录中最大的10个文件
largefile() { find . -type f -exec du -k {} \; | sort  -nrk 1 | head; }
# 查看当前目录大于[多少]kb的文件,速度更快
bigthan() { size=${1:-100}; find . -type f -size +&amp;quot;$size&amp;quot;k |xargs  ls  -lh ; }
# 返回你的当前IP地址的地理位置。
getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep &#39;city|state|country&#39;|awk &#39;{print $3,$4,$5,$6,$7,$8}&#39;|sed &#39;s\ip address flag \\&#39;|sed &#39;s\My\\&#39;;}
# 删除.log.1.gz 或者 .log.1.bz2
delog(){ ls | grep &amp;quot;log.\d\+.\(bz2\|gz\)&amp;quot; | xargs rm}

# 查看最占用内存的前五个进程(根据第几列可修改k6)
topmem()
{
	ps aux | sort -k6nr | head -n5;
}


&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;部分快捷键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
CTRL + U -剪切光标前的内容

CTRL + K -剪切光标至行末的内容

CTRL + Y -粘贴

CTRL + E -移动光标到行末

CTRL + A -移动光标到行首

ALT + F -跳向下一个空格

ALT + B -跳回上一个空格

ALT + Backspace -删除前一个单词

CTRL + W -剪切光标后一个单词

Shift + Insert -向终端内粘贴文本

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;压缩率 xz &amp;gt; 7z &amp;gt; bzip2 &amp;gt; gzip &amp;gt; zip&lt;/p&gt;

&lt;p&gt;gzexe 创建自解压文件&lt;/p&gt;

&lt;p&gt;xz5.2以上版本支持多线程压缩,xz -T0 就可以自动按机器线程数多线程执行了,xz 支持 env 环境变量，XZ_OPT=-T0 xz xxx.file 就行啦&lt;/p&gt;

&lt;p&gt;多线程的压缩速度几乎与gzip相当&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 查看你机器的CPU个数,超线程信息
sysinfo() {
physicalNumber=0
coreNumber=0
logicalNumber=0
HTNumber=0
logicalNumber=$(grep &amp;quot;processor&amp;quot; /proc/cpuinfo|sort -u|wc -l)
physicalNumber=$(grep &amp;quot;physical id&amp;quot; /proc/cpuinfo|sort -u|wc -l)
coreNumber=$(grep &amp;quot;cpu cores&amp;quot; /proc/cpuinfo|uniq|awk -F&#39;:&#39; &#39;{print $2}&#39;|xargs)
HTNumber=$((logicalNumber / (physicalNumber * coreNumber)))
echo &amp;quot;****** CPU Information ******&amp;quot;
echo &amp;quot;Logical CPU Number  : ${logicalNumber}&amp;quot;
echo &amp;quot;Physical CPU Number : ${physicalNumber}&amp;quot;
echo &amp;quot;CPU Core Number     : ${coreNumber}&amp;quot;
echo &amp;quot;HT Number           : ${HTNumber}&amp;quot;
echo &amp;quot;*****************************&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用脚本清理一些文件&#34;&gt;使用脚本清理一些文件&lt;/h2&gt;

&lt;p&gt;删除当前目录超过30天未变动过的log文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; | xargs rm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; -exec rm -i {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的操作都包含子目录&lt;/p&gt;

&lt;p&gt;-exec  参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&lt;/p&gt;

&lt;p&gt;{}   花括号代表前面find查找出来的文件名。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -type f -exec ls -l {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -name &amp;quot;*.log&amp;quot; -mtime +60 -ok rm {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-mtime +30 设定时间为30天前&lt;/p&gt;

&lt;p&gt;-type f 查找的类型为文件&lt;/p&gt;

&lt;p&gt;-name 文件路径需要匹配的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用全文查找&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;grep -lr &amp;lsquo;string&amp;rsquo; /etc/&lt;/p&gt;

&lt;p&gt;这个命令就可以搞定。搜索etc下面的文件，包含所有目录下的文件。这样就搞定了。&lt;/p&gt;

&lt;p&gt;-i，乎略大小写
-l，找出含有这个字符串的文件
-r，不放过子目录&lt;/p&gt;

&lt;h2 id=&#34;解决can-t-set-the-locale-make-sure-lc-and-lang-are-correct&#34;&gt;解决can&amp;rsquo;t set the locale; make sure $LC_* and $LANG are correct&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&#34;&gt;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&lt;/a&gt;
&lt;code&gt;照着全部做下来&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;sed使用&#34;&gt;sed使用&lt;/h2&gt;

&lt;p&gt;更新版本号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sed -i &amp;quot;s/?ver=\w\+/?ver=`date +%s`/g&amp;quot; *.html
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;o=http://cdn.ourwill.cn/fed-static r=http://cdn.ourwill.cn/fed-static/fedv2 sed -i &amp;quot;s#$o#$r#g&amp;quot; *.html
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;vim乱码解决&#34;&gt;Vim乱码解决&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vim ~/.vimrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;开机启动的&#34;&gt;开机启动的&lt;/h2&gt;

&lt;p&gt;检视和控制systemd的主要命令是systemctl&lt;/p&gt;

&lt;p&gt;详细使用见&lt;a href=&#34;https://wiki.archlinux.org/index.php/systemd_(简体中文)&#34;&gt;https://wiki.archlinux.org/index.php/systemd_(简体中文)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CentOS7 用&lt;code&gt;systemctl&lt;/code&gt;取代了&lt;code&gt;service&lt;/code&gt;
旧版本的 &lt;code&gt;service docker start&lt;/code&gt; 改为&lt;code&gt;systemctl start docker&lt;/code&gt;
设置开机启动
旧版本的 &lt;code&gt;chkconfig docker on&lt;/code&gt; 改为 &lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/systemd/system/&lt;/code&gt;
&lt;code&gt;/etc/systemd/system/&lt;/code&gt;
后者有较高优先级会覆盖前者&lt;/p&gt;

&lt;p&gt;/etc/profile 和 ~/.bash_profile 是在启动 一个交互登陆shell的时候 被调用。
/etc/bashrc 和 ~/.bashrc 是在一个交互的非登陆shell启动 的时候 被调用。
~/.bash_logout 在用户注销登陆的时候 被读取&lt;/p&gt;

&lt;p&gt;系统脚本 可以放置在/etc/rc.d/init.d中并建立/etc/rc.d/rc?.d链接，也可以直接放置在/etc/rc.d/rc.local中。
init.d脚本 包含完整的start,stop,status,reload等参数，是标准做法，推荐使用。&lt;/p&gt;

&lt;h2 id=&#34;linux-家族&#34;&gt;Linux 家族&lt;/h2&gt;

&lt;p&gt;一般来说著名的linux系统基本上分两大类：&lt;/p&gt;

&lt;p&gt;1.RedHat系列：Redhat、Centos、Fedora等&lt;/p&gt;

&lt;p&gt;2.Debian系列：Debian、Ubuntu等&lt;/p&gt;

&lt;p&gt;RedHat 系列&lt;/p&gt;

&lt;p&gt;1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 yum&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;Debian系列
1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 apt-get&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;soft rlimits too low. Number of files is 256, should be at least 1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;https://www.fdzh.org/slides/2015/06/20/linux-distr/&#34;&gt;https://www.fdzh.org/slides/2015/06/20/linux-distr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://static.suconghou.cn/document/linux.jpg&#34; alt=&#34;家族示意图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;判断一个命令是否存在&#34;&gt;判断一个命令是否存在&lt;/h2&gt;

&lt;p&gt;如判断&lt;code&gt;nc&lt;/code&gt;是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command -v nc &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || { echo &amp;gt;&amp;amp;2 &amp;quot;I require nc but it&#39;s not installed.  Aborting.&amp;quot;; exit 1; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if ! command -v pip &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then
    echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;PIP=$(which pip)
if [ ! -x &amp;quot;${PIP}&amp;quot; ];then
	echo &amp;quot;NO&amp;quot;
else
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[[ ! -x $(which pip) ]] &amp;amp;&amp;amp; echo &amp;quot;No&amp;quot; || echo &amp;quot;Yes&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if (( ${+commands[pip]} )); then
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;判断一个进程pid是否还存在&#34;&gt;判断一个进程PID是否还存在&lt;/h2&gt;

&lt;p&gt;例如检查pid为143的进程 &lt;code&gt;ps ax | awk &#39;{ print $1 }&#39; | grep -e &amp;quot;^143$&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;时间同步&#34;&gt;时间同步&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.pool.ntp.org/zh/&#34;&gt;http://www.pool.ntp.org/zh/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.ntp.org.cn/&#34;&gt;http://www.ntp.org.cn/&lt;/a&gt; 提供 ntp server&lt;/p&gt;

&lt;p&gt;使用 &lt;code&gt;sudo ntpdate us.ntp.org.cn&lt;/code&gt; 来同步时间.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;time.pool.aliyun.com&lt;/code&gt;  &lt;code&gt;time.asia.apple.com&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;/usr/bin/tzselect 来设置时区&lt;/p&gt;

&lt;p&gt;Alpine Linux 3.4  &lt;code&gt;ntpd -d -n -q -p us.ntp.org.cn&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以&lt;code&gt;sudo date -s &amp;quot;2017-02-08 21:28:00&amp;quot;&lt;/code&gt;手动设置时间&lt;/p&gt;

&lt;p&gt;alpine中设置时区执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk update &amp;amp;&amp;amp; apk upgrade &amp;amp;&amp;amp; apk add --no-cache tzdata
ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime
echo &amp;quot;Asia/Shanghai&amp;quot; &amp;gt; /etc/timezone
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;会立即生效.&lt;/p&gt;

&lt;h2 id=&#34;linux-磁盘与mysql性能测试&#34;&gt;Linux 磁盘与MySQL性能测试&lt;/h2&gt;

&lt;p&gt;源码地址 : &lt;a href=&#34;https://github.com/akopytov/sysbench&#34;&gt;https://github.com/akopytov/sysbench&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;它主要包括以下几种方式的测试：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;cpu性能&lt;/li&gt;
&lt;li&gt;磁盘io性能&lt;/li&gt;
&lt;li&gt;调度程序性能&lt;/li&gt;
&lt;li&gt;内存分配及传输速度&lt;/li&gt;
&lt;li&gt;POSIX线程性能&lt;/li&gt;
&lt;li&gt;数据库性能(OLTP基准测试)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;目前sysbench主要支持 MySQL,pgsql,oracle 这3种数据库。&lt;/p&gt;

&lt;h2 id=&#34;mtr网络线路测试&#34;&gt;Mtr网络线路测试&lt;/h2&gt;

&lt;p&gt;如果未安装可以&lt;code&gt;yum info mtr&lt;/code&gt;安装&lt;/p&gt;

&lt;p&gt;-n  不用主机解释
-c   发送多少个数据包
&amp;ndash;report  结果显示，并不动态显示。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mtr --report www.baidu.com&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;shell基本语法&#34;&gt;Shell基本语法&lt;/h2&gt;

&lt;p&gt;声明数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arr=(item1 item2 item3)&lt;/code&gt; 使用空格分开&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;echo ${arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${arr[@]}&lt;/code&gt; 可以查看数组内的元素,&lt;code&gt;echo $arr&lt;/code&gt;只能取得第一个元素&lt;/p&gt;

&lt;p&gt;要取得数组长度,只需在名字前面加一个#,如&lt;code&gt;echo ${#arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${#arr[@]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;数组下标以0开始,取得第二个元素为&lt;code&gt;echo ${arr[1]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;赋值使用&lt;code&gt;arr[5]=5555&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;dns配置&#34;&gt;DNS配置&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;/etc/resolv.conf&lt;/code&gt;内配置&lt;/p&gt;

&lt;p&gt;国外可以配置&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;nameserver 8.8.8.8
nameserver 4.2.2.1
nameserver 8.8.4.4
nameserver 4.2.2.2
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;测试vps宽带&#34;&gt;测试VPS宽带&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/sivel/speedtest-cli&#34;&gt;https://github.com/sivel/speedtest-cli&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://man.linuxde.net/speedtest-cli&#34;&gt;http://man.linuxde.net/speedtest-cli&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;还可以使用wget下载各大型机房的测试文件&lt;/p&gt;

&lt;p&gt;芝加哥机房/100M测试包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://cachefly.cachefly.net/100mb.test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://cachefly.cachefly.net/10mb.test&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;directspace机房/10M.100M测试包&lt;/p&gt;

&lt;p&gt;Portland, Oregon Data Center&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://bandwidth.directspace.net/100MBtest.zip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://bandwidth.directspace.net/10MBtest.zip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Los Angeles, California Data Center&lt;/p&gt;

&lt;p&gt;&lt;code&gt;wget http://45.34.158.82/speedtest/100MBtest.zip&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;访问 cachefly.cachefly.net 可以测试你电脑当前的网络速度&lt;/p&gt;

&lt;p&gt;枫叶主机 &lt;a href=&#34;http://www.fyzhuji.com/speed.html&#34;&gt;http://www.fyzhuji.com/speed.html&lt;/a&gt; 提供的测速文件.&lt;/p&gt;

&lt;p&gt;香港SV新力讯机房,测试20M光纤能跑满2.6MB/s&lt;/p&gt;

&lt;p&gt;星光互联 &lt;a href=&#34;https://www.starrydns.com/tc/speedtest&#34;&gt;https://www.starrydns.com/tc/speedtest&lt;/a&gt; 提供的测速文件&lt;/p&gt;

&lt;p&gt;Mega-I, Hong Kong,测试能跑到3MB/s&lt;/p&gt;

&lt;h2 id=&#34;lvm&#34;&gt;LVM&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;pvcreate&lt;/code&gt;创建PV&lt;/p&gt;

&lt;p&gt;pvcreate 物理分区名字&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;vgcreate&lt;/code&gt;创建VG&lt;/p&gt;

&lt;p&gt;vgcreate vgname pv1 pv2 pv3&lt;/p&gt;

&lt;p&gt;pvdisplay 查看当前的PV&lt;/p&gt;

&lt;p&gt;vgdisplay 查看VG&lt;/p&gt;

&lt;p&gt;lvdisplay 查看LV&lt;/p&gt;

&lt;p&gt;&lt;code&gt;pvscan&lt;/code&gt; &lt;code&gt;vgscan&lt;/code&gt;  &lt;code&gt;lvscan&lt;/code&gt; &lt;code&gt;fdisk -l&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-L：指定LV的大小 -n：指定LV的名。Vo1Group00：表示从这个VG中划分LV；&lt;/p&gt;

&lt;p&gt;LV创建好后格式化为想要的格式,然后挂载指定目录,就能使用了.(可以使用&lt;code&gt;df -lhT&lt;/code&gt;查看了)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;lsblk&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[root@will ~]# lsblk
NAME            MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
sda               8:0    0 931.5G  0 disk
├─sda1            8:1    0   200M  0 part /boot/efi
├─sda2            8:2    0   500M  0 part /boot
└─sda3            8:3    0 930.8G  0 part
  ├─centos-root 253:0    0    50G  0 lvm  /
  ├─centos-swap 253:1    0   5.9G  0 lvm  [SWAP]
  └─centos-home 253:2    0 874.9G  0 lvm  /home
sr0              11:0    1  1024M  0 rom

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;##&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://home.tiscali.cz/~cz210552/webbench.html&#34;&gt;http://home.tiscali.cz/~cz210552/webbench.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.cppblog.com/merlinfang/archive/2014/12/26/209311.html&#34;&gt;http://www.cppblog.com/merlinfang/archive/2014/12/26/209311.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cloudwu.github.io/lua53doc/&#34;&gt;http://cloudwu.github.io/lua53doc/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
LUA_VERSION=lua-5.3.3
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.lua.org/ftp/${LUA_VERSION}.tar.gz
tar zxf ${LUA_VERSION}.tar.gz
cd ${LUA_VERSION}
make linux
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/#srlua&#34;&gt;http://webserver2.tecgraf.puc-rio.br/~lhf/ftp/lua/#srlua&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://luabinaries.sourceforge.net/download.html&#34;&gt;http://luabinaries.sourceforge.net/download.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://cloudwu.github.io/lua53doc/manual.html&#34;&gt;http://cloudwu.github.io/lua53doc/manual.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;socat是一個netcat(nc)的替代產品，可以稱得上nc++。
&lt;a href=&#34;http://www.dest-unreach.org/socat/&#34;&gt;http://www.dest-unreach.org/socat/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.dest-unreach.org/socat/download/&#34;&gt;http://www.dest-unreach.org/socat/download/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;iotop htop
mtr&lt;/p&gt;

&lt;p&gt;netpipes 和socat一样，主要是用来在命令行来进行socket操作的命令，这样你就可以在Shell脚本下行进socket网络通讯了。&lt;/p&gt;

&lt;p&gt;iftop和iptraf可以用来查看当前网络链接的一些流量情况。&lt;/p&gt;

&lt;p&gt;iostat, vmstat, ifstat 三合一的工具，用来查看系统性能。&lt;/p&gt;

&lt;p&gt;rtorrent aria2c
lftp
ack是一个perl脚本，是grep的一个可选替换品&lt;/p&gt;

&lt;h2 id=&#34;logs&#34;&gt;logs&lt;/h2&gt;

&lt;p&gt;系统log&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/log/boot.log&lt;/code&gt; 系统启动的log&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/log/yum.log&lt;/code&gt; yum执行的log&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/log/messages&lt;/code&gt; 系统实时log&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/log/cron&lt;/code&gt; crontab 的log&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/log/secure&lt;/code&gt; sshd 的log&lt;/p&gt;

&lt;p&gt;这些log的配置主要由&lt;code&gt;/etc/rsyslog.conf&lt;/code&gt;配置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;grep &amp;quot;Failed password for&amp;quot; /var/log/secure&lt;/code&gt; 查看最近登录失败的请求&lt;/p&gt;

&lt;p&gt;&lt;code&gt;grep &amp;quot;Failed password for&amp;quot; /var/log/secure | awk &#39;{print $11}&#39; | sort | uniq -c | sort -nr&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查看最近登录失败的统计&lt;/p&gt;

&lt;h3 id=&#34;查看进程的线程&#34;&gt;查看进程的线程&lt;/h3&gt;

&lt;p&gt;在ps命令中，“-T”选项可以开启线程查看。 &lt;code&gt;ps -T aux&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ps -T -p &lt;pid&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;top -H&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在top运行时，你也可以通过按“H”键将线程查看模式切换为开或关。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;top -H -p &amp;lt;pid&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;top -H -b -n1&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
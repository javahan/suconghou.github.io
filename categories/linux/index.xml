<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 苏苏的博客</title>
    <link>http://blog.suconghou.cn/categories/linux/</link>
    <description>Recent content in Linux on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Jan 2016 13:40:53 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/categories/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux相关操作</title>
      <link>http://blog.suconghou.cn/post/linux/</link>
      <pubDate>Thu, 21 Jan 2016 13:40:53 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux/</guid>
      <description>

&lt;h2 id=&#34;linux实用命令&#34;&gt;Linux实用命令&lt;/h2&gt;

&lt;h2 id=&#34;w&#34;&gt;w&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;w&lt;/code&gt;命令能容清晰的显示,服务器在线时间,负载以及当前登陆的用户&lt;/p&gt;

&lt;h2 id=&#34;vmstat&#34;&gt;vmstat&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 显示开机以来的平均值，而不是前一秒的值
&lt;code&gt;vmstat 1&lt;/code&gt;命令指定一个参数 1 运行，来打印每一秒的统计摘要.
这些列代表的信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;r：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：&amp;rdquo;r&amp;rdquo;的值大于了 CPU 的数量就表示已经饱和了。
free：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。&amp;rdquo;free -m&amp;rdquo; 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。
si, so：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。
us, sy, id, wa, st：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。
对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。&lt;/p&gt;

&lt;p&gt;SIZE(VIRT): 进程使用的地址空间, 如果进程映射了100M的内存, 进程的地址空间将报告为100M内存. 事实上, 这个大小不是一个程序实际使用的内存数.&lt;/p&gt;

&lt;p&gt;RSS(RES): &amp;ldquo;Resident Set Size&amp;rdquo;, 实际驻留&amp;rdquo;在内存中&amp;rdquo;的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.&lt;/p&gt;

&lt;p&gt;SHARE(SHR): RSS中与其它进程共享的内存部分大小.&lt;/p&gt;

&lt;p&gt;VMSIZE: 一个进程占用的总的地址空间大小. 它包括了没有映射到内存中的页面。&lt;/p&gt;

&lt;p&gt;SZ（DATA）: 映射到内存中的页面, 这些页面仅由进程单独使用. 这也是我们最关心地方: 进程实际占用的内存数。&lt;/p&gt;

&lt;h2 id=&#34;top&#34;&gt;top&lt;/h2&gt;

&lt;h2 id=&#34;free&#34;&gt;free&lt;/h2&gt;

&lt;h2 id=&#34;ssh&#34;&gt;ssh&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub root@host&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub -p 26671 root@host&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pgrep&#34;&gt;pgrep&lt;/h2&gt;

&lt;p&gt;根据名字或其他属性查询出进程的PID&lt;/p&gt;

&lt;p&gt;如:&lt;code&gt;pgrep nginx -fl&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pkill&#34;&gt;pkill&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;pgrep&lt;/code&gt;类似,不同的是向进程发送信号,默认发送&lt;code&gt;SIGTERM&lt;/code&gt;信号,查看都有哪些信号可用,可以使用&lt;code&gt;kill -l&lt;/code&gt;查看&lt;/p&gt;

&lt;p&gt;类似&lt;code&gt;pkill&lt;/code&gt;的命令是&lt;code&gt;killall&lt;/code&gt;,后面都是可以直接加进程名字批量杀死进程&lt;/p&gt;

&lt;h2 id=&#34;pstree&#34;&gt;pstree&lt;/h2&gt;

&lt;p&gt;用树的形式显示正在运行的进程,树的节点为指定的PID(忽略则为init进程)&lt;/p&gt;

&lt;h2 id=&#34;ss&#34;&gt;ss&lt;/h2&gt;

&lt;p&gt;用于显示socket的统计信息,&lt;code&gt;-s&lt;/code&gt;用于显示汇总&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt;用于列出正在监听的&lt;code&gt;socket&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;显示进程信息,&lt;code&gt;ss -pl&lt;/code&gt; 可以查看使用网络端口的进程名字&lt;/p&gt;

&lt;h2 id=&#34;磁盘相关&#34;&gt;磁盘相关&lt;/h2&gt;

&lt;h3 id=&#34;dd&#34;&gt;dd&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dd&lt;/code&gt;把指定的输入文件拷贝到指定的输出文件中,并且在拷贝的过程中可以进行格式转换。&lt;/p&gt;

&lt;p&gt;if =输入文件(或设备名称)
of =输出文件(或设备名称)
bs = bytes 同时设置读/写缓冲区的字节数(等于设置obs和obs)
count = blocks 只拷贝输入的blocks块&lt;/p&gt;

&lt;p&gt;创建一个100M的空文件
&lt;code&gt;dd if=/dev/zero of=hello.txt bs=100m count=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小&#34;&gt;查看当前目录下所有一级子目录文件夹大小&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小-并排序&#34;&gt;查看当前目录下所有一级子目录文件夹大小 并排序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1 |sort&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上两条命令不适用于MacOs,可以使用&lt;code&gt;du -sh *&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;ps&lt;/h2&gt;

&lt;p&gt;ps ef  查看进程的状态&lt;/p&gt;

&lt;p&gt;ps auxw 查看进程的CPU,内存占用&lt;/p&gt;

&lt;p&gt;ps 默认是按照PID排序的,若要按内存使用排序&lt;code&gt;ps auxw --sort=rss&lt;/code&gt;,同理按虚拟内存排序&lt;code&gt;ps auxw --sort=vsz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mac上无法使用&lt;code&gt;--sort&lt;/code&gt;,可以采用&lt;code&gt;sort&lt;/code&gt;排序,如rss在第六列,则&lt;code&gt;ps auxw | sort -k6,6n&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;一份linux别名和函数库&#34;&gt;一份Linux别名和函数库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;alias tree=&amp;quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39; &amp;quot;;
alias cls=&amp;quot;cd $1;ls -lh;&amp;quot;;
# 获得你的公网IP地址和主机名。
alias ipinfo=&amp;quot;curl ifconfig.me &amp;amp;&amp;amp; curl ifconfig.me/host&amp;quot;;
# 显示出哪个应用程序连接到网络。
alias listen=&amp;quot;lsof -P -i -n&amp;quot;;
# 显示出活动的端口。
alias port=&#39;netstat -uanltp&#39;
# 统计TCP连接个数
alias tcpstatus=&amp;quot;netstat -n|awk &#39;/^tcp/{++S[\$NF]} END {for(a in S) print a,S[a]}&#39;&amp;quot;
# 回到上层目录
alias ..=&#39;cd ..&#39;
# 去到上两层目录
alias ...=&#39;cd ../..&#39;
# 按列格式化输出mount信息。
alias cmount=&amp;quot;mount | column -t&amp;quot;
# 查看你还有剩下多少内存
alias meminfo=&#39;free -m -l -t&#39;
# 按照文件在磁盘存储的大小排序，显示当前目录的文件列表。
sbs() { du -b --max-depth 1 | sort -nr | perl -pe &#39;s{([0-9]+)}{sprintf &amp;quot;%.1f%s&amp;quot;, $1&amp;gt;=2**30? ($1/2**30, &amp;quot;G&amp;quot;): $1&amp;gt;=2**20? ($1/2**20, &amp;quot;M&amp;quot;): $1&amp;gt;=2**10? ($1/2**10, &amp;quot;K&amp;quot;): ($1, &amp;quot;&amp;quot;)}e&#39;;}
# 找出指定目录中最大的10个文件
largefile() { find . -type f -exec du -k {} \; | sort  -nrk 1 | head; }
# 查看当前目录大于[多少]kb的文件,速度更快
bigthan() { size=${1:-100}; find . -type f -size +&amp;quot;$size&amp;quot;k |xargs  ls  -lh ; }
# 返回你的当前IP地址的地理位置。
getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep &#39;city|state|country&#39;|awk &#39;{print $3,$4,$5,$6,$7,$8}&#39;|sed &#39;s\ip address flag \\&#39;|sed &#39;s\My\\&#39;;}
# 删除.log.1.gz 或者 .log.1.bz2
delog(){ ls | grep &amp;quot;log.\d\+.\(bz2\|gz\)&amp;quot; | xargs rm}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 这几个Mac不兼容
# 查看最占用内存的前五个进程
topmem()
{
	ps aux | sort -k4nr | head -n5;
}
# 查看某一程序占用的内存
mem()
{
    top -n1 -b | head -n7 | sed &#39;1,6d&#39; &amp;amp;&amp;amp; top -n1 -b | sed &#39;1,7d&#39; | grep --color=auto $1;
    ps aux | grep --color=auto $1 | grep --color=auto -v grep | awk -F &amp;quot; &amp;quot; &#39;{ sum += $6 } END { printf &amp;quot;Total Memory Usage: %.1f MB\n&amp;quot;, sum/1024 }&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 查看你机器的CPU个数,超线程信息
sysinfo() {
physicalNumber=0
coreNumber=0
logicalNumber=0
HTNumber=0
logicalNumber=$(grep &amp;quot;processor&amp;quot; /proc/cpuinfo|sort -u|wc -l)
physicalNumber=$(grep &amp;quot;physical id&amp;quot; /proc/cpuinfo|sort -u|wc -l)
coreNumber=$(grep &amp;quot;cpu cores&amp;quot; /proc/cpuinfo|uniq|awk -F&#39;:&#39; &#39;{print $2}&#39;|xargs)
HTNumber=$((logicalNumber / (physicalNumber * coreNumber)))
echo &amp;quot;****** CPU Information ******&amp;quot;
echo &amp;quot;Logical CPU Number  : ${logicalNumber}&amp;quot;
echo &amp;quot;Physical CPU Number : ${physicalNumber}&amp;quot;
echo &amp;quot;CPU Core Number     : ${coreNumber}&amp;quot;
echo &amp;quot;HT Number           : ${HTNumber}&amp;quot;
echo &amp;quot;*****************************&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用脚本清理一些文件&#34;&gt;使用脚本清理一些文件&lt;/h2&gt;

&lt;p&gt;删除当前目录超过30天未变动过的log文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; | xargs rm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; -exec rm -i {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的操作都包含子目录&lt;/p&gt;

&lt;p&gt;-exec  参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&lt;/p&gt;

&lt;p&gt;{}   花括号代表前面find查找出来的文件名。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -type f -exec ls -l {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -name &amp;quot;*.log&amp;quot; -mtime +60 -ok rm {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-mtime +30 设定时间为30天前&lt;/p&gt;

&lt;p&gt;-type f 查找的类型为文件&lt;/p&gt;

&lt;p&gt;-name 文件路径需要匹配的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用全文查找&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;grep -lr &amp;lsquo;string&amp;rsquo; /etc/&lt;/p&gt;

&lt;p&gt;这个命令就可以搞定。搜索etc下面的文件，包含所有目录下的文件。这样就搞定了。&lt;/p&gt;

&lt;p&gt;-i，乎略大小写
-l，找出含有这个字符串的文件
-r，不放过子目录&lt;/p&gt;

&lt;h2 id=&#34;解决can-t-set-the-locale-make-sure-lc-and-lang-are-correct&#34;&gt;解决can&amp;rsquo;t set the locale; make sure $LC_* and $LANG are correct&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&#34;&gt;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&lt;/a&gt;
&lt;code&gt;照着全部做下来&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;vim乱码解决&#34;&gt;Vim乱码解决&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vim ~/.vimrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;开机启动的&#34;&gt;开机启动的&lt;/h2&gt;

&lt;p&gt;检视和控制systemd的主要命令是systemctl&lt;/p&gt;

&lt;p&gt;详细使用见&lt;a href=&#34;https://wiki.archlinux.org/index.php/systemd_(简体中文)&#34;&gt;https://wiki.archlinux.org/index.php/systemd_(简体中文)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CentOS7 用&lt;code&gt;systemctl&lt;/code&gt;取代了&lt;code&gt;service&lt;/code&gt;
旧版本的 &lt;code&gt;service docker start&lt;/code&gt; 改为&lt;code&gt;systemctl start docker&lt;/code&gt;
设置开机启动
旧版本的 &lt;code&gt;chkconfig docker on&lt;/code&gt; 改为 &lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/systemd/system/&lt;/code&gt;
&lt;code&gt;/etc/systemd/system/&lt;/code&gt;
后者有较高优先级会覆盖前者&lt;/p&gt;

&lt;p&gt;/etc/profile 和 ~/.bash_profile 是在启动 一个交互登陆shell的时候 被调用。
/etc/bashrc 和 ~/.bashrc 是在一个交互的非登陆shell启动 的时候 被调用。
~/.bash_logout 在用户注销登陆的时候 被读取&lt;/p&gt;

&lt;p&gt;系统脚本 可以放置在/etc/rc.d/init.d中并建立/etc/rc.d/rc?.d链接，也可以直接放置在/etc/rc.d/rc.local中。
init.d脚本 包含完整的start,stop,status,reload等参数，是标准做法，推荐使用。&lt;/p&gt;

&lt;h2 id=&#34;linux-家族&#34;&gt;Linux 家族&lt;/h2&gt;

&lt;p&gt;一般来说著名的linux系统基本上分两大类：&lt;/p&gt;

&lt;p&gt;1.RedHat系列：Redhat、Centos、Fedora等&lt;/p&gt;

&lt;p&gt;2.Debian系列：Debian、Ubuntu等
RedHat 系列
1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 yum&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;Debian系列
1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 apt-get&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;soft rlimits too low. Number of files is 256, should be at least 1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;https://www.fdzh.org/slides/2015/06/20/linux-distr/&#34;&gt;https://www.fdzh.org/slides/2015/06/20/linux-distr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dn-copr.qbox.me/49d503bf47879ffe8a169dd81c744d83_b.jpg&#34; alt=&#34;家族示意图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;判断一个命令是否存在&#34;&gt;判断一个命令是否存在&lt;/h2&gt;

&lt;p&gt;如判断&lt;code&gt;nc&lt;/code&gt;是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command -v nc &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || { echo &amp;gt;&amp;amp;2 &amp;quot;I require nc but it&#39;s not installed.  Aborting.&amp;quot;; exit 1; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if ! command -v pip &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then
    echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;PIP=$(which pip)
if [ ! -x &amp;quot;${PIP}&amp;quot; ];then
	echo &amp;quot;NO&amp;quot;
else
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[[ ! -x $(which pip) ]] &amp;amp;&amp;amp; echo &amp;quot;No&amp;quot; || echo &amp;quot;Yes&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if (( ${+commands[pip]} )); then
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;shell基本语法&#34;&gt;Shell基本语法&lt;/h2&gt;

&lt;p&gt;声明数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arr=(item1 item2 item3)&lt;/code&gt; 使用空格分开&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;echo ${arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${arr[@]}&lt;/code&gt; 可以查看数组内的元素,&lt;code&gt;echo $arr&lt;/code&gt;只能取得第一个元素&lt;/p&gt;

&lt;p&gt;要取得数组长度,只需在名字前面加一个#,如&lt;code&gt;echo ${#arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${#arr[@]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;数组下标以0开始,取得第二个元素为&lt;code&gt;echo ${arr[1]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;赋值使用&lt;code&gt;arr[5]=5555&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
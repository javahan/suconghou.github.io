<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Linux on 苏苏的博客</title>
    <link>http://blog.suconghou.cn/tags/linux/</link>
    <description>Recent content in Linux on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 21 Jan 2016 13:40:53 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/tags/linux/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>linux相关操作</title>
      <link>http://blog.suconghou.cn/post/linux/</link>
      <pubDate>Thu, 21 Jan 2016 13:40:53 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux/</guid>
      <description>

&lt;h2 id=&#34;linux用户管理&#34;&gt;Linux用户管理&lt;/h2&gt;

&lt;h3 id=&#34;添加用户adduser&#34;&gt;添加用户adduser&lt;/h3&gt;

&lt;p&gt;假如用户名为&lt;code&gt;work&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;adduser work -M&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;修改密码&#34;&gt;修改密码&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;passwd work&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;linux实用命令&#34;&gt;Linux实用命令&lt;/h2&gt;

&lt;h2 id=&#34;w&#34;&gt;w&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;w&lt;/code&gt;命令能容清晰的显示,服务器在线时间,负载以及当前登陆的用户&lt;/p&gt;

&lt;h2 id=&#34;vmstat&#34;&gt;vmstat&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 显示开机以来的平均值，而不是前一秒的值
&lt;code&gt;vmstat 1&lt;/code&gt;命令指定一个参数 1 运行，来打印每一秒的统计摘要.
这些列代表的信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;r：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：&amp;rdquo;r&amp;rdquo;的值大于了 CPU 的数量就表示已经饱和了。
free：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。&amp;rdquo;free -m&amp;rdquo; 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。
si, so：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。
us, sy, id, wa, st：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。
对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。&lt;/p&gt;

&lt;p&gt;SIZE(VIRT): 进程使用的地址空间, 如果进程映射了100M的内存, 进程的地址空间将报告为100M内存. 事实上, 这个大小不是一个程序实际使用的内存数.&lt;/p&gt;

&lt;p&gt;RSS(RES): &amp;ldquo;Resident Set Size&amp;rdquo;, 实际驻留&amp;rdquo;在内存中&amp;rdquo;的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.&lt;/p&gt;

&lt;p&gt;SHARE(SHR): RSS中与其它进程共享的内存部分大小.&lt;/p&gt;

&lt;p&gt;VMSIZE: 一个进程占用的总的地址空间大小. 它包括了没有映射到内存中的页面。&lt;/p&gt;

&lt;p&gt;SZ（DATA）: 映射到内存中的页面, 这些页面仅由进程单独使用. 这也是我们最关心地方: 进程实际占用的内存数。&lt;/p&gt;

&lt;h2 id=&#34;top&#34;&gt;top&lt;/h2&gt;

&lt;h2 id=&#34;free&#34;&gt;free&lt;/h2&gt;

&lt;h2 id=&#34;ssh&#34;&gt;ssh&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub root@host&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub -p 26671 root@host&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pgrep&#34;&gt;pgrep&lt;/h2&gt;

&lt;p&gt;根据名字或其他属性查询出进程的PID&lt;/p&gt;

&lt;p&gt;如:&lt;code&gt;pgrep nginx -fl&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pkill&#34;&gt;pkill&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;pgrep&lt;/code&gt;类似,不同的是向进程发送信号,默认发送&lt;code&gt;SIGTERM&lt;/code&gt;信号,查看都有哪些信号可用,可以使用&lt;code&gt;kill -l&lt;/code&gt;查看&lt;/p&gt;

&lt;p&gt;类似&lt;code&gt;pkill&lt;/code&gt;的命令是&lt;code&gt;killall&lt;/code&gt;,后面都是可以直接加进程名字批量杀死进程&lt;/p&gt;

&lt;h2 id=&#34;pstree&#34;&gt;pstree&lt;/h2&gt;

&lt;p&gt;用树的形式显示正在运行的进程,树的节点为指定的PID(忽略则为init进程)&lt;/p&gt;

&lt;h2 id=&#34;ss&#34;&gt;ss&lt;/h2&gt;

&lt;p&gt;用于显示socket的统计信息,&lt;code&gt;-s&lt;/code&gt;用于显示汇总&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt;用于列出正在监听的&lt;code&gt;socket&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;显示进程信息,&lt;code&gt;ss -pl&lt;/code&gt; 可以查看使用网络端口的进程名字&lt;/p&gt;

&lt;h2 id=&#34;磁盘相关&#34;&gt;磁盘相关&lt;/h2&gt;

&lt;h3 id=&#34;dd&#34;&gt;dd&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dd&lt;/code&gt;把指定的输入文件拷贝到指定的输出文件中,并且在拷贝的过程中可以进行格式转换。&lt;/p&gt;

&lt;p&gt;if =输入文件(或设备名称)
of =输出文件(或设备名称)
bs = bytes 同时设置读/写缓冲区的字节数(等于设置obs和obs)
count = blocks 只拷贝输入的blocks块&lt;/p&gt;

&lt;p&gt;创建一个100M的空文件
&lt;code&gt;dd if=/dev/zero of=hello.txt bs=100m count=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小&#34;&gt;查看当前目录下所有一级子目录文件夹大小&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小-并排序&#34;&gt;查看当前目录下所有一级子目录文件夹大小 并排序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1 |sort&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上两条命令不适用于MacOs,可以使用&lt;code&gt;du -sh *&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;ps&lt;/h2&gt;

&lt;p&gt;ps ef  查看进程的状态&lt;/p&gt;

&lt;p&gt;ps auxw 查看进程的CPU,内存占用&lt;/p&gt;

&lt;p&gt;ps 默认是按照PID排序的,若要按内存使用排序&lt;code&gt;ps auxw --sort=rss&lt;/code&gt;,同理按虚拟内存排序&lt;code&gt;ps auxw --sort=vsz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mac上无法使用&lt;code&gt;--sort&lt;/code&gt;,可以采用&lt;code&gt;sort&lt;/code&gt;排序,如rss在第六列,则&lt;code&gt;ps auxw | sort -k6,6n&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;nc&#34;&gt;nc&lt;/h2&gt;

&lt;p&gt;nc 命令默认没有安装,需要自己安装,&lt;code&gt;yum install nc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传送字符与文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc -l 9090&lt;/code&gt;监听端口9090&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc host 9090&lt;/code&gt;连接host的9090端口,通信建立后,可以双向通信,实现文字聊天等,也可以传送文件&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc -l 9090 &amp;gt; file&lt;/code&gt; ,另一端发送文件&lt;code&gt;nc host 9090 &amp;lt; file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;传送文件夹(压缩文件) &lt;code&gt;nc -l 9090 |tar xzvf -&lt;/code&gt; , 另一端发送文件&lt;code&gt;tar czvf – dir | nc host 9090&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同样可以拷贝硬盘 &lt;code&gt;nc -l 9090 | dd of=/dev/sda&lt;/code&gt;,另一端发送&lt;code&gt;dd if=/dev/sda | nc host 9090&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端口扫描&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nc -vz -w 1 someIp 1-1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模拟调试http请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GET / HTTP/1.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端口转发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用之前需要了解其他的命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令将标准输入的数据写入标准输出和tee命令指定的文件参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkfifo&lt;/code&gt;命令用于创建一个FIFO（先进先出）方式的命名管道&lt;/p&gt;

&lt;p&gt;标准流:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stdin	0
stdout	1
stderr	2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** listener-to-client模式(用于外网访问内网) **&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;http://onestraw.net/cybersecurity/netcat-advanced-usage/&#34;&gt;http://onestraw.net/cybersecurity/netcat-advanced-usage/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一份linux别名和函数库&#34;&gt;一份Linux别名和函数库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;alias tree=&amp;quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39; &amp;quot;;
alias cls=&amp;quot;cd $1;ls -lh;&amp;quot;;
# 获得你的公网IP地址和主机名。
alias ipinfo=&amp;quot;curl ifconfig.me &amp;amp;&amp;amp; curl ifconfig.me/host&amp;quot;;
# 显示出哪个应用程序连接到网络。
alias listen=&amp;quot;lsof -P -i -n&amp;quot;;
# 显示出活动的端口。
alias port=&#39;netstat -uanltp&#39;
# 统计TCP连接个数
alias tcpstatus=&amp;quot;netstat -n|awk &#39;/^tcp/{++S[\$NF]} END {for(a in S) print a,S[a]}&#39;&amp;quot;
# 回到上层目录
alias ..=&#39;cd ..&#39;
# 去到上两层目录
alias ...=&#39;cd ../..&#39;
# 按列格式化输出mount信息。
alias cmount=&amp;quot;mount | column -t&amp;quot;
# 查看你还有剩下多少内存
alias meminfo=&#39;free -m -l -t&#39;
# 按照文件在磁盘存储的大小排序，显示当前目录的文件列表。
sbs() { du -b --max-depth 1 | sort -nr | perl -pe &#39;s{([0-9]+)}{sprintf &amp;quot;%.1f%s&amp;quot;, $1&amp;gt;=2**30? ($1/2**30, &amp;quot;G&amp;quot;): $1&amp;gt;=2**20? ($1/2**20, &amp;quot;M&amp;quot;): $1&amp;gt;=2**10? ($1/2**10, &amp;quot;K&amp;quot;): ($1, &amp;quot;&amp;quot;)}e&#39;;}
# 找出指定目录中最大的10个文件
largefile() { find . -type f -exec du -k {} \; | sort  -nrk 1 | head; }
# 查看当前目录大于[多少]kb的文件,速度更快
bigthan() { size=${1:-100}; find . -type f -size +&amp;quot;$size&amp;quot;k |xargs  ls  -lh ; }
# 返回你的当前IP地址的地理位置。
getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep &#39;city|state|country&#39;|awk &#39;{print $3,$4,$5,$6,$7,$8}&#39;|sed &#39;s\ip address flag \\&#39;|sed &#39;s\My\\&#39;;}
# 删除.log.1.gz 或者 .log.1.bz2
delog(){ ls | grep &amp;quot;log.\d\+.\(bz2\|gz\)&amp;quot; | xargs rm}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 这几个Mac不兼容
# 查看最占用内存的前五个进程(根据第几列可修改k6)
topmem()
{
	ps aux | sort -k6nr | head -n5;
}
# 查看某一程序占用的内存
mem()
{
    top -n1 -b | head -n7 | sed &#39;1,6d&#39; &amp;amp;&amp;amp; top -n1 -b | sed &#39;1,7d&#39; | grep --color=auto $1;
    ps aux | grep --color=auto $1 | grep --color=auto -v grep | awk -F &amp;quot; &amp;quot; &#39;{ sum += $6 } END { printf &amp;quot;Total Memory Usage: %.1f MB\n&amp;quot;, sum/1024 }&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;部分快捷键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
CTRL + U -剪切光标前的内容

CTRL + K -剪切光标至行末的内容

CTRL + Y -粘贴

CTRL + E -移动光标到行末

CTRL + A -移动光标到行首

ALT + F -跳向下一个空格

ALT + B -跳回上一个空格

ALT + Backspace -删除前一个单词

CTRL + W -剪切光标后一个单词

Shift + Insert -向终端内粘贴文本

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;压缩率 xz &amp;gt; bzip2 &amp;gt; gzip &amp;gt; zip&lt;/p&gt;

&lt;p&gt;gzexe 创建自解压文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 查看你机器的CPU个数,超线程信息
sysinfo() {
physicalNumber=0
coreNumber=0
logicalNumber=0
HTNumber=0
logicalNumber=$(grep &amp;quot;processor&amp;quot; /proc/cpuinfo|sort -u|wc -l)
physicalNumber=$(grep &amp;quot;physical id&amp;quot; /proc/cpuinfo|sort -u|wc -l)
coreNumber=$(grep &amp;quot;cpu cores&amp;quot; /proc/cpuinfo|uniq|awk -F&#39;:&#39; &#39;{print $2}&#39;|xargs)
HTNumber=$((logicalNumber / (physicalNumber * coreNumber)))
echo &amp;quot;****** CPU Information ******&amp;quot;
echo &amp;quot;Logical CPU Number  : ${logicalNumber}&amp;quot;
echo &amp;quot;Physical CPU Number : ${physicalNumber}&amp;quot;
echo &amp;quot;CPU Core Number     : ${coreNumber}&amp;quot;
echo &amp;quot;HT Number           : ${HTNumber}&amp;quot;
echo &amp;quot;*****************************&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用脚本清理一些文件&#34;&gt;使用脚本清理一些文件&lt;/h2&gt;

&lt;p&gt;删除当前目录超过30天未变动过的log文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; | xargs rm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; -exec rm -i {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的操作都包含子目录&lt;/p&gt;

&lt;p&gt;-exec  参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&lt;/p&gt;

&lt;p&gt;{}   花括号代表前面find查找出来的文件名。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -type f -exec ls -l {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -name &amp;quot;*.log&amp;quot; -mtime +60 -ok rm {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-mtime +30 设定时间为30天前&lt;/p&gt;

&lt;p&gt;-type f 查找的类型为文件&lt;/p&gt;

&lt;p&gt;-name 文件路径需要匹配的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用全文查找&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;grep -lr &amp;lsquo;string&amp;rsquo; /etc/&lt;/p&gt;

&lt;p&gt;这个命令就可以搞定。搜索etc下面的文件，包含所有目录下的文件。这样就搞定了。&lt;/p&gt;

&lt;p&gt;-i，乎略大小写
-l，找出含有这个字符串的文件
-r，不放过子目录&lt;/p&gt;

&lt;h2 id=&#34;解决can-t-set-the-locale-make-sure-lc-and-lang-are-correct&#34;&gt;解决can&amp;rsquo;t set the locale; make sure $LC_* and $LANG are correct&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&#34;&gt;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&lt;/a&gt;
&lt;code&gt;照着全部做下来&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;vim乱码解决&#34;&gt;Vim乱码解决&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vim ~/.vimrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;开机启动的&#34;&gt;开机启动的&lt;/h2&gt;

&lt;p&gt;检视和控制systemd的主要命令是systemctl&lt;/p&gt;

&lt;p&gt;详细使用见&lt;a href=&#34;https://wiki.archlinux.org/index.php/systemd_(简体中文)&#34;&gt;https://wiki.archlinux.org/index.php/systemd_(简体中文)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CentOS7 用&lt;code&gt;systemctl&lt;/code&gt;取代了&lt;code&gt;service&lt;/code&gt;
旧版本的 &lt;code&gt;service docker start&lt;/code&gt; 改为&lt;code&gt;systemctl start docker&lt;/code&gt;
设置开机启动
旧版本的 &lt;code&gt;chkconfig docker on&lt;/code&gt; 改为 &lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/systemd/system/&lt;/code&gt;
&lt;code&gt;/etc/systemd/system/&lt;/code&gt;
后者有较高优先级会覆盖前者&lt;/p&gt;

&lt;p&gt;/etc/profile 和 ~/.bash_profile 是在启动 一个交互登陆shell的时候 被调用。
/etc/bashrc 和 ~/.bashrc 是在一个交互的非登陆shell启动 的时候 被调用。
~/.bash_logout 在用户注销登陆的时候 被读取&lt;/p&gt;

&lt;p&gt;系统脚本 可以放置在/etc/rc.d/init.d中并建立/etc/rc.d/rc?.d链接，也可以直接放置在/etc/rc.d/rc.local中。
init.d脚本 包含完整的start,stop,status,reload等参数，是标准做法，推荐使用。&lt;/p&gt;

&lt;h2 id=&#34;linux-家族&#34;&gt;Linux 家族&lt;/h2&gt;

&lt;p&gt;一般来说著名的linux系统基本上分两大类：&lt;/p&gt;

&lt;p&gt;1.RedHat系列：Redhat、Centos、Fedora等&lt;/p&gt;

&lt;p&gt;2.Debian系列：Debian、Ubuntu等
RedHat 系列
1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 yum&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;Debian系列
1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 apt-get&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;soft rlimits too low. Number of files is 256, should be at least 1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;https://www.fdzh.org/slides/2015/06/20/linux-distr/&#34;&gt;https://www.fdzh.org/slides/2015/06/20/linux-distr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dn-copr.qbox.me/49d503bf47879ffe8a169dd81c744d83_b.jpg&#34; alt=&#34;家族示意图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;判断一个命令是否存在&#34;&gt;判断一个命令是否存在&lt;/h2&gt;

&lt;p&gt;如判断&lt;code&gt;nc&lt;/code&gt;是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command -v nc &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || { echo &amp;gt;&amp;amp;2 &amp;quot;I require nc but it&#39;s not installed.  Aborting.&amp;quot;; exit 1; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if ! command -v pip &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then
    echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;PIP=$(which pip)
if [ ! -x &amp;quot;${PIP}&amp;quot; ];then
	echo &amp;quot;NO&amp;quot;
else
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[[ ! -x $(which pip) ]] &amp;amp;&amp;amp; echo &amp;quot;No&amp;quot; || echo &amp;quot;Yes&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if (( ${+commands[pip]} )); then
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;判断一个进程pid是否还存在&#34;&gt;判断一个进程PID是否还存在&lt;/h2&gt;

&lt;p&gt;例如检查pid为143的进程 &lt;code&gt;ps ax | awk &#39;{ print $1 }&#39; | grep -e &amp;quot;^143$&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;shell基本语法&#34;&gt;Shell基本语法&lt;/h2&gt;

&lt;p&gt;声明数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arr=(item1 item2 item3)&lt;/code&gt; 使用空格分开&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;echo ${arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${arr[@]}&lt;/code&gt; 可以查看数组内的元素,&lt;code&gt;echo $arr&lt;/code&gt;只能取得第一个元素&lt;/p&gt;

&lt;p&gt;要取得数组长度,只需在名字前面加一个#,如&lt;code&gt;echo ${#arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${#arr[@]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;数组下标以0开始,取得第二个元素为&lt;code&gt;echo ${arr[1]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;赋值使用&lt;code&gt;arr[5]=5555&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>SSH</title>
      <link>http://blog.suconghou.cn/post/linux-ssh/</link>
      <pubDate>Thu, 07 Jan 2016 13:47:22 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux-ssh/</guid>
      <description>

&lt;h2 id=&#34;避免ssh自动断开连接&#34;&gt;避免SSH自动断开连接&lt;/h2&gt;

&lt;p&gt;如果有一段时间在SSH连接上无数据传输，连接就会断开,以下设定可以解决这个问题&lt;/p&gt;

&lt;p&gt;方案一：在客户端设置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo vim /etc/ssh/ssh_config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;开启 &lt;code&gt;ServerAliveInterval 60&lt;/code&gt;
开启 &lt;code&gt;TCPKeepAlive yes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此后该系统里的用户连接SSH时，每60秒会发一个KeepAlive请求，避免被踢。&lt;/p&gt;

&lt;p&gt;方案二：在服务器端设置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo vim /etc/ssh/sshd_config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;开启&lt;code&gt;ClientAliveInterval 60&lt;/code&gt;
开启 &lt;code&gt;TCPKeepAlive yes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果您只想让当前的 ssh 保持连接，可以使用以下的命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh -o ServerAliveInterval=60 user@sshserver&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ssh隧道&#34;&gt;ssh隧道&lt;/h2&gt;

&lt;h3 id=&#34;cfng&#34;&gt;-CfNg&lt;/h3&gt;

&lt;p&gt;C表示压缩数据传输
f表示后台用户验证,这个选项很有用,没有shell的不可登陆账号也能使用.
N表示不执行脚本或命令
g表示允许远程主机连接转发端口&lt;/p&gt;

&lt;h3 id=&#34;l-本地转发&#34;&gt;-L 本地转发&lt;/h3&gt;

&lt;p&gt;-L [本地监听IP:]本地监听端口号:目标主机IP:目标端口号
(其中,“本地监听IP”可以省略，省略的话就认为是“0.0.0.0”，但为了安全性考虑，请务必使用“127.0.0.1”做为本地监听端口， 而不要使用默认的“0.0.0.0”。）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh -D 8080 user@host&lt;/code&gt;
SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh -L 2121:host2:21 host3&lt;/code&gt;
命令中的L参数一共接受三个值，分别是&amp;rdquo;本地端口:目标主机:目标主机端口&amp;rdquo;，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。
这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -CfNg -L 6300:127.0.0.1:1521 oracle@172.16.1.164
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本机的6300端口就是远程主机172.16.1.164的1521端口&lt;/p&gt;

&lt;h3 id=&#34;r-远程转发&#34;&gt;-R 远程转发&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; ssh -CfNg -R 1521:127.0.0.1:6300 oracle@172.16.1.164
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在远程主机172.16.1.164上打开1521端口, 来映射本机的6300端口.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在树莓派上映射ssh到外网&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -CfNg -R 2222:127.0.0.1:22 username@yourvps.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就映射vps的2222端口到树莓派上了.但是这样映射的是服务器的127.0.0.1:2222,外网无法连接这个2222端口&lt;/p&gt;

&lt;p&gt;如果你自己的服务器连接时需要端口可以在最后加上 &lt;code&gt;-p port&lt;/code&gt; 指定ssh的端口&lt;/p&gt;

&lt;p&gt;可以在服务器上执行&lt;code&gt;netstat -anltp&lt;/code&gt;查看,这样要先登陆到自己的vps才能通过2222访问树莓派.&lt;/p&gt;

&lt;p&gt;可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -CfNg -R 0.0.0.0:2222:127.0.0.1:22 username@yourvps.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再在服务器上配置&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#增加下面一句
GatewayPorts yes
#如果有
GatewayPorts no
#则改为
GatewayPorts yes
#然后重启ssh
#centos7： systemctl restart sshd
#centos6： service sshd restart
#ubuntu:   service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;netstat -anltp&lt;/code&gt;查看,监听的已经是&lt;code&gt;0.0.0.0&lt;/code&gt;了,不过即使你指定-R参数&lt;code&gt;127.0.0.1:2222&lt;/code&gt;,也不会监听&lt;code&gt;127.0.0.1&lt;/code&gt;而始终是&lt;code&gt;0.0.0.0&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用socks5代理&#34;&gt;使用socks5代理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;alias socksproxy=&amp;quot;ssh -NT -f -D 0.0.0.0:1090  -p 1234 root@host&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-N 不打开远程的shell
-T 不分配tty
-f 后台运行&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;socksproxy&lt;/code&gt;后就建立了一条ssh socks5 proxy,本地使用127.0.0.1:1090就可以使用服务器中转流量.&lt;/p&gt;

&lt;h3 id=&#34;ssh-服务&#34;&gt;ssh 服务&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;chkconfig --list&lt;/code&gt;可以查看所有服务是否开机启动等.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chkconfig --list sshd&lt;/code&gt;可以单独查看sshd服务的启动状态&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/empty/sshd&lt;/code&gt;文件夹是sshd所必须的,不能被删除否则ssh服务将无法启动&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chkconfig sshd on&lt;/code&gt;将其设置为开机启动&lt;/p&gt;

&lt;p&gt;CentOS7 用&lt;code&gt;systemctl&lt;/code&gt;取代了&lt;code&gt;service&lt;/code&gt;
旧版本的 &lt;code&gt;chkconfig docker on&lt;/code&gt; 改为 &lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;编译openssh&#34;&gt;编译openssh&lt;/h3&gt;

&lt;p&gt;在alpine中编译openssh,镜像地址 &lt;a href=&#34;http://ftp.jaist.ac.jp/pub/OpenBSD/OpenSSH/portable/&#34;&gt;http://ftp.jaist.ac.jp/pub/OpenBSD/OpenSSH/portable/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译完成后得到一些工具,如&lt;code&gt;scp&lt;/code&gt;,&lt;code&gt;sftp-server&lt;/code&gt;,&lt;code&gt;ssh&lt;/code&gt;,&lt;code&gt;sshd&lt;/code&gt;等等&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk update &amp;amp;&amp;amp; apk upgrade
apk --update add make gcc g++ zlib-dev openssl-dev
cd /tmp
OPENSSH_VERSION=openssh-7.3p1
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
curl http://ftp.jaist.ac.jp/pub/OpenBSD/OpenSSH/portable/${OPENSSH_VERSION}.tar.gz | tar xz
cd ${OPENSSH_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
./configure
make -j$CPU_NUM &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我编译好的二进制文件,能直接用于alpine系统&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/bin/ssh.xz&#34;&gt;ssh&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/bin/sshd.xz&#34;&gt;sshd&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译出来的这些工具的合集&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/bin/sshbin.tar.gz&#34;&gt;sshbin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/bin/sshtool.tar.gz&#34;&gt;sshtool&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;配合Linux&lt;code&gt;adduser&lt;/code&gt;,可以ssh到docker中&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -o /usr/local/bin/sshd.xz http://share.suconghou.cn/bin/sshd.xz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;sshd运行不能直接执行sshd,需要执行&lt;code&gt;/usr/local/bin/sshd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;配置文件为&lt;code&gt;/usr/local/etc/sshd_config&lt;/code&gt;,同时还需要几个密匙文件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -o /usr/local/bin/sshd.xz http://share.suconghou.cn/bin/sshd.xz
xz -d /usr/local/bin/sshd.xz
chmod +x /usr/local/bin/sshd
mkdir -p /usr/local/etc/
touch /usr/local/etc/sshd_config
ssh-keygen -t dsa -f /usr/local/etc/ssh_host_dsa_key -N &#39;&#39;
ssh-keygen -t rsa -f /usr/local/etc/ssh_host_rsa_key -N &#39;&#39;
ssh-keygen -t ecdsa -f /usr/local/etc/ssh_host_ecdsa_key -N &#39;&#39;
ssh-keygen -t ed25519 -f /usr/local/etc/ssh_host_ed25519_key -N &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;添加一个用户:&lt;code&gt;adduser work&lt;/code&gt; ,Alpine里是&lt;code&gt;adduser&lt;/code&gt;,Linux发行版里是&lt;code&gt;useradd&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;cat /etc/passwd 可以查看所有用户的列表,只输出用户名可以&lt;code&gt;cat /etc/passwd |cut -f 1 -d :&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;看第三个参数:500以上的,就是后面建的用户了.其它则为系统的用户.&lt;/p&gt;

&lt;p&gt;cat /etc/group 查看用户组&lt;/p&gt;

&lt;p&gt;w 可以查看当前活跃的用户列表&lt;/p&gt;

&lt;p&gt;删除用户&lt;code&gt;userdel&lt;/code&gt; , 用户&lt;code&gt;userdel -r 用户名&lt;/code&gt;,删除用户账户及用户主目录文件&lt;/p&gt;

&lt;p&gt;没有外网IP还可以使用ssh建立一个隧道&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -CfNg -R 0.0.0.0:2233:127.0.0.1:22 root@yourvps.com -p 27558

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Linux下常用的下载利器</title>
      <link>http://blog.suconghou.cn/post/linux-download-tools/</link>
      <pubDate>Fri, 01 Jan 2016 23:54:20 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux-download-tools/</guid>
      <description>

&lt;h2 id=&#34;wget&#34;&gt;wget&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;wget -c -O filename &amp;quot;http://xx.com&amp;quot;&lt;/code&gt; 下载存储到指定文件,并指定断点续传
&lt;code&gt;wget -nc -c -i url.txt&lt;/code&gt; 批量下载文件中指定的资源(每行一个连接),跳过已下载的(同名的),并且断点续传.&lt;/p&gt;

&lt;h2 id=&#34;curl&#34;&gt;curl&lt;/h2&gt;

&lt;p&gt;常用的命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl http://xx.com&lt;/code&gt; 只获取http消息正文&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -I http://xx.com&lt;/code&gt; 只获取http消息头&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -i http://xx.com&lt;/code&gt; 获取http消息头和正文&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -d &amp;quot;name=abc&amp;amp;pass=123&amp;quot; http://xx.com&lt;/code&gt; 发送&lt;code&gt;http post&lt;/code&gt;请求,采用的是&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;形式&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -F &amp;quot;name=abc&amp;quot; -F &amp;quot;pass=123&amp;quot; http://xx.com&lt;/code&gt; 发送&lt;code&gt;http post&lt;/code&gt;请求,采用的是&lt;code&gt;multipart/form-data&lt;/code&gt; 形式,此两种方式都可以由 $_POST 接收&lt;/p&gt;

&lt;p&gt;&lt;code&gt;curl -F &amp;quot;name=abc&amp;quot; -F &amp;quot;file=@/tmp/1.jpg&amp;quot; http://xx.com&lt;/code&gt; 发送 &lt;code&gt;http post&lt;/code&gt;请求, &lt;code&gt;multipart/form-data&lt;/code&gt; 形式还可以上传文件,只需改为@加路径&lt;/p&gt;

&lt;p&gt;curl 不仅能用来下载,还是网络调试的利器,Chrome的网络请求也可以直接另存为curl请求格式&lt;/p&gt;

&lt;p&gt;批量下载规则的URL资源&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;curl -O &amp;quot;http://www.example.com/[0001-9999].jpg&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在shell中可以这样用,实现同样功能&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in {10001..19999}; do
wget www.example.com/${i:1}.jpg;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for i in {0001..9999}; do
echo www.example.com/${i}.jpg;
done
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;下载一个压缩包-不存储直接解压&#34;&gt;下载一个压缩包,不存储直接解压&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;curl -sSL http://www.memcached.org/files/memcached-1.4.30.tar.gz | tar xz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;其中&lt;code&gt;-L&lt;/code&gt;表示更随重定向&lt;code&gt;-s&lt;/code&gt;为安静模式,不输出任何信息,&lt;code&gt;-S&lt;/code&gt;为在安静模式下出错的话要输出错误信息.&lt;/p&gt;

&lt;p&gt;要解压到指定目录,后面的可以使用 tar xzC ./path/to/dir ,当然这个路径要存在&lt;/p&gt;

&lt;p&gt;用curl下载的好处是不会像wget那样出现多个已下载的重复文件&lt;/p&gt;

&lt;h2 id=&#34;axel&#34;&gt;Axel&lt;/h2&gt;

&lt;p&gt;下载速度最快,分段下载速度优异
&lt;code&gt;axel -n 30 -a -o localfilename http://xx.com/downloadfile&lt;/code&gt; 30个线程分段下载,存储为localfilename
参数&lt;code&gt;-a&lt;/code&gt;更新进度条而不是每次都输出
参数&lt;code&gt;-H&lt;/code&gt; 添加header,参数&lt;code&gt;-U&lt;/code&gt;设定&lt;code&gt;user-agent&lt;/code&gt;
&lt;strong&gt;Downloads patch from 4 ftp mirrors&lt;/strong&gt;
axel &lt;a href=&#34;ftp://ftp.{us,uk,br,fr}.kernel.org/pub/linux/kernel/v2.6/patch-2.6.39.gz&#34;&gt;ftp://ftp.{us,uk,br,fr}.kernel.org/pub/linux/kernel/v2.6/patch-2.6.39.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;axel &lt;a href=&#34;http://itmp.suconghou.cn&#34;&gt;http://itmp.suconghou.cn&lt;/a&gt; hypriot-rpi-20160306-192317.img.zip &lt;a href=&#34;http://wtmp.suconghou.cn&#34;&gt;http://wtmp.suconghou.cn&lt;/a&gt; hypriot-rpi-20160306-192317.img.zip &lt;a href=&#34;http://btmp.suconghou.cn&#34;&gt;http://btmp.suconghou.cn&lt;/a&gt; hypriot-rpi-20160306-192317.img.zip&lt;/p&gt;

&lt;h2 id=&#34;aria2c&#34;&gt;Aria2c&lt;/h2&gt;

&lt;p&gt;aria2c支持多种协议,&lt;code&gt;URI&lt;/code&gt; &lt;code&gt;MAGNET&lt;/code&gt; &lt;code&gt;TORRENT_FILE&lt;/code&gt; &lt;code&gt;METALINK_FILE&lt;/code&gt;,也支持axel类似的分段下载&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aria2c -s 30 -c -o localfilename http://xx.com/downloadfile&lt;/code&gt; 30个线程分段下载,存储为localfilename,并断点续传&lt;/p&gt;

&lt;p&gt;&lt;code&gt;aria2c file1.torrent file2.torrent&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
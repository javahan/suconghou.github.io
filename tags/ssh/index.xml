<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ssh on 苏苏的博客</title>
    <link>http://blog.suconghou.cn/tags/ssh/</link>
    <description>Recent content in Ssh on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 07 Jan 2016 13:47:22 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/tags/ssh/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>SSH</title>
      <link>http://blog.suconghou.cn/post/linux-ssh/</link>
      <pubDate>Thu, 07 Jan 2016 13:47:22 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux-ssh/</guid>
      <description>

&lt;h2 id=&#34;避免ssh自动断开连接&#34;&gt;避免SSH自动断开连接&lt;/h2&gt;

&lt;p&gt;如果有一段时间在SSH连接上无数据传输，连接就会断开,以下设定可以解决这个问题&lt;/p&gt;

&lt;p&gt;方案一：在客户端设置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo vim /etc/ssh/ssh_config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;开启 &lt;code&gt;ServerAliveInterval 60&lt;/code&gt;
开启 &lt;code&gt;TCPKeepAlive yes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;此后该系统里的用户连接SSH时，每60秒会发一个KeepAlive请求，避免被踢。&lt;/p&gt;

&lt;p&gt;方案二：在服务器端设置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo vim /etc/ssh/sshd_config&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;开启&lt;code&gt;ClientAliveInterval 60&lt;/code&gt;
开启 &lt;code&gt;TCPKeepAlive yes&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果您只想让当前的 ssh 保持连接，可以使用以下的命令：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh -o ServerAliveInterval=60 user@sshserver&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ssh隧道&#34;&gt;ssh隧道&lt;/h2&gt;

&lt;h3 id=&#34;cfng&#34;&gt;-CfNg&lt;/h3&gt;

&lt;p&gt;C表示压缩数据传输
f表示后台用户验证,这个选项很有用,没有shell的不可登陆账号也能使用.
N表示不执行脚本或命令
g表示允许远程主机连接转发端口&lt;/p&gt;

&lt;h3 id=&#34;l-本地转发&#34;&gt;-L 本地转发&lt;/h3&gt;

&lt;p&gt;-L [本地监听IP:]本地监听端口号:目标主机IP:目标端口号
(其中,“本地监听IP”可以省略，省略的话就认为是“0.0.0.0”，但为了安全性考虑，请务必使用“127.0.0.1”做为本地监听端口， 而不要使用默认的“0.0.0.0”。）&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh -D 8080 user@host&lt;/code&gt;
SSH会建立一个socket，去监听本地的8080端口。一旦有数据传向那个端口，就自动把它转移到SSH连接上面，发往远程主机。可以想象，如果8080端口原来是一个不加密端口，现在将变成一个加密端口。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh -L 2121:host2:21 host3&lt;/code&gt;
命令中的L参数一共接受三个值，分别是&amp;rdquo;本地端口:目标主机:目标主机端口&amp;rdquo;，它们之间用冒号分隔。这条命令的意思，就是指定SSH绑定本地端口2121，然后指定host3将所有的数据，转发到目标主机host2的21端口（假定host2运行FTP，默认端口为21）。
这样一来，我们只要连接host1的2121端口，就等于连上了host2的21端口。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -CfNg -L 6300:127.0.0.1:1521 oracle@172.16.1.164
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;本机的6300端口就是远程主机172.16.1.164的1521端口&lt;/p&gt;

&lt;h3 id=&#34;r-远程转发&#34;&gt;-R 远程转发&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt; ssh -CfNg -R 1521:127.0.0.1:6300 oracle@172.16.1.164
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在远程主机172.16.1.164上打开1521端口, 来映射本机的6300端口.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在树莓派上映射ssh到外网&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -CfNg -R 2222:127.0.0.1:22 username@yourvps.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就映射vps的2222端口到树莓派上了.但是这样映射的是服务器的127.0.0.1:2222,外网无法连接这个2222端口&lt;/p&gt;

&lt;p&gt;如果你自己的服务器连接时需要端口可以在最后加上 &lt;code&gt;-p port&lt;/code&gt; 指定ssh的端口&lt;/p&gt;

&lt;p&gt;可以在服务器上执行&lt;code&gt;netstat -anltp&lt;/code&gt;查看,这样要先登陆到自己的vps才能通过2222访问树莓派.&lt;/p&gt;

&lt;p&gt;可以使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -CfNg -R 0.0.0.0:2222:127.0.0.1:22 username@yourvps.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再在服务器上配置&lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#增加下面一句
GatewayPorts yes
#如果有
GatewayPorts no
#则改为
GatewayPorts yes
#然后重启ssh
#centos7： systemctl restart sshd
#centos6： service sshd restart
#ubuntu:   service ssh restart
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;netstat -anltp&lt;/code&gt;查看,监听的已经是&lt;code&gt;0.0.0.0&lt;/code&gt;了,不过即使你指定-R参数&lt;code&gt;127.0.0.1:2222&lt;/code&gt;,也不会监听&lt;code&gt;127.0.0.1&lt;/code&gt;而始终是&lt;code&gt;0.0.0.0&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;使用socks5代理&#34;&gt;使用socks5代理&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;alias socksproxy=&amp;quot;ssh -NT -f -D 0.0.0.0:1090  -p 1234 root@host&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;-N 不打开远程的shell
-T 不分配tty
-f 后台运行&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;socksproxy&lt;/code&gt;后就建立了一条ssh socks5 proxy,本地使用127.0.0.1:1090就可以使用服务器中转流量.&lt;/p&gt;

&lt;h3 id=&#34;ssh-服务&#34;&gt;ssh 服务&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;chkconfig --list&lt;/code&gt;可以查看所有服务是否开机启动等.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chkconfig --list sshd&lt;/code&gt;可以单独查看sshd服务的启动状态&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/var/empty/sshd&lt;/code&gt;文件夹是sshd所必须的,不能被删除否则ssh服务将无法启动&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chkconfig sshd on&lt;/code&gt;将其设置为开机启动&lt;/p&gt;

&lt;p&gt;CentOS7 用&lt;code&gt;systemctl&lt;/code&gt;取代了&lt;code&gt;service&lt;/code&gt;
旧版本的 &lt;code&gt;chkconfig docker on&lt;/code&gt; 改为 &lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
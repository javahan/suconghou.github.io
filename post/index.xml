<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 苏苏的博客</title>
    <link>http://blog.suconghou.cn/post/</link>
    <description>Recent content in Posts on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 Sep 2016 14:37:51 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>pc hardware</title>
      <link>http://blog.suconghou.cn/post/pc-hardware/</link>
      <pubDate>Sun, 04 Sep 2016 14:37:51 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/pc-hardware/</guid>
      <description>

&lt;h2 id=&#34;修电脑相关知识&#34;&gt;修电脑相关知识&lt;/h2&gt;

&lt;h3 id=&#34;较好的pe&#34;&gt;较好的PE&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;微PE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wepe.com.cn/&#34;&gt;http://www.wepe.com.cn/&lt;/a&gt; 自带刻录,可以一键安装到U盘,硬盘等,支持UEFI,CMS等多种启动方式.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一般的BIOS里找不到UEFI/CMS的切换设置,可能是&lt;code&gt;security boot&lt;/code&gt;的配置,禁用&lt;code&gt;security boot&lt;/code&gt;试试&lt;/p&gt;

&lt;p&gt;如果在BIOS里找不到U盘,可能是&lt;code&gt;fastboot&lt;/code&gt;的问题,可以禁用fastboot,安装好系统后在开启.&lt;/p&gt;

&lt;p&gt;硬盘的设置模式里,找不到U盘或者硬盘,可以尝试切换&lt;code&gt;AHCI/IDE&lt;/code&gt;,注意安装好系统后,此选项不能够再随意切换,否知导致系统进不去.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;休眠能将现有所有工作保存到硬盘,下次开机恢复上次的会话,Windows8及以后采用了混合休眠机制&lt;/p&gt;

&lt;p&gt;你可能找不到单纯的休眠按钮.&lt;/p&gt;

&lt;p&gt;可以使用&lt;code&gt;shutdown -h&lt;/code&gt;休眠&lt;/p&gt;

&lt;p&gt;其他一些补充&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关机计算机：shutdown.exe -s -t 00
重启计算机：shutdown.exe -r -t 00
注销计算机：shutdown.exe -l -t 00
锁定计算机：rundll32.exe user32.dll,LockWorkStation
休眠计算机：rundll32.exe powrProf.dll,SetSuspendState
睡眠计算机：rundll32.exe powrprof.dll,SetSuspendState 0,1,0,
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;性能天梯图&#34;&gt;性能天梯图&lt;/h2&gt;

&lt;p&gt;CPU天梯图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://suconghou.sinaapp.com/e7d6741f4b703c5057fa6c4f0f3cf971.jpg&#34; alt=&#34;CPU天梯图简化版&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CPU天梯图详细&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://suconghou.sinaapp.com/33f41a782ceddd3a78a7f40321329777.jpg&#34; alt=&#34;CPU天梯图详细&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显卡天梯图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://suconghou.sinaapp.com/14db00815cebc3e46f9647515b384815.jpg&#34; alt=&#34;显卡天梯图&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>memcached usage</title>
      <link>http://blog.suconghou.cn/post/memcached-usage/</link>
      <pubDate>Wed, 24 Aug 2016 14:44:23 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/memcached-usage/</guid>
      <description>

&lt;h2 id=&#34;安装memcached&#34;&gt;安装memcached&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://memcached.org/downloads&#34;&gt;http://memcached.org/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;memcached所有版本见&lt;a href=&#34;http://www.memcached.org/files/&#34;&gt;http://www.memcached.org/files/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
MEMCACHE_VERSION=memcached-1.4.31
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.memcached.org/files/${MEMCACHE_VERSION}.tar.gz
tar xzf ${MEMCACHE_VERSION}.tar.gz
cd ${MEMCACHE_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
./configure
make -j$CPU_NUM &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker版本见:&lt;a href=&#34;https://hub.docker.com/r/suconghou/memcached/&#34;&gt;https://hub.docker.com/r/suconghou/memcached/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动memcached&#34;&gt;启动Memcached&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;memcached -d -u memcached -p 11211 -m 8 -P /var/run/memcached/memcached.pid

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-d 以daemon方式运行&lt;/li&gt;
&lt;li&gt;-u 绑定使用指定用户运行进程(仅在以root运行的时候有效)&lt;/li&gt;
&lt;li&gt;-p 设置TCP端口号(默认11211)&lt;/li&gt;
&lt;li&gt;-m 允许最大内存用量，单位M (默认: 64 MB)&lt;/li&gt;
&lt;li&gt;-M 内存耗尽时返回错误，而不是删除项&lt;/li&gt;
&lt;li&gt;-l 是监听的服务器IP地址，默认应该是本机&lt;/li&gt;
&lt;li&gt;-P 将PID写入文件&lt;file&gt;，这样可以使得后边进行快速进程终止, 需要与-d 一起使用&lt;/li&gt;
&lt;li&gt;-c 最大同时连接数，默认是1024&lt;/li&gt;
&lt;li&gt;-t 线程数,默认为4&lt;/li&gt;
&lt;li&gt;-v 输出警告和错误信息&lt;/li&gt;
&lt;li&gt;-vv 打印客户端的请求和返回信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下是不限制访问IP的,相当于是外网和内网都能访问,-l 使只有这个IP能访问&lt;/p&gt;

&lt;p&gt;尽量不要用root用户运行.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;状态查看&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 telnet 连接 memcached
&lt;code&gt;stats settings&lt;/code&gt;可以查看所有参数设置&lt;/p&gt;

&lt;p&gt;memcached状态和性能查看&lt;/p&gt;

&lt;p&gt;stats命令&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://static.suconghou.cn/document/memcached.jpg&#34; alt=&#34;memcached stats命令&#34; /&gt;&lt;/p&gt;

&lt;p&gt;官方也提供监控工具&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/memcached/memcached/blob/master/scripts/memcached-tool&#34;&gt;https://github.com/memcached/memcached/blob/master/scripts/memcached-tool&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript code snippet</title>
      <link>http://blog.suconghou.cn/post/javascript-code-snippet/</link>
      <pubDate>Thu, 11 Aug 2016 10:27:18 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-code-snippet/</guid>
      <description>

&lt;h2 id=&#34;实用的javascript代码锦集&#34;&gt;实用的Javascript代码锦集&lt;/h2&gt;

&lt;h3 id=&#34;获取查询查询字符串get参数值&#34;&gt;获取查询查询字符串get参数值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function getParam()
{
	var data = decodeURIComponent(location.href).split(&amp;quot;?&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;);
	var param = {};
	for(var i = 0; i&amp;lt;data .length; i++)
	{
		param[data [i].split(&amp;quot;=&amp;quot;)[0]] = data [i].split(&amp;quot;=&amp;quot;)[1];
	}
	return param;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于PHP中的&lt;code&gt;$_GET&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $_GET = (function()
{
	var url = decodeURIComponent(location.href);
	var u = url.split( &amp;quot;?&amp;quot; );
	if ( typeof (u[1]) == &amp;quot;string&amp;quot; )
	{
		u = u[1].split( &amp;quot;&amp;amp;&amp;quot; );
		var get = {};
		for ( var i in u)
		{
			var j = u[i].split( &amp;quot;=&amp;quot; );
			get[j[0]] = j[1];
		}
		return get;
	}
	else
	{
		return {};
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给出要获取的参数,每次都会解析一遍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getPar(par)
{
	//获取当前URL
	var local_url = decodeURIComponent(location.href);
	//获取要取得的get参数位置
	var get = local_url.indexOf(par + &amp;quot;=&amp;quot; );
	if (get == -1)
	{
		return false ;
	}
	//截取字符串
	var get_par = local_url.slice(par.length + get + 1);
	//判断截取后的字符串是否还有其他get参数
	var nextPar = get_par.indexOf( &amp;quot;&amp;amp;&amp;quot; );
	if (nextPar != -1)
	{
		get_par = get_par.slice(0, nextPar);
	}
	return get_par;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QueryString&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function QueryString(item)
{
	var value = location.search.match(new RegExp(&#39;[\?\&amp;amp;]&#39; + item + &#39;=([^\&amp;amp;]*)(\&amp;amp;?)&#39;,&#39;i&#39;));
	return value ? value[1] : value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;取得cookie中某个键的值&#34;&gt;取得Cookie中某个键的值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$.getCookie = function(name)
{
	 if(document.cookie.indexOf(name)!=-1) return document.cookie.split(name+&#39;=&#39;)[1].split(&#39;;&#39;)[0]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getcookie(cookieid)
{
	//获取cookie字符串
	var strCookie=document.cookie;
	//将多cookie切割为多个名/值对
	var arrCookie=strCookie.split(&amp;quot;; &amp;quot;);
	var cookieval;
	//遍历cookie数组，处理每个cookie对
	for(var i=0;i&amp;lt;arrCookie.length;i++)
	{
		var arr=arrCookie[i].split(&amp;quot;=&amp;quot;);
		//找到名称为userId的cookie，并返回它的值
		if(cookieid==arr[0])
		{
			cookieval=arr[1];
			break;
		}
	}
	return(cookieval);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;进入全屏&#34;&gt;进入全屏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function gofull()
{
	var el=document.documentElement;
	el.webkitRequestFullScreen&amp;amp;&amp;amp;el.webkitRequestFullScreen();
	el.mozRequestFullScreen&amp;amp;&amp;amp;el.mozRequestFullScreen();
	el.requestFullscreen&amp;amp;&amp;amp;el.requestFullscreen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串去空格&#34;&gt;字符串去空格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;String.prototype.trim=function() {return this.replace(/(^\s*)|(\s*$)/g,&amp;quot;&amp;quot;); }
String.prototype.ltrim=function(){return this.replace(/(^\s*)/g,&amp;quot;&amp;quot;); }
String.prototype.rtrim=function(){return this.replace(/(\s*$)/g,&amp;quot;&amp;quot;); }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字节格式化&#34;&gt;字节格式化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function size(size)
{
	var name=[&#39;B&#39;,&#39;KB&#39;,&#39;MB&#39;,&#39;GB&#39;,&#39;TB&#39;,&#39;PB&#39;];
	var pos=0;
	while(size&amp;gt;=1204)
	{
	    size/=1024;
	    pos++;
	}
	return size.toFixed(2)+&amp;quot; &amp;quot;+name[pos];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一些正则验证&#34;&gt;一些正则验证&lt;/h3&gt;

&lt;p&gt;验证邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_mail(str)
{
	return(new RegExp(/^[0-9a-zA-Z]+@(([0-9a-zA-Z]+)[.])+[a-z]{2,4}$/i).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证手机号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_tel(str)
{
	return(new RegExp(/^1[34578][0-9]{9}$/).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;base64的1x1像素间隔gif&#34;&gt;Base64的1x1像素间隔gif&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一个range函数&#34;&gt;一个range函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function range(start, count)
{
	return Array.apply(0, Array(count)).map(function (element, index)
	{
		return index + start;
	});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;简化-console-log&#34;&gt;简化&lt;code&gt;console.log&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var log = console.log.bind(console);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成较短的唯一id&#34;&gt;生成较短的唯一ID&lt;/h3&gt;

&lt;p&gt;一定年限内单线程非连续调用唯一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function shortId()
{
	var time=Date.now()+&#39;&#39;;
	time=parseInt(time.substr(1));
	return time.toString(36);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成随机短ID,仅具备较低的不重复性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var t=(((1+Math.random())*0x10000000)|0).toString(16);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成指定长度随机字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function code($nc, $a=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;)
{
    $l=strlen($a)-1; $r=&#39;&#39;;
    while($nc--&amp;gt;0) $r.=$a{mt_rand(0,$l)};
    return $r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;给jquery的form添加-serializeobject&#34;&gt;给jQuery的form添加&lt;code&gt;serializeObject&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.serializeObject=function()
{
	var a,o,h,i,e;
	a=this.serializeArray();
	o={};
	h=o.hasOwnProperty;
	for(i=0;i&amp;lt;a.length;i++)
	{
		e=a[i];
		if(!h.call(o,e.name))
		{
			o[e.name]=e.value;
		}
	}
	return o;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用效果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery(&amp;quot;form&amp;quot;).serialize(); //&amp;quot;username=&amp;amp;password=&amp;quot;
jQuery(&amp;quot;form&amp;quot;).serializeArray(); //[{name:&amp;quot;username&amp;quot;,value:&amp;quot;&amp;quot;},{name:&amp;quot;password&amp;quot;,value:&amp;quot;&amp;quot;}]
jQuery(&amp;quot;form&amp;quot;).serializeObject(); //{username:&amp;quot;&amp;quot;,password:&amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;资源预取&#34;&gt;资源预取&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function prefetch(url)
{
	var link = document.createElement(&amp;quot;link&amp;quot;);
	link.href = url;
	link.rel=&amp;quot;prefetch&amp;quot;;
	var s = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
	s.appendChild(link);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用-google-analytics-统计js错误&#34;&gt;用&lt;code&gt;Google Analytics&lt;/code&gt;统计JS错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,&#39;script&#39;,&#39;https://www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);
window.addEventListener(&#39;error&#39;, function (err)
{
	ga(&#39;create&#39;, &#39;UA-xxx-1&#39;, &#39;auto&#39;);
    var lineAndColumnInfo = err.colno ? &#39; line:&#39; + err.lineno +&#39;, column:&#39;+ err.colno : &#39; line:&#39; + err.lineno;
    ga(&#39;send&#39;, &#39;event&#39;, &#39;JavaScript Error&#39;, err.message, location.href+&#39; =&amp;gt; &#39;+err.filename + lineAndColumnInfo + &#39; -&amp;gt; &#39; +  navigator.userAgent, 0, true );
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;UA-xxx-1&lt;/code&gt;使用自己的统计ID&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript senior</title>
      <link>http://blog.suconghou.cn/post/javascript-senior/</link>
      <pubDate>Tue, 09 Aug 2016 21:27:39 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-senior/</guid>
      <description>

&lt;h2 id=&#34;javascript-参数传递&#34;&gt;Javascript 参数传递&lt;/h2&gt;

&lt;p&gt;说起参数传递,首先需要弄清楚javascript里的数据类型&lt;/p&gt;

&lt;p&gt;原始数据类型
&lt;code&gt;Undefined&lt;/code&gt; &lt;code&gt;Null&lt;/code&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;code&gt;Number&lt;/code&gt; &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用数据类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; &lt;code&gt;Date&lt;/code&gt; 等&lt;/p&gt;

&lt;p&gt;原始数据类型存储在栈的简单数据段,他们的值直接存储在变量访问的位置(因原始数据类型占据的空间是固定的,可以存储在较小的内存区域&lt;code&gt;栈&lt;/code&gt;中)&lt;/p&gt;

&lt;p&gt;引用数据类型是存储在堆中的对象,存储在变量处的值只是一个指针,指向存储对象的内存地址,这是因为引用类型的大小会改变.&lt;/p&gt;

&lt;p&gt;不同的内存分配机制带来不同的访问机制&lt;/p&gt;

&lt;p&gt;在JavaScript中,是不允许直接访问保存在堆内存中的对象的,访问对象时必须取得对象在堆内存中的地址,然后按地址去取得对象中的值.&lt;/p&gt;

&lt;p&gt;这便是传说中的按引用访问.&lt;/p&gt;

&lt;p&gt;而原始类型则是直接访问到的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复制变量时的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;会将原始值的副本赋值给新变量.此后两个变量完全独立.&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;会把内存地址赋值给新变量,也就是说两个变量都指向堆内存中的同一个对象.
他们中任何一个改变都会反映到另一个身上.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数传递的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最重要的一点:&lt;code&gt;ECMAScript&lt;/code&gt;中所有函数的参数都是按值传递的.&lt;/p&gt;

&lt;p&gt;但原始值和引用值仍会造成不同的后果.&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;把变量里的值传递给参数,之后两个变量互不影响.(就是把实参复制给形参的过程)&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;任然是将实参里面的值复制到形参,但是注意&lt;em&gt;对象变量它里面的值是这个对象的堆内存地址&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;也就是说形参和实参都是指向同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;但是也要记住另外一点:如果形参被赋值为另外一个对象时,那么这个形参将会丢弃对上次指向的堆内存地址,而指向新对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;此时,形参和实参相互脱离,互不影响,原先的实参任然指向原先对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;如果是添加修改形参的属性,那么就是修改堆内存中的对象,形参和实参将同时得到反映,因为他们指向的是同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;这种传递方式被称为&lt;code&gt;Call By Sharing&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function box(obj)
{
	obj.name=&#39;hello&#39;;
	var obj=new Object();
	obj.name=&#39;world&#39;;
}
var obj=new Object();
box(obj);
console.log(obj.name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意两点:
1. &lt;code&gt;var obj=new Object()&lt;/code&gt; 声明提升&lt;/p&gt;

&lt;p&gt;变为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj;
obj.name=&#39;hello&#39;;
obj=new Object();
obj.name=&#39;world&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数的已存在一个变量形参&lt;code&gt;obj&lt;/code&gt;,再次的变量申明会忽略&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;obj=new Object()&lt;/code&gt; 时,obj的修改就不会影响外层obj变量了,因为他此时已经脱离执行那个堆内存对象了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://www.zhihu.com/question/27114726&#34;&gt;http://www.zhihu.com/question/27114726&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;object-create&#34;&gt;Object.create&lt;/h2&gt;

&lt;p&gt;简单来讲，new Object()是一种通过构造函数来创建object的方式，而Object.create(proto, [ propertiesObject ])
不需要通过构造函数就可以创建一个object，Object.create()的第一个参数是必须要的，第二个参数可选。其实Object.create()内部依然是通过new一个构造函数的方式来实现的，它有构造函数，不过这个构造函数是隐式存在的，看一下使老旧浏览器支持Object.create方法的“polyfill”就可以对它们之间的区别一目了然了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
    Object.create = function (o) {
    function F() {}  //定义了一个隐式的构造函数
    F.prototype = o;
    return new F();  //其实还是通过new来实现的
    };
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HAProxy优化应用程序速度</title>
      <link>http://blog.suconghou.cn/post/use-haproxy/</link>
      <pubDate>Fri, 29 Jul 2016 14:27:54 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-haproxy/</guid>
      <description>

&lt;h2 id=&#34;haproxy&#34;&gt;HAProxy&lt;/h2&gt;

&lt;p&gt;HAProxy高性能的反向代理软件,更专注于TCP,HTTP处理,它可以基于四层或七层进行反向代理,尤其适合于高负载且需要进行七层处理的 Web 站点.&lt;/p&gt;

&lt;p&gt;单进程、事件驱动模型,通常用于超高流量的负载均衡.&lt;/p&gt;

&lt;p&gt;我们也可以使用它来作为中转站,使直连连通率不好的请求进过中转提升速度.&lt;/p&gt;

&lt;h3 id=&#34;编译安装&#34;&gt;编译安装&lt;/h3&gt;

&lt;p&gt;编译haproxy时必须制定target,不能直接make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Due to too many reports of suboptimized setups, building without
specifying the target is no longer supported. Please specify the
target OS in the TARGET variable, in the following form:

   make TARGET=xxx

Please choose the target among the following supported list :

   linux2628, linux26, linux24, linux24e, linux22, solaris
   freebsd, openbsd, cygwin, custom, generic

Use &amp;quot;generic&amp;quot; if you don&#39;t want any optimization, &amp;quot;custom&amp;quot; if you
want to precisely tweak every option, or choose the target which
matches your OS the most in order to gain the maximum performance
out of it. Please check the Makefile in case of doubts.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;linux2628 表示  内核版本&amp;gt;=2.6.28&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y wget gcc g++ make libpcre++0v5 libpcre++-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;HAPROXY_VERSION=haproxy-1.6.8
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.haproxy.org/download/1.6/src/${HAPROXY_VERSION}.tar.gz
tar zxf ${HAPROXY_VERSION}.tar.gz
cd ${HAPROXY_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
make TARGET=linux2628 ARCH=X86_64 USE_STATIC_PCRE=1 -j$CPU_NUM &amp;amp;&amp;amp; make install

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译32位版本&lt;code&gt;make TARGET=linux26 ARCH=i686 USE_STATIC_PCRE=1 -j$CPU_NUM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在64位系统下编译32位需要&lt;code&gt;apt-get install gcc-multilib g++-multilib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我编译好的haproxy version 1.6.8&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/bin/haproxy.xz&#34;&gt;http://share.suconghou.cn/bin/haproxy.xz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;32位 &lt;a href=&#34;http://share.suconghou.cn/bin/haproxy.gz&#34;&gt;http://share.suconghou.cn/bin/haproxy.gz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;使用docker版本的haproxy&#34;&gt;使用Docker版本的HAProxy&lt;/h3&gt;

&lt;p&gt;这里提供一份编译好的最新版HAProxy镜像 &lt;a href=&#34;https://hub.docker.com/r/suconghou/haproxy/&#34;&gt;https://hub.docker.com/r/suconghou/haproxy/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;优化国外主机速度&#34;&gt;优化国外主机速度&lt;/h3&gt;

&lt;p&gt;HAProxy有多种连接模型,还有多种负载均衡算法,由于只有一台机器,我们主要侧重于使用它的反向代理.&lt;/p&gt;

&lt;p&gt;HAProxy可以一边保持与代理后端的长连接,一边又保持对客户端的连接.
这样双向保持持久连接,省去了中间反复创建连接可以在一定程度上优化速度.&lt;/p&gt;

&lt;p&gt;其只需要一个配置文件,配置主要有以下几部分功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;：用于为所有其它配置段提供默认参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frontend&lt;/code&gt;：用于定义一系列监听的套接字，这些套接字可接受客户端请求并与之建立连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backend&lt;/code&gt;：用于定义一系列后端服务器，代理将会将对应客户端的请求转发至这些服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;： 通过关联前端和后端定义了一个完整的代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置写在&lt;code&gt;haproxy.cfg&lt;/code&gt;文件中,启动的时候指定使用的配置文件.&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;haproxy -c -f /etc/haproxy/haproxy.cfg&lt;/code&gt;检查配置文件,&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg&lt;/code&gt;使用此配置文件启动&lt;/p&gt;

&lt;p&gt;一个简单的配置文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    log         127.0.0.1 local3
    pidfile     /var/run/haproxy.pid
    user        haproxy
    group       haproxy
    daemon

defaults
    mode                    http
    log                     global
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 30000

frontend http-in
    mode http
    bind 0.0.0.0:1080
    option http-keep-alive
    default_backend  servers

backend servers
	option http-keep-alive
    server myserver 192.243.115.210:80 check maxconn 6000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个在应对高并发时通常都需要改的
&lt;code&gt;ulimit -n 8192&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;重启HAProxy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg -st `cat /var/run/haproxy.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;升级-glibc-版本-最新发布-http-www-gnu-org-software-libc&#34;&gt;升级&lt;code&gt;glibc&lt;/code&gt;版本,最新发布 &lt;a href=&#34;http://www.gnu.org/software/libc/&#34;&gt;http://www.gnu.org/software/libc/&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;所有版本见&lt;code&gt;http://mirror.hust.edu.cn/gnu/libc/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;错误 &lt;code&gt;libc.so.6: version GLIBC_2.14 not found&lt;/code&gt; 表明当前系统的glibc版本较低&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strings libc.so.6 |grep GLIBC_&lt;/code&gt;可以查看当前系统支持的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://mirror.hust.edu.cn/gnu/libc/glibc-2.19.tar.xz
tar Jxf glibc-2.19.tar.xz
cd glibc-2.19
mkdir build
cd build
../configure
make -j4&amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;a href=&#34;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&#34;&gt;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&lt;/a&gt;
此编译需要较长时间&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>react native</title>
      <link>http://blog.suconghou.cn/post/react-native/</link>
      <pubDate>Mon, 11 Jul 2016 11:39:08 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/react-native/</guid>
      <description>

&lt;h2 id=&#34;react-native&#34;&gt;react native&lt;/h2&gt;

&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;

&lt;p&gt;前提是需要node和npm,这里不在赘述.介绍一个npm加速的.&lt;/p&gt;

&lt;p&gt;使用淘宝的npm镜像.控制台运行,或者加入你的bashrc中永久生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias cnpm=&amp;quot;npm --registry=https://registry.npm.taobao.org --cache=$HOME/.npm/.cache/cnpm --disturl=https://npm.taobao.org/dist --userconfig=$HOME/.cnpmrc&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装开发必备的一些package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install -g react-native-cli webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react-native&lt;/code&gt;也调用了&lt;code&gt;npm&lt;/code&gt;命令,所以我们可以再来个alias加速&lt;code&gt;react-native init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alias npm=&#39;cnpm&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者直接将仓库改为淘宝的NPM镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org
npm config set disturl https://npm.taobao.org/dist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在mac上还需要一些东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install flow watchman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完以后可以开始helloworld了.&lt;/p&gt;

&lt;h3 id=&#34;开始第一个例子&#34;&gt;开始第一个例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /data/tmp
react-native init HelloWorld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后正在初始化大致如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This will walk you through creating a new React Native project in /data/tmp/HelloWorld
Installing react-native package from npm...
Setting up new React Native app in /data/tmp/HelloWorld
HelloWorld@0.0.1 /data/tmp/HelloWorld
└── react@15.2.1

To run your app on iOS:
   cd /data/tmp/HelloWorld
   react-native run-ios
   - or -
   Open /data/tmp/HelloWorld/ios/HelloWorld.xcodeproj in Xcode
   Hit the Run button
To run your app on Android:
   Have an Android emulator running (quickest way to get started), or a device connected
   cd /data/tmp/HelloWorld
   react-native run-android
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;React&lt;/code&gt;类名(组件名)必须首字母大写才会被认为是一个组件,否则在JSX里只会当做普通标签&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发IOS的教程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们执行&lt;code&gt;react-native run-ios&lt;/code&gt;开始编译运行,前提是你必须安装了&lt;code&gt;xcode&lt;/code&gt;哦.&lt;/p&gt;

&lt;p&gt;执行后,出现&lt;code&gt;BUILD SUCCEEDED&lt;/code&gt;,同时自动打开新的终端运行了一个server在8081端口.&lt;/p&gt;

&lt;p&gt;模拟器中也会出现刚编译好的app的窗口,使用&lt;code&gt;cmd+r&lt;/code&gt;刷新,&lt;code&gt;cmd+d&lt;/code&gt;弹出开发菜单.&lt;/p&gt;

&lt;p&gt;我们可以修改&lt;code&gt;index.ios.js&lt;/code&gt;开始开发了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发Android的教程&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;fetch&lt;/code&gt;调用接口时,可能会出现&lt;code&gt;The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.&lt;/code&gt;错误&lt;/p&gt;

&lt;p&gt;这是IOS9要求必须使用https通信,需要修改 &lt;a href=&#34;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&#34;&gt;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;react native&lt;/code&gt;创建&lt;code&gt;Info.plist&lt;/code&gt;时就已经为我们说明了,在&lt;code&gt;NSExceptionDomains&lt;/code&gt;下面的&lt;code&gt;dict&lt;/code&gt;里添加一个排除域名就OK了.&lt;/p&gt;

&lt;p&gt;注意,不能将默认的&lt;code&gt;localhost&lt;/code&gt;去掉,否则会出现&lt;code&gt;_fbBatchedBridge is undefined&lt;/code&gt;错误.&lt;/p&gt;

&lt;h2 id=&#34;打包&#34;&gt;打包&lt;/h2&gt;

&lt;h3 id=&#34;对android项目打包&#34;&gt;对android项目打包&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;keytool&lt;/code&gt;生成签名文件,在任意目录下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -v -keystore my-release-key.keystore  -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面&lt;code&gt;my-release-key&lt;/code&gt;可以自己定义,后面的&lt;code&gt;my-key-alias&lt;/code&gt;也可以自己定义.运行后输入一下相关信息后,生成&lt;code&gt;my-release-key.keystore&lt;/code&gt;文件.&lt;/p&gt;

&lt;p&gt;其中输入的两次密码,需要记住.将这个文件移动到&lt;code&gt;android/app&lt;/code&gt;目录下,编译&lt;code&gt;android/app&lt;/code&gt;里的&lt;code&gt;build.gradle&lt;/code&gt;,添加下面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    ...
    defaultConfig { ... }
    signingConfigs {
        release {
            storeFile file(MYAPP_RELEASE_STORE_FILE)
            storePassword MYAPP_RELEASE_STORE_PASSWORD
            keyAlias MYAPP_RELEASE_KEY_ALIAS
            keyPassword MYAPP_RELEASE_KEY_PASSWORD
        }
    }
    ...
    buildTypes {
        release {
              ...
              signingConfig signingConfigs.release
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;android&lt;/code&gt;目录下运行如下命令,就可以打包,安装到自己手机上,前提是手机已usb调试连接到电脑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew assembleRelease
cd app/build/outputs/apk
adb install -r app-release.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://facebook.github.io/react-native/docs/signed-apk-android.html&#34;&gt;https://facebook.github.io/react-native/docs/signed-apk-android.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>都有哪些坑</title>
      <link>http://blog.suconghou.cn/post/some-hole/</link>
      <pubDate>Thu, 07 Jul 2016 15:46:03 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/some-hole/</guid>
      <description>

&lt;h2 id=&#34;总结一下遇到的坑&#34;&gt;总结一下遇到的坑&lt;/h2&gt;

&lt;h3 id=&#34;微信&#34;&gt;微信&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;关于横竖屏的坑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;css3可以使用媒体查询判断设备是横屏还是竖屏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//横屏时显示
@media all and (orientation : landscape) {
#screenMask{display:block}
}

//竖屏时隐藏
@media all and (orientation : portrait) {
#screenMask{display:none}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在手机浏览器中表现良好,微信中看样子也可以,但是微信网页中如果聚焦输入框,弹起键盘就有问题了.&lt;/p&gt;

&lt;p&gt;软键盘弹起后,网页可用面积减小,安卓就自动识别为横屏了,原有的页面消失了,影响非常大.IOS则没有这个问题,媒体查询判断横竖屏在IOS上工作良好.&lt;/p&gt;

&lt;p&gt;并且由此发现,css3媒体查询就是根据宽度是否比高度小来判断横竖屏的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方案1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;javascript&lt;/code&gt;的&lt;code&gt;orientation&lt;/code&gt;和&lt;code&gt;orientationchange&lt;/code&gt;判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;window.orientation   属于window对象上一个属性；共有三个值 ：0为竖屏模式（portrait）,90为向左反转变为横屏模式（landscape），-90为向右反转变为横屏模式（landscape），最后180就是设备上下互换还是竖屏模式。&lt;/li&gt;
&lt;li&gt;orientationchange    是一个event，在设备旋转时，会触发此事件，如同PC上使用的resize事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var init = function(){
        var updateOrientation = function(){
            var orientation = window.orientation;
            switch(orientation){
                case 90:
                case -90:
                    orientation = &#39;landscape&#39;;
                    break;
                default:
                    orientation = &#39;portrait&#39;;
                    break;
            }

           //do something
           //比如在html标签加一个状态
            //然后根据不同状态，显示不同大小
            document.body.parentNode.setAttribute(&#39;class&#39;,orientation);
        };

        window.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        updateOrientation();
    };

    window.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试使用JS判断能够正确得出安卓微信客户端里输入框聚焦时的横竖屏状态.&lt;/p&gt;

&lt;p&gt;orientation和orientationchange只有移动设备有这些属性和事件.&lt;/p&gt;

&lt;p&gt;在不支持这种属性和事件的设备上使用宽高比来判断做一下兼容,这样在不支持&lt;code&gt;orientation&lt;/code&gt;的设备上就相当于使用了媒体查询&lt;/p&gt;

&lt;p&gt;最终总结代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(w)
{
    var supportOrientation = (typeof w.orientation === &#39;number&#39; &amp;amp;&amp;amp; typeof w.onorientationchange === &#39;object&#39;);
    var init = function()
    {
        var htmlNode = document.body.parentNode, orientation;
        var updateOrientation = function()
        {
            if(supportOrientation)
            {
                orientation = w.orientation;
                switch(orientation)
                {
                    case 90:
                    case -90:
                        orientation = &#39;landscape&#39;;
                        break;
                    default:
                        orientation = &#39;portrait&#39;;
                        break;
                }
            }
            else
            {
                orientation = (w.innerWidth &amp;gt; w.innerHeight) ? &#39;landscape&#39; : &#39;portrait&#39;;
            }
            htmlNode.setAttribute(&#39;class&#39;,orientation);
        };
        if(supportOrientation)
        {
            w.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        }
        else
        {
            //监听resize事件
            w.addEventListener(&#39;resize&#39;,updateOrientation,false);
        }
        updateOrientation();
    };
    w.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以访问如下网址测试: /html/wx&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP最佳实践</title>
      <link>http://blog.suconghou.cn/post/php-best-way/</link>
      <pubDate>Thu, 30 Jun 2016 16:40:13 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/php-best-way/</guid>
      <description>

&lt;h2 id=&#34;性能优化&#34;&gt;性能优化&lt;/h2&gt;

&lt;h3 id=&#34;数组相关&#34;&gt;数组相关&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;in_array&lt;/code&gt;在大数据量(数万以上元素)下效率低下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在分析nginx log得出所有不重复IP时,采用&lt;code&gt;in_array&lt;/code&gt;判断,50多万的数据耗时需要五六分钟,而采用存键的方法,用&lt;code&gt;isset&lt;/code&gt;判断仅需要十几秒,效率差别非常大. [php7环境下]&lt;/p&gt;

&lt;p&gt;判断一个数组是否存在某个元素,远比查找一个键消耗的要多.前者时间复杂度O(n),而后者O(1)&lt;/p&gt;

&lt;p&gt;即时使用&lt;code&gt;in_array&lt;/code&gt;,也需要加上第三个参数,设置为严格模式,省略数据类型转化的开销,设置为&lt;code&gt;true&lt;/code&gt;比设置为&lt;code&gt;false&lt;/code&gt;性能要提升好几倍.&lt;/p&gt;

&lt;p&gt;这种情况下使用&lt;code&gt;array_search&lt;/code&gt;情况比&lt;code&gt;in_array&lt;/code&gt;更加糟糕&lt;/p&gt;

&lt;p&gt;如果条件允许使用&lt;code&gt;array_flip&lt;/code&gt;交换键值,在用&lt;code&gt;isset&lt;/code&gt;来判断要比&lt;code&gt;in_array&lt;/code&gt;好得多&lt;/p&gt;

&lt;p&gt;同时,使用&lt;code&gt;isset&lt;/code&gt;来判断数组的键,也比使用&lt;code&gt;array_key_exists&lt;/code&gt;要好&lt;/p&gt;

&lt;p&gt;而对于本题,还可以使用&lt;code&gt;array_unique&lt;/code&gt;最后去重,用空间换时间,效率仅次于用&lt;code&gt;isset&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;bugs&#34;&gt;Bugs&lt;/h2&gt;

&lt;h3 id=&#34;php-pdo-mysql-server-has-gone-away&#34;&gt;php pdo &lt;code&gt;MySQL server has gone away&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在使用PDO长连接时,执行过一次PDO初始化后,php-fpm进程会与mysql server开启一条TCP长连接,下次连接数据库就能加快速度.&lt;/p&gt;

&lt;p&gt;但是却存在一定问题,PDO维持了长连接并没有较好的检测其可用性,如果mysql server kill 掉这个连接,或者mysql重启,都会造成&lt;/p&gt;

&lt;p&gt;重新实例化PDO时得到旧的链接,导致出现&lt;code&gt;MySQL server has gone away&lt;/code&gt;,更让人郁闷的是这个错误并不是一个Exception,无法被catch捕获,即使设置&lt;code&gt;PDO::ATTR_ERRMODE=&amp;gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt;,也不行,还是直接在页面上提示.&lt;/p&gt;

&lt;p&gt;如果你使用了&lt;code&gt;set_error_handler&lt;/code&gt;,那么这个&lt;code&gt;Warning&lt;/code&gt;将会被捕捉,不会直接显示在页面上,但也改变了程序的原有执行逻辑.&lt;/p&gt;

&lt;p&gt;如果你不使用&lt;code&gt;set_error_handler&lt;/code&gt;,页面上报出&lt;code&gt;Warning&lt;/code&gt;,但其实PDO已经返回一个可用的链接了.&lt;/p&gt;

&lt;p&gt;猜测可能是PDO首先得到了不可用的然后报警告,然后又创建了一个新的.&lt;/p&gt;

&lt;p&gt;较好的解决方法是设置&lt;code&gt;set_error_handler&lt;/code&gt;若捕获了这个&lt;code&gt;MySQL server has gone away&lt;/code&gt;,则返回null,程序继续按原有逻辑执行.&lt;/p&gt;

&lt;p&gt;或者不使用PDO长连接.&lt;/p&gt;

&lt;p&gt;注意,&lt;code&gt;set_error_handler&lt;/code&gt;返回false的话,这个错误还是会被交到上一级错误程序处理的.&lt;/p&gt;

&lt;h3 id=&#34;编码转换中的若干问题&#34;&gt;编码转换中的若干问题&lt;/h3&gt;

&lt;p&gt;我们经常会遇到将utf8编码字符转化为gbk编码的字符,例如生成csv表格,在windows上的cmd窗口输出文字,以及操作windows上的有关文件路径的操作都需要使用gbk编码.&lt;/p&gt;

&lt;p&gt;常使用&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $str);&lt;/code&gt;将utf8字符转为gbk&lt;/p&gt;

&lt;p&gt;这里 utf gbk 不区分大小写,也可以混写,不区分是&lt;code&gt;utf8&lt;/code&gt;还是&lt;code&gt;utf-8&lt;/code&gt;,都能都正常使用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk//ignore&#39;, $str);&lt;/code&gt; 加上&lt;code&gt;//ignore&lt;/code&gt;使有些字符无法装换时略过.&lt;/p&gt;

&lt;p&gt;但是&lt;code&gt;//ignore&lt;/code&gt;在php5.4及以下,和个别php5.6版本上无效,任然是报NOTICE错误.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	echo iconv(&#39;UTF8&#39;, &#39;GBK//IGNORE&#39;, &#39;l l l&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;code&gt;https://3v4l.org/7vCFW&lt;/code&gt; 和 &lt;code&gt;http://www.php.net/manual/en/function.iconv.php&lt;/code&gt;第一条评论&lt;/p&gt;

&lt;p&gt;可以考虑使用&lt;code&gt;$content = mb_convert_encoding($content, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;);&lt;/code&gt; 从UTF8转为GBK&lt;/p&gt;

&lt;p&gt;这样不会报错,不能装换的被替换为?,参数也是不区分大小写,utf8和utf-8&lt;/p&gt;

&lt;h3 id=&#34;filter-var-filter-validate-url&#34;&gt;filter_var FILTER_VALIDATE_URL&lt;/h3&gt;

&lt;p&gt;filter_var FILTER_VALIDATE_URL 中不能包含中文,包含中文被判定为false&lt;/p&gt;

&lt;h3 id=&#34;内存是拷贝还是内存引用&#34;&gt;内存是拷贝还是内存引用&lt;/h3&gt;

&lt;p&gt;例1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
echo intval(memory_get_usage()/1024);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
$b=$a;
$c=$a;
$d=$a;
echo intval(memory_get_usage()/1024);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
$b=$a.&#39;&#39;;
$c=$a.&#39;&#39;;
$d=$a.&#39;&#39;;
echo intval(memory_get_usage()/1024);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例1与例2,内存差距基本不大,例2与例3有较大差距,例3约为例2的3倍,但小于3倍&lt;/p&gt;

&lt;p&gt;一般数据类型&lt;/p&gt;

&lt;p&gt;php在内存上是写时拷贝,一个变量复制多份内存不会占用多份,只有变量被改变时才会新申请一份内存给此变量.&lt;/p&gt;

&lt;h3 id=&#34;memcached-中的问题&#34;&gt;Memcached 中的问题&lt;/h3&gt;

&lt;p&gt;如果你安装了php的&lt;code&gt;memcached&lt;/code&gt;扩展,但是&lt;code&gt;igbinary&lt;/code&gt;扩展没有被启用,&lt;/p&gt;

&lt;p&gt;会使得memcache存储简单数据类型没有问题,但是存储复杂数据类型,如数组等,便会出现问题,&lt;/p&gt;

&lt;p&gt;对一个复杂数据类型的set将会导致php worker进程崩溃,类似&lt;code&gt;[pool www] child 4573 exited on signal 5 (SIGTRAP) after 20.831438 seconds from start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;nginx将会收到类似&lt;code&gt;upstream prematurely closed connection while reading response header from upstream&lt;/code&gt;,用户看到的将是502错误.&lt;/p&gt;

&lt;p&gt;故启用&lt;code&gt;memcached&lt;/code&gt;时最好启用&lt;code&gt;igbinary&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;php-worker&#34;&gt;php worker&lt;/h3&gt;

&lt;p&gt;python 简单的空worker 消耗内存比php空worker更少,但是随着python&lt;code&gt;import&lt;/code&gt;的模块增加,消耗的内存也随之上升,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import&lt;/code&gt;大多数常用模块后,内存消耗较php稍大,php进程只有业务处理会波动内存,python的CPU占用明显比php高.&lt;/p&gt;

&lt;p&gt;但python有多线程,多线程下内存消耗也较少,都适合写一些worker,相比之下,node的worker占用较多内存,引入常用模块后内存更是占用更大,CPU占用也比PHP多,优点是异步可以媲美多线程&lt;/p&gt;

&lt;h3 id=&#34;domdocument-loadhtml-内存泄漏&#34;&gt;DOMDocument loadHTML 内存泄漏&lt;/h3&gt;

&lt;p&gt;在大量使用DOMDocument的loadHTML后,php的进程占用内存不断增长,最终内存泄漏被强行杀死.&lt;/p&gt;

&lt;p&gt;其实这是&lt;code&gt;libxml_use_internal_errors&lt;/code&gt;所引起的问题,&lt;code&gt;loadHTML&lt;/code&gt;产生的警告被内部收集,但没有清楚,所以一直堆积.&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;http://stackoverflow.com/questions/8379829/domdocument-php-memory-leak&#34;&gt;http://stackoverflow.com/questions/8379829/domdocument-php-memory-leak&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks libev</title>
      <link>http://blog.suconghou.cn/post/shadowsocks-libev/</link>
      <pubDate>Wed, 18 May 2016 17:37:16 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/shadowsocks-libev/</guid>
      <description>

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;yum update &amp;amp;&amp;amp; yum install -y zip unzip xz curl wget git gcc make zlib zlib-devel openssl openssl-devel
git clone https://github.com/shadowsocks/shadowsocks-libev.git
cd shadowsocks-libev
./configure --enable-static=yes
export CFLAGS=&amp;quot;-O3&amp;quot;
make -j4 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;GO语言版本的也十分方便哦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里提供一个基于&lt;code&gt;docker&lt;/code&gt;的go语言版本,&lt;a href=&#34;https://hub.docker.com/r/suconghou/shadowsocks/&#34;&gt;docker go shadowsocks&lt;/a&gt;,只有3.3MB
十分方便&lt;/p&gt;

&lt;p&gt;同时也含有libev版本的可供选择&lt;/p&gt;

&lt;h2 id=&#34;网络内核参数优化&#34;&gt;网络内核参数优化&lt;/h2&gt;

&lt;p&gt;修改&lt;code&gt;ulimit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vim /etc/security/limits.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加一下两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* soft nofile 51200
* hard nofile 51200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;KVM 和 XEN 可以修改内核,明显提升网络环境差的情况下的表现,使用&lt;code&gt;hybla&lt;/code&gt;控制算法,效果明显,能提速30%&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zoakerc.com/archives/optimize-shadowsocks-server-in-kvm-or-xen/&#34;&gt;https://www.zoakerc.com/archives/optimize-shadowsocks-server-in-kvm-or-xen/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OPENVZ只能修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.core.somaxconn = 4096
net.ipv4.tcp_syncookies = 1
net.netfilter.nf_conntrack_max = 64000
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用tcpdump与ngrep</title>
      <link>http://blog.suconghou.cn/post/tcpdump/</link>
      <pubDate>Mon, 16 May 2016 18:21:04 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/tcpdump/</guid>
      <description>

&lt;p&gt;各版本 &lt;code&gt;http://www.tcpdump.org/release/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装依赖 &lt;code&gt;yum install -y flex gcc make byacc&lt;/code&gt; or &lt;code&gt;apt-get install flex gcc make byacc wget bzip2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
wget http://www.tcpdump.org/release/libpcap-1.7.4.tar.gz
tar zxf libpcap-1.7.4.tar.gz
cd libpcap-1.7.4
./configure --prefix=/tmp/lib
make -j4 &amp;amp;&amp;amp; make install
cd ../
wget http://www.tcpdump.org/release/tcpdump-4.7.4.tar.gz
tar zxf tcpdump-4.7.4.tar.gz
cd tcpdump-4.7.4
./configure --prefix=/tmp  --disable-ipv6 CFLAGS=&#39;-O3 -I/tmp/lib/include&#39; LDFLAGS=&#39;-L/tmp/lib/lib/libpcap.a&#39;
make -j4
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后,位于&lt;code&gt;ls -lh /tmp/sbin/tcpdump&lt;/code&gt; &lt;code&gt;ldd&lt;/code&gt;查看此文件依赖较少,可直接复制到其他Linux上使用.&lt;/p&gt;

&lt;p&gt;采用&lt;code&gt;CFLAGS=&amp;quot;-O3&amp;quot;&lt;/code&gt;编译后为1.2MB&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tcpdump -h&lt;/code&gt; 查看版本号以及用法&lt;/p&gt;

&lt;p&gt;我编译好的tcpdump version 4.7.4&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/bin/tcpdump.xz&#34;&gt;http://share.suconghou.cn/bin/tcpdump.xz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也可以直接&lt;code&gt;yum install tcpdump&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用tcpdump&#34;&gt;使用tcpdump&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;-a 　　　将网络地址和广播地址转变成名字；&lt;/p&gt;

&lt;p&gt;-d 　　　将匹配信息包的代码以人们能够理解的汇编格式给出；&lt;/p&gt;

&lt;p&gt;-dd 　　 将匹配信息包的代码以c语言程序段的格式给出；&lt;/p&gt;

&lt;p&gt;-ddd 　　将匹配信息包的代码以十进制的形式给出；&lt;/p&gt;

&lt;p&gt;-e 　　　在输出行打印出数据链路层的头部信息；&lt;/p&gt;

&lt;p&gt;-f 　　　将外部的Internet地址以数字的形式打印出来；&lt;/p&gt;

&lt;p&gt;-l 　　　使标准输出变为缓冲行形式；&lt;/p&gt;

&lt;p&gt;-n 　　　不把网络地址转换成名字；&lt;/p&gt;

&lt;p&gt;-t 　　　在输出的每一行不打印时间戳；&lt;/p&gt;

&lt;p&gt;-v 　　　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；&lt;/p&gt;

&lt;p&gt;-vv 　　 输出详细的报文信息；&lt;/p&gt;

&lt;p&gt;-c 　　　在收到指定的包的数目后，tcpdump就会停止；&lt;/p&gt;

&lt;p&gt;-F 　　　从指定的文件中读取表达式,忽略其它的表达式；&lt;/p&gt;

&lt;p&gt;-i 　　　指定监听的网络接口；&lt;/p&gt;

&lt;p&gt;-r 　　　从指定的文件中读取包(这些包一般通过-w选项产生)；&lt;/p&gt;

&lt;p&gt;-w 　　　直接将包写入文件中，并不分析和打印出来；&lt;/p&gt;

&lt;p&gt;-T 　　　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;tcpdump host 210.27.48.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-A&lt;/code&gt;和&lt;code&gt;-X&lt;/code&gt;有助于你查看详细的报文数据&lt;/p&gt;

&lt;h2 id=&#34;ngrep&#34;&gt;ngrep&lt;/h2&gt;

&lt;p&gt;ngrep 编译总是出问题,建议直接安装:&lt;code&gt;apt-get install ngrep&lt;/code&gt; &lt;code&gt;yum install ngrep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果更关注于TCP流量内容,可以使用&lt;code&gt;ngrep&lt;/code&gt;,他是grep命令的网络版,同样需要libpcap库,能识别TCP、UDP和ICMP包，理解bpf的过滤机制&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngrep -W byline -d eno1 port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用-d指定网卡,使用&lt;code&gt;ifconfig&lt;/code&gt;可以查看网卡信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-e ：显示空数据包
-i ：忽略大小写
-v ：反转匹配
-R ：don&#39;t do privilege revocation logic
-x ：以16进制格式显示
-X ：以16进制格式匹配
-w ：整字匹配
-p ：不使用混杂模式
-l ：make stdout line buffered
-D ：replay pcap_dumps with their recorded time intervals
-t ：在每个匹配的包之前显示时间戳
-T ：显示上一个匹配的数据包之间的时间间隔
-M ：仅进行单行匹配
-I ：从文件中读取数据进行匹配
-O ：将匹配的数据保存到文件
-n ：仅捕获指定数目的数据包进行查看
-A ：匹配到数据包后dump随后的指定数目的数据包
-s ：set the bpf caplen
-S ：set the limitlen on matched packets
-W ：设置显示格式byline将解析包中的换行符
-c ：强制显示列的宽度
-q ：is be quiet (don’t print packet reception hash marks)静默模式，如果没有此开关，未匹配的数据包都以&amp;quot;#&amp;quot;显示
-P ：set the non-printable display char to what is specified
-F ：使用文件中定义的bpf(Berkeley Packet Filter)
-N ：显示由IANA定义的子协议号
-d ：使用哪个网卡，可以用-L选项查询
-L ：查询网卡接口

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要匹配关键字可以在-d参数之后, port 参数之前添加字符串匹配&lt;/p&gt;

&lt;p&gt;同时可以使用-i忽略大小写,-w整字匹配等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo ngrep  -W byline -d en0 -iw &amp;quot;easy&amp;quot;  port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以使用这种过滤 &lt;code&gt;host www.google.com and port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;具体使用见
&lt;a href=&#34;http://man.linuxde.net/ngrep&#34;&gt;http://man.linuxde.net/ngrep&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译安装Apache Traffic Server</title>
      <link>http://blog.suconghou.cn/post/use-apache-traffic-server/</link>
      <pubDate>Mon, 09 May 2016 22:24:14 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-apache-traffic-server/</guid>
      <description>

&lt;h2 id=&#34;编译安装&#34;&gt;编译安装&lt;/h2&gt;

&lt;p&gt;Centos下编译安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum update -y &amp;amp;&amp;amp; yum install wget gcc g++ gcc-c++ glibc-headers perl openssl openssl-devel tcl-devel libxml2-devel pcre-devel
wget http://apache.fayea.com/trafficserver/trafficserver-6.1.1.tar.bz2
tar xvjf trafficserver-6.1.1.tar.bz2
cd trafficserver-6.1.1
./configure
make &amp;amp;&amp;amp; make install
useradd -s /sbin/nologin trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache镜像&lt;a href=&#34;http://archive.apache.org/dist/&#34;&gt;http://archive.apache.org/dist/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;国内Apache镜像&lt;a href=&#34;http://apache.fayea.com/&#34;&gt;http://apache.fayea.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译完成后,就可以使用了,默认是安装在&lt;code&gt;/usr/local/bin&lt;/code&gt;,编译后是比较大&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total 98M
-rwxr-xr-x 1 root root 692K May  9 14:30 header_rewrite_test
-rwxr-xr-x 1 root root 520K May  9 14:30 traffic_cop
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_crashlog
-rwxr-xr-x 1 root root 259K May  9 14:30 traffic_ctl
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_layout
-rwxr-xr-x 1 root root  41K May  9 14:30 traffic_line
-rwxr-xr-x 1 root root 4.4M May  9 14:30 traffic_logcat
-rwxr-xr-x 1 root root 5.0M May  9 14:30 traffic_logstats
-rwxr-xr-x 1 root root 4.7M May  9 14:30 traffic_manager
-rwxr-xr-x 1 root root  37M May  9 14:30 traffic_sac
-rwxr-xr-x 1 root root  43M May  9 14:30 traffic_server
-rwxr-xr-x 1 root root  42K May  9 14:30 traffic_via
-rwxr-xr-x 1 root root  18K May  9 14:30 trafficserver
-rwxr-xr-x 1 root root 2.1K May  9 14:30 tspush
-rwxr-xr-x 1 root root 5.7K May  9 14:30 tsxs

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;code&gt;traffic_server -R 1&lt;/code&gt;执行测试,经过一系列测试后,显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tests Passed: 177
Tests Failed: 0
    REGRESSION_RESULT PARENTSELECTION:                          PASSED
REGRESSION_TEST DONE: PASSED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全部测试通过&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;默认的配置文件存放在&lt;code&gt;/usr/local/etc/trafficserver&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x 3 nobody nobody 1.0K May  9 14:30 body_factory
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 cache.config
-rw-r--r-- 1 nobody nobody  657 May  9 14:30 cluster.config
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 congestion.config
-rw-r--r-- 1 nobody nobody  746 May  9 14:30 hosting.config
-rw-r--r-- 1 nobody nobody 1.8K May  9 14:30 icp.config
-rw-r--r-- 1 nobody nobody 1.2K May  9 14:30 ip_allow.config
-rw-r--r-- 1 nobody nobody  328 May  9 14:30 log_hosts.config
-rw-r--r-- 1 nobody nobody  17K May  9 14:30 logs_xml.config
-rw-r--r-- 1 nobody nobody 1.4K May  9 14:30 parent.config
-rw-r--r-- 1 nobody nobody  261 May  9 14:30 plugin.config
-rw-r--r-- 1 nobody nobody  13K May  9 14:30 records.config
-rw-r--r-- 1 nobody nobody 8.6K May  9 14:30 remap.config
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 socks.config
-rw-r--r-- 1 nobody nobody 2.1K May  9 14:30 splitdns.config
-rw-r--r-- 1 nobody nobody 2.7K May  9 14:30 ssl_multicert.config
-rw-r--r-- 1 nobody nobody  76K May  9 14:30 stats.config.xml
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 storage.config
-rw-r--r-- 1 root   root     19 May  9 14:30 trafficserver-release
-rw-r--r-- 1 nobody nobody  649 May  9 14:30 vaddrs.config
-rw-r--r-- 1 nobody nobody 1.3K May  9 14:30 volume.config

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;records.config&lt;/code&gt;负责大部分全局的选项设置，即主要配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG proxy.config.reverse_proxy.enabled INT 1                           # 开启反向代理
CONFIG proxy.config.url_remap.remap_required INT 1                        # 1 代理反向代理，0代表正向+反向代理
CONFIG proxy.config.http.cache.http INT 1                                 # 打开http缓存功能
CONFIG proxy.config.cache.ram_cache.size INT 512M                         # RAM 缓存大小
CONFIG proxy.config.http.keep_alive_no_activity_timeout_out INT 120       # 当一个事务结束后同原服务器保持连接的时间
CONFIG proxy.config.cluster.ethernet_interface STRING eth0                # 修改成需要侦听的interface名称

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;remap.config&lt;/code&gt;定义映射规则，用于请求的重定向（rewrite）,反向代理即在此配置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;storage.config&lt;/code&gt; 用于指定磁盘存储&lt;/p&gt;

&lt;p&gt;启动&lt;code&gt;trafficserver start&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;varnish编译&#34;&gt;varnish编译&lt;/h3&gt;

&lt;p&gt;alpine中编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk update &amp;amp;&amp;amp; apk upgrade
apk --update add gcc g++ make wget curl m4 automake autoconf libtool linux-headers py-docutils ncurses-dev pcre-dev libedit-dev
cd /tmp
VARNISH_VERSION=varnish-4.1.3
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget https://repo.varnish-cache.org/source/${VARNISH_VERSION}.tar.gz
tar xzf ${VARNISH_VERSION}.tar.gz
cd ${VARNISH_VERSION}
./configure
make CFLAGS=&amp;quot;-Os&amp;quot; CPPFLAGS=-D__NEED_mode_t -j$CPU_NUM &amp;amp;&amp;amp; make install
strip -s /usr/local/bin/* /usr/local/sbin/* /usr/local/lib/varnish/*.so /usr/local/lib/varnish/vmods/*.so
varnishd  -V
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varnish基本使用&#34;&gt;varnish基本使用&lt;/h4&gt;

&lt;p&gt;varnish / squid / nginx 优缺点讨论 见 &lt;a href=&#34;http://www.zhihu.com/question/20143441&#34;&gt;http://www.zhihu.com/question/20143441&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在树莓派上使用Docker</title>
      <link>http://blog.suconghou.cn/post/use-docker-on-raspberry/</link>
      <pubDate>Sun, 08 May 2016 20:01:56 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-docker-on-raspberry/</guid>
      <description>

&lt;h2 id=&#34;安装支持docker的系统&#34;&gt;安装支持Docker的系统&lt;/h2&gt;

&lt;p&gt;树莓派官方系统并不支持Docker,需要安装.&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;集成Dcoker的树莓派系统&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -s 50 -c https://downloads.hypriot.com/hypriotos-rpi-v0.8.0.img.zip


diskutil list
diskutil unmountdisk /dev/disk2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用以下命令前必须卸载u盘&lt;code&gt;diskutil unmountdisk /dev/disk2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=hypriotos-rpi-v0.8.0.img of=/dev/disk2 bs=8k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成重启就可以啦,启动后登陆的用户是pirate,密码hypriot&lt;/p&gt;

&lt;p&gt;修改密码:执行&lt;code&gt;passwd&lt;/code&gt;,输入当前密码,输入新密码,再输入新密码,更新完成&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;exit&lt;/code&gt;退出,或者&lt;code&gt;sudo reboot&lt;/code&gt;重启&lt;/p&gt;

&lt;p&gt;创建用户:&lt;code&gt;useradd -g test -d /home/test1 -s /etc/bash -m test1&lt;/code&gt;
注解：-g 所属组 -d 家目录 -s 所用的SHELL
passwd abc&lt;/p&gt;

&lt;p&gt;获得sudo权限:编辑&lt;code&gt;/etc/sudoers&lt;/code&gt; 加入新添加的用户名&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux相关操作</title>
      <link>http://blog.suconghou.cn/post/linux/</link>
      <pubDate>Thu, 21 Jan 2016 13:40:53 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux/</guid>
      <description>

&lt;h2 id=&#34;linux用户管理&#34;&gt;Linux用户管理&lt;/h2&gt;

&lt;h3 id=&#34;添加用户adduser&#34;&gt;添加用户adduser&lt;/h3&gt;

&lt;p&gt;假如用户名为&lt;code&gt;work&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;adduser work -M&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;修改密码&#34;&gt;修改密码&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;passwd work&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;linux实用命令&#34;&gt;Linux实用命令&lt;/h2&gt;

&lt;h2 id=&#34;w&#34;&gt;w&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;w&lt;/code&gt;命令能容清晰的显示,服务器在线时间,负载以及当前登陆的用户&lt;/p&gt;

&lt;h2 id=&#34;vmstat&#34;&gt;vmstat&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 显示开机以来的平均值，而不是前一秒的值
&lt;code&gt;vmstat 1&lt;/code&gt;命令指定一个参数 1 运行，来打印每一秒的统计摘要.
这些列代表的信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;r：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：&amp;rdquo;r&amp;rdquo;的值大于了 CPU 的数量就表示已经饱和了。
free：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。&amp;rdquo;free -m&amp;rdquo; 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。
si, so：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。
us, sy, id, wa, st：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。
对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。&lt;/p&gt;

&lt;p&gt;SIZE(VIRT): 进程使用的地址空间, 如果进程映射了100M的内存, 进程的地址空间将报告为100M内存. 事实上, 这个大小不是一个程序实际使用的内存数.&lt;/p&gt;

&lt;p&gt;RSS(RES): &amp;ldquo;Resident Set Size&amp;rdquo;, 实际驻留&amp;rdquo;在内存中&amp;rdquo;的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.&lt;/p&gt;

&lt;p&gt;SHARE(SHR): RSS中与其它进程共享的内存部分大小.&lt;/p&gt;

&lt;p&gt;VMSIZE: 一个进程占用的总的地址空间大小. 它包括了没有映射到内存中的页面。&lt;/p&gt;

&lt;p&gt;SZ（DATA）: 映射到内存中的页面, 这些页面仅由进程单独使用. 这也是我们最关心地方: 进程实际占用的内存数。&lt;/p&gt;

&lt;h2 id=&#34;top&#34;&gt;top&lt;/h2&gt;

&lt;h2 id=&#34;free&#34;&gt;free&lt;/h2&gt;

&lt;h2 id=&#34;ssh&#34;&gt;ssh&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub root@host&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub -p 26671 root@host&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pgrep&#34;&gt;pgrep&lt;/h2&gt;

&lt;p&gt;根据名字或其他属性查询出进程的PID&lt;/p&gt;

&lt;p&gt;如:&lt;code&gt;pgrep nginx -fl&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pkill&#34;&gt;pkill&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;pgrep&lt;/code&gt;类似,不同的是向进程发送信号,默认发送&lt;code&gt;SIGTERM&lt;/code&gt;信号,查看都有哪些信号可用,可以使用&lt;code&gt;kill -l&lt;/code&gt;查看&lt;/p&gt;

&lt;p&gt;类似&lt;code&gt;pkill&lt;/code&gt;的命令是&lt;code&gt;killall&lt;/code&gt;,后面都是可以直接加进程名字批量杀死进程&lt;/p&gt;

&lt;h2 id=&#34;pstree&#34;&gt;pstree&lt;/h2&gt;

&lt;p&gt;用树的形式显示正在运行的进程,树的节点为指定的PID(忽略则为init进程)&lt;/p&gt;

&lt;h2 id=&#34;ss&#34;&gt;ss&lt;/h2&gt;

&lt;p&gt;用于显示socket的统计信息,&lt;code&gt;-s&lt;/code&gt;用于显示汇总&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt;用于列出正在监听的&lt;code&gt;socket&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;显示进程信息,&lt;code&gt;ss -pl&lt;/code&gt; 可以查看使用网络端口的进程名字&lt;/p&gt;

&lt;h2 id=&#34;磁盘相关&#34;&gt;磁盘相关&lt;/h2&gt;

&lt;h3 id=&#34;dd&#34;&gt;dd&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dd&lt;/code&gt;把指定的输入文件拷贝到指定的输出文件中,并且在拷贝的过程中可以进行格式转换。&lt;/p&gt;

&lt;p&gt;if =输入文件(或设备名称)
of =输出文件(或设备名称)
bs = bytes 同时设置读/写缓冲区的字节数(等于设置obs和obs)
count = blocks 只拷贝输入的blocks块&lt;/p&gt;

&lt;p&gt;创建一个100M的空文件
&lt;code&gt;dd if=/dev/zero of=hello.txt bs=100m count=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小&#34;&gt;查看当前目录下所有一级子目录文件夹大小&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小-并排序&#34;&gt;查看当前目录下所有一级子目录文件夹大小 并排序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1 |sort&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上两条命令不适用于MacOs,可以使用&lt;code&gt;du -sh *&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;ps&lt;/h2&gt;

&lt;p&gt;ps ef  查看进程的状态&lt;/p&gt;

&lt;p&gt;ps auxw 查看进程的CPU,内存占用&lt;/p&gt;

&lt;p&gt;ps 默认是按照PID排序的,若要按内存使用排序&lt;code&gt;ps auxw --sort=rss&lt;/code&gt;,同理按虚拟内存排序&lt;code&gt;ps auxw --sort=vsz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mac上无法使用&lt;code&gt;--sort&lt;/code&gt;,可以采用&lt;code&gt;sort&lt;/code&gt;排序,如rss在第六列,则&lt;code&gt;ps auxw | sort -k6,6n&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;nc&#34;&gt;nc&lt;/h2&gt;

&lt;p&gt;nc 命令默认没有安装,需要自己安装,&lt;code&gt;yum install nc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;传送字符与文件&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc -l 9090&lt;/code&gt;监听端口9090&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc host 9090&lt;/code&gt;连接host的9090端口,通信建立后,可以双向通信,实现文字聊天等,也可以传送文件&lt;/p&gt;

&lt;p&gt;一端&lt;code&gt;nc -l 9090 &amp;gt; file&lt;/code&gt; ,另一端发送文件&lt;code&gt;nc host 9090 &amp;lt; file&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;传送文件夹(压缩文件) &lt;code&gt;nc -l 9090 |tar xzvf -&lt;/code&gt; , 另一端发送文件&lt;code&gt;tar czvf – dir | nc host 9090&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;同样可以拷贝硬盘 &lt;code&gt;nc -l 9090 | dd of=/dev/sda&lt;/code&gt;,另一端发送&lt;code&gt;dd if=/dev/sda | nc host 9090&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端口扫描&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;nc -vz -w 1 someIp 1-1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;模拟调试http请求&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;GET / HTTP/1.0&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;端口转发&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用之前需要了解其他的命令&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tee&lt;/code&gt;命令将标准输入的数据写入标准输出和tee命令指定的文件参数&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkfifo&lt;/code&gt;命令用于创建一个FIFO（先进先出）方式的命名管道&lt;/p&gt;

&lt;p&gt;标准流:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;stdin	0
stdout	1
stderr	2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;** listener-to-client模式(用于外网访问内网) **&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;http://onestraw.net/cybersecurity/netcat-advanced-usage/&#34;&gt;http://onestraw.net/cybersecurity/netcat-advanced-usage/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;一份linux别名和函数库&#34;&gt;一份Linux别名和函数库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;alias tree=&amp;quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39; &amp;quot;;
alias cls=&amp;quot;cd $1;ls -lh;&amp;quot;;
# 获得你的公网IP地址和主机名。
alias ipinfo=&amp;quot;curl ifconfig.me &amp;amp;&amp;amp; curl ifconfig.me/host&amp;quot;;
# 显示出哪个应用程序连接到网络。
alias listen=&amp;quot;lsof -P -i -n&amp;quot;;
# 显示出活动的端口。
alias port=&#39;netstat -uanltp&#39;
# 统计TCP连接个数
alias tcpstatus=&amp;quot;netstat -n|awk &#39;/^tcp/{++S[\$NF]} END {for(a in S) print a,S[a]}&#39;&amp;quot;
# 回到上层目录
alias ..=&#39;cd ..&#39;
# 去到上两层目录
alias ...=&#39;cd ../..&#39;
# 按列格式化输出mount信息。
alias cmount=&amp;quot;mount | column -t&amp;quot;
# 查看你还有剩下多少内存
alias meminfo=&#39;free -m -l -t&#39;
# 按照文件在磁盘存储的大小排序，显示当前目录的文件列表。
sbs() { du -b --max-depth 1 | sort -nr | perl -pe &#39;s{([0-9]+)}{sprintf &amp;quot;%.1f%s&amp;quot;, $1&amp;gt;=2**30? ($1/2**30, &amp;quot;G&amp;quot;): $1&amp;gt;=2**20? ($1/2**20, &amp;quot;M&amp;quot;): $1&amp;gt;=2**10? ($1/2**10, &amp;quot;K&amp;quot;): ($1, &amp;quot;&amp;quot;)}e&#39;;}
# 找出指定目录中最大的10个文件
largefile() { find . -type f -exec du -k {} \; | sort  -nrk 1 | head; }
# 查看当前目录大于[多少]kb的文件,速度更快
bigthan() { size=${1:-100}; find . -type f -size +&amp;quot;$size&amp;quot;k |xargs  ls  -lh ; }
# 返回你的当前IP地址的地理位置。
getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep &#39;city|state|country&#39;|awk &#39;{print $3,$4,$5,$6,$7,$8}&#39;|sed &#39;s\ip address flag \\&#39;|sed &#39;s\My\\&#39;;}
# 删除.log.1.gz 或者 .log.1.bz2
delog(){ ls | grep &amp;quot;log.\d\+.\(bz2\|gz\)&amp;quot; | xargs rm}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 这几个Mac不兼容
# 查看最占用内存的前五个进程(根据第几列可修改k6)
topmem()
{
	ps aux | sort -k6nr | head -n5;
}
# 查看某一程序占用的内存
mem()
{
    top -n1 -b | head -n7 | sed &#39;1,6d&#39; &amp;amp;&amp;amp; top -n1 -b | sed &#39;1,7d&#39; | grep --color=auto $1;
    ps aux | grep --color=auto $1 | grep --color=auto -v grep | awk -F &amp;quot; &amp;quot; &#39;{ sum += $6 } END { printf &amp;quot;Total Memory Usage: %.1f MB\n&amp;quot;, sum/1024 }&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;部分快捷键&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
CTRL + U -剪切光标前的内容

CTRL + K -剪切光标至行末的内容

CTRL + Y -粘贴

CTRL + E -移动光标到行末

CTRL + A -移动光标到行首

ALT + F -跳向下一个空格

ALT + B -跳回上一个空格

ALT + Backspace -删除前一个单词

CTRL + W -剪切光标后一个单词

Shift + Insert -向终端内粘贴文本

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;压缩率 xz &amp;gt; 7z &amp;gt; bzip2 &amp;gt; gzip &amp;gt; zip&lt;/p&gt;

&lt;p&gt;gzexe 创建自解压文件&lt;/p&gt;

&lt;p&gt;xz5.2以上版本支持多线程压缩,xz -T0 就可以自动按机器线程数多线程执行了,xz 支持 env 环境变量，XZ_OPT=-T0 xz xxx.file 就行啦&lt;/p&gt;

&lt;p&gt;多线程的压缩速度几乎与gzip相当&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# 查看你机器的CPU个数,超线程信息
sysinfo() {
physicalNumber=0
coreNumber=0
logicalNumber=0
HTNumber=0
logicalNumber=$(grep &amp;quot;processor&amp;quot; /proc/cpuinfo|sort -u|wc -l)
physicalNumber=$(grep &amp;quot;physical id&amp;quot; /proc/cpuinfo|sort -u|wc -l)
coreNumber=$(grep &amp;quot;cpu cores&amp;quot; /proc/cpuinfo|uniq|awk -F&#39;:&#39; &#39;{print $2}&#39;|xargs)
HTNumber=$((logicalNumber / (physicalNumber * coreNumber)))
echo &amp;quot;****** CPU Information ******&amp;quot;
echo &amp;quot;Logical CPU Number  : ${logicalNumber}&amp;quot;
echo &amp;quot;Physical CPU Number : ${physicalNumber}&amp;quot;
echo &amp;quot;CPU Core Number     : ${coreNumber}&amp;quot;
echo &amp;quot;HT Number           : ${HTNumber}&amp;quot;
echo &amp;quot;*****************************&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用脚本清理一些文件&#34;&gt;使用脚本清理一些文件&lt;/h2&gt;

&lt;p&gt;删除当前目录超过30天未变动过的log文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; | xargs rm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; -exec rm -i {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的操作都包含子目录&lt;/p&gt;

&lt;p&gt;-exec  参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&lt;/p&gt;

&lt;p&gt;{}   花括号代表前面find查找出来的文件名。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -type f -exec ls -l {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -name &amp;quot;*.log&amp;quot; -mtime +60 -ok rm {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-mtime +30 设定时间为30天前&lt;/p&gt;

&lt;p&gt;-type f 查找的类型为文件&lt;/p&gt;

&lt;p&gt;-name 文件路径需要匹配的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用全文查找&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;grep -lr &amp;lsquo;string&amp;rsquo; /etc/&lt;/p&gt;

&lt;p&gt;这个命令就可以搞定。搜索etc下面的文件，包含所有目录下的文件。这样就搞定了。&lt;/p&gt;

&lt;p&gt;-i，乎略大小写
-l，找出含有这个字符串的文件
-r，不放过子目录&lt;/p&gt;

&lt;h2 id=&#34;解决can-t-set-the-locale-make-sure-lc-and-lang-are-correct&#34;&gt;解决can&amp;rsquo;t set the locale; make sure $LC_* and $LANG are correct&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&#34;&gt;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&lt;/a&gt;
&lt;code&gt;照着全部做下来&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;vim乱码解决&#34;&gt;Vim乱码解决&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vim ~/.vimrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;开机启动的&#34;&gt;开机启动的&lt;/h2&gt;

&lt;p&gt;检视和控制systemd的主要命令是systemctl&lt;/p&gt;

&lt;p&gt;详细使用见&lt;a href=&#34;https://wiki.archlinux.org/index.php/systemd_(简体中文)&#34;&gt;https://wiki.archlinux.org/index.php/systemd_(简体中文)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CentOS7 用&lt;code&gt;systemctl&lt;/code&gt;取代了&lt;code&gt;service&lt;/code&gt;
旧版本的 &lt;code&gt;service docker start&lt;/code&gt; 改为&lt;code&gt;systemctl start docker&lt;/code&gt;
设置开机启动
旧版本的 &lt;code&gt;chkconfig docker on&lt;/code&gt; 改为 &lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/systemd/system/&lt;/code&gt;
&lt;code&gt;/etc/systemd/system/&lt;/code&gt;
后者有较高优先级会覆盖前者&lt;/p&gt;

&lt;p&gt;/etc/profile 和 ~/.bash_profile 是在启动 一个交互登陆shell的时候 被调用。
/etc/bashrc 和 ~/.bashrc 是在一个交互的非登陆shell启动 的时候 被调用。
~/.bash_logout 在用户注销登陆的时候 被读取&lt;/p&gt;

&lt;p&gt;系统脚本 可以放置在/etc/rc.d/init.d中并建立/etc/rc.d/rc?.d链接，也可以直接放置在/etc/rc.d/rc.local中。
init.d脚本 包含完整的start,stop,status,reload等参数，是标准做法，推荐使用。&lt;/p&gt;

&lt;h2 id=&#34;linux-家族&#34;&gt;Linux 家族&lt;/h2&gt;

&lt;p&gt;一般来说著名的linux系统基本上分两大类：&lt;/p&gt;

&lt;p&gt;1.RedHat系列：Redhat、Centos、Fedora等&lt;/p&gt;

&lt;p&gt;2.Debian系列：Debian、Ubuntu等
RedHat 系列
1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 yum&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;Debian系列
1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 apt-get&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;soft rlimits too low. Number of files is 256, should be at least 1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;https://www.fdzh.org/slides/2015/06/20/linux-distr/&#34;&gt;https://www.fdzh.org/slides/2015/06/20/linux-distr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://static.suconghou.cn/document/linux.jpg&#34; alt=&#34;家族示意图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;判断一个命令是否存在&#34;&gt;判断一个命令是否存在&lt;/h2&gt;

&lt;p&gt;如判断&lt;code&gt;nc&lt;/code&gt;是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command -v nc &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || { echo &amp;gt;&amp;amp;2 &amp;quot;I require nc but it&#39;s not installed.  Aborting.&amp;quot;; exit 1; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if ! command -v pip &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then
    echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;PIP=$(which pip)
if [ ! -x &amp;quot;${PIP}&amp;quot; ];then
	echo &amp;quot;NO&amp;quot;
else
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[[ ! -x $(which pip) ]] &amp;amp;&amp;amp; echo &amp;quot;No&amp;quot; || echo &amp;quot;Yes&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if (( ${+commands[pip]} )); then
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;判断一个进程pid是否还存在&#34;&gt;判断一个进程PID是否还存在&lt;/h2&gt;

&lt;p&gt;例如检查pid为143的进程 &lt;code&gt;ps ax | awk &#39;{ print $1 }&#39; | grep -e &amp;quot;^143$&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;shell基本语法&#34;&gt;Shell基本语法&lt;/h2&gt;

&lt;p&gt;声明数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arr=(item1 item2 item3)&lt;/code&gt; 使用空格分开&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;echo ${arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${arr[@]}&lt;/code&gt; 可以查看数组内的元素,&lt;code&gt;echo $arr&lt;/code&gt;只能取得第一个元素&lt;/p&gt;

&lt;p&gt;要取得数组长度,只需在名字前面加一个#,如&lt;code&gt;echo ${#arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${#arr[@]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;数组下标以0开始,取得第二个元素为&lt;code&gt;echo ${arr[1]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;赋值使用&lt;code&gt;arr[5]=5555&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>玩转树莓派</title>
      <link>http://blog.suconghou.cn/post/play-with-raspberrypi/</link>
      <pubDate>Sun, 17 Jan 2016 22:21:49 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/play-with-raspberrypi/</guid>
      <description>

&lt;h2 id=&#34;安装其他操作系统&#34;&gt;安装其他操作系统&lt;/h2&gt;

&lt;h3 id=&#34;centos&#34;&gt;CentOS&lt;/h3&gt;

&lt;p&gt;CentOS7官方支持了AMRV7发布了树莓派2、香蕉派、以及CubitTruck单片机的版本&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mirror.centos.org/altarch/7/isos/armhfp/&#34;&gt;CentOS7官方下载&lt;/a&gt;
root 密码 centos&lt;/p&gt;

&lt;h3 id=&#34;archlinux&#34;&gt;ArchLinux&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://archlinuxarm.org/platforms/armv7/broadcom/raspberry-pi-2&#34;&gt;armv7 raspberry-pi-2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://archlinuxarm.org/platforms/armv6/raspberry-pi&#34;&gt;armv6 raspberry-pi&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装osmc&#34;&gt;安装OSMC&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://software.opensuse.org/download.html?project=home:osmc&amp;amp;package=osmc-installer&amp;amp;hcolor=17394a&amp;amp;fcolor=17394a&amp;amp;acolor=17394a&#34;&gt;osmc-installer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或者安装OSMC转为树莓派制作的系统&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://osmc.tv/download/&#34;&gt;下载一览&lt;/a&gt;,选择&lt;code&gt;Disk images&lt;/code&gt;,此系统较省资源,默认开机进入OSMC,img.gz 大小约160M&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OSMC_FILE=OSMC_TGT_rbp2_20160621.img.gz
cd /data/tmp
axel -n 20 http://download.osmc.tv/installers/diskimages/$OSMC_FILE
md5sum $OSMC_FILE
ls -lh
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;使用清华大学镜像站国内下载速度更快: &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/osmc/osmc/download/installers/&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/osmc/osmc/download/installers/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;插入内存卡,开始烧写到内存卡中.烧写之前需要取消挂载&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diskutil list&lt;/code&gt; 查看你的内存卡的挂载位置,取消挂载&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;diskutil unmountdisk /dev/disk2&lt;/code&gt; 取消挂载,需要稍等一小会.&lt;/p&gt;

&lt;p&gt;烧写,烧写过程中读卡器不断闪烁.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip -dc /data/tmp/$OSMC_FILE | sudo dd of=/dev/disk2 bs=8k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dd的用法: &lt;code&gt;dd if=/dev/zero of=hello.txt bs=1024&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;dd过程中看不到进度,如果确实想要了解进度,可以再开一个终端&lt;code&gt;pkill -USR1 -n -x dd&lt;/code&gt;查看进度.&lt;/p&gt;

&lt;p&gt;如果是iso文件,需要装换为img文件,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;hdiutil convert -format UDRW -o /path/to/generate/img/file /path/to/your/iso/file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;mac osx会默认追加一个.dmg,这个没有影响,然后就可以使用dd写入这个img文件了.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diskutil eject /dev/disk1&lt;/code&gt; 弹出USB,注意和卸载(&lt;code&gt;unmountdisk&lt;/code&gt;)是不同的&lt;/p&gt;

&lt;p&gt;除了OSMC默认皮肤,还有一些好看的皮肤推荐&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;http://forum.kodi.tv/showthread.php?tid=187071&#34;&gt;Eminence&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;http://forum.kodi.tv/showthread.php?tid=214146&#34;&gt;Bello&lt;/a&gt; 看github,支持中文&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://forum.kodi.tv/forumdisplay.php?fid=26&#34;&gt;官方论坛&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OSMC默认的ssh连接用户是 osmc 密码 osmc&lt;/p&gt;

&lt;h2 id=&#34;安装openelec&#34;&gt;安装openelec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://openelec.tv/get-openelec&#34;&gt;openelec&lt;/a&gt; 镜像下载,osmc是基于debain的,系统更加完善.此系统相比osmc更加精简,是专为跑kodi精简的系统. img.gz 大小约102M&lt;/p&gt;

&lt;h2 id=&#34;安装xbian&#34;&gt;安装xbian&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.xbian.org/&#34;&gt;http://www.xbian.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;与openelec,osmc都是类似,img.gz较大,大约316MB&lt;/p&gt;

&lt;h2 id=&#34;安装chromeos&#34;&gt;安装ChromeOs&lt;/h2&gt;

&lt;p&gt;ChromeOs已经有支持树莓派的版本了,&lt;a href=&#34;www.chromiumosforsbc.org&#34;&gt;www.chromiumosforsbc.org&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用镜像加速homebrew</title>
      <link>http://blog.suconghou.cn/post/homebrew-speedup/</link>
      <pubDate>Fri, 15 Jan 2016 12:56:53 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/homebrew-speedup/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://mirrors.ustc.edu.cn/&#34;&gt;中国科大镜像站&lt;/a&gt; 提供 Debian, Ubuntu, Fedora, Archlinux, CentOS 等多个发行版的官方源.
还有brew 的二进制源,brew使用此配置能大大提升速度.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/local
git remote set-url origin git://mirrors.ustc.edu.cn/brew.git
git remote -v
brew update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改二进制源见&lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/homebrew-bottles&#34;&gt;https://lug.ustc.edu.cn/wiki/mirrors/help/homebrew-bottles&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;即&lt;code&gt;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;brew config&lt;/code&gt; 查看&lt;code&gt;ORIGIN&lt;/code&gt;和&lt;code&gt;HOMEBREW_BOTTLE_DOMAIN&lt;/code&gt;已经是新的&lt;code&gt;mirrors.ustc.edu.cn&lt;/code&gt;即为配置成功&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew list&lt;/code&gt; 列出所有安装的模块&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew search mysql&lt;/code&gt; 查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew commands&lt;/code&gt; 查看所有命令&lt;/p&gt;

&lt;p&gt;安装（需要 Ruby）：
&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;搜索：&lt;code&gt;brew search mysql&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查询：&lt;code&gt;brew info mysql&lt;/code&gt; 主要看具体的信息，比如目前的版本，依赖，安装后注意事项等&lt;/p&gt;

&lt;p&gt;更新：&lt;code&gt;brew update&lt;/code&gt; 这会更新 Homebrew 自己，并且使得接下来的两个操作有意义——&lt;/p&gt;

&lt;p&gt;检查过时（是否有新版本）：&lt;code&gt;brew outdated&lt;/code&gt; 这回列出所有安装的软件里可以升级的那些&lt;/p&gt;

&lt;p&gt;升级：&lt;code&gt;brew upgrade&lt;/code&gt; 升级所有可以升级的软件们&lt;/p&gt;

&lt;p&gt;清理：&lt;code&gt;brew cleanup&lt;/code&gt; 清理不需要的版本极其安装包缓存&lt;/p&gt;

&lt;p&gt;一些必备的软件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; brew install vim git subversion node go python3 lua nginx hugo openssl htop ffmpeg xz aria2 wget axel memcached redis mcrypt md5sha1sum fswatch mpv
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
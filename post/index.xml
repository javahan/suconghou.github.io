<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 苏苏的博客</title>
    <link>http://blog.suconghou.cn/post/</link>
    <description>Recent content in Posts on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 11 Aug 2016 10:27:18 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>javascript code snippet</title>
      <link>http://blog.suconghou.cn/post/javascript-code-snippet/</link>
      <pubDate>Thu, 11 Aug 2016 10:27:18 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-code-snippet/</guid>
      <description>

&lt;h2 id=&#34;实用的javascript代码锦集&#34;&gt;实用的Javascript代码锦集&lt;/h2&gt;

&lt;h3 id=&#34;获取查询查询字符串get参数值&#34;&gt;获取查询查询字符串get参数值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function getParam()
{
	var data = decodeURIComponent(location.href).split(&amp;quot;?&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;);
	var param = {};
	for(var i = 0; i&amp;lt;data .length; i++)
	{
		param[data [i].split(&amp;quot;=&amp;quot;)[0]] = data [i].split(&amp;quot;=&amp;quot;)[1];
	}
	return param;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于PHP中的&lt;code&gt;$_GET&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $_GET = (function()
{
	var url = decodeURIComponent(location.href);
	var u = url.split( &amp;quot;?&amp;quot; );
	if ( typeof (u[1]) == &amp;quot;string&amp;quot; )
	{
		u = u[1].split( &amp;quot;&amp;amp;&amp;quot; );
		var get = {};
		for ( var i in u)
		{
			var j = u[i].split( &amp;quot;=&amp;quot; );
			get[j[0]] = j[1];
		}
		return get;
	}
	else
	{
		return {};
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给出要获取的参数,每次都会解析一遍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getPar(par)
{
	//获取当前URL
	var local_url = decodeURIComponent(location.href);
	//获取要取得的get参数位置
	var get = local_url.indexOf(par + &amp;quot;=&amp;quot; );
	if (get == -1)
	{
		return false ;
	}
	//截取字符串
	var get_par = local_url.slice(par.length + get + 1);
	//判断截取后的字符串是否还有其他get参数
	var nextPar = get_par.indexOf( &amp;quot;&amp;amp;&amp;quot; );
	if (nextPar != -1)
	{
		get_par = get_par.slice(0, nextPar);
	}
	return get_par;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QueryString&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function QueryString(item)
{
	var value = location.search.match(new RegExp(&#39;[\?\&amp;amp;]&#39; + item + &#39;=([^\&amp;amp;]*)(\&amp;amp;?)&#39;,&#39;i&#39;));
	return value ? value[1] : value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;取得cookie中某个键的值&#34;&gt;取得Cookie中某个键的值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$.getCookie = function(name)
{
	 if(document.cookie.indexOf(name)!=-1) return document.cookie.split(name+&#39;=&#39;)[1].split(&#39;;&#39;)[0]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getcookie(cookieid)
{
	//获取cookie字符串
	var strCookie=document.cookie;
	//将多cookie切割为多个名/值对
	var arrCookie=strCookie.split(&amp;quot;; &amp;quot;);
	var cookieval;
	//遍历cookie数组，处理每个cookie对
	for(var i=0;i&amp;lt;arrCookie.length;i++)
	{
		var arr=arrCookie[i].split(&amp;quot;=&amp;quot;);
		//找到名称为userId的cookie，并返回它的值
		if(cookieid==arr[0])
		{
			cookieval=arr[1];
			break;
		}
	}
	return(cookieval);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;进入全屏&#34;&gt;进入全屏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function gofull()
{
	var el=document.documentElement;
	el.webkitRequestFullScreen&amp;amp;&amp;amp;el.webkitRequestFullScreen();
	el.mozRequestFullScreen&amp;amp;&amp;amp;el.mozRequestFullScreen();
	el.requestFullscreen&amp;amp;&amp;amp;el.requestFullscreen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串去空格&#34;&gt;字符串去空格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;String.prototype.trim=function() {return this.replace(/(^\s*)|(\s*$)/g,&amp;quot;&amp;quot;); }
String.prototype.ltrim=function(){return this.replace(/(^\s*)/g,&amp;quot;&amp;quot;); }
String.prototype.rtrim=function(){return this.replace(/(\s*$)/g,&amp;quot;&amp;quot;); }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字节格式化&#34;&gt;字节格式化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function size(size)
{
	var name=[&#39;B&#39;,&#39;KB&#39;,&#39;MB&#39;,&#39;GB&#39;,&#39;TB&#39;,&#39;PB&#39;];
	var pos=0;
	while(size&amp;gt;=1204)
	{
	    size/=1024;
	    pos++;
	}
	return size.toFixed(2)+&amp;quot; &amp;quot;+name[pos];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一些正则验证&#34;&gt;一些正则验证&lt;/h3&gt;

&lt;p&gt;验证邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_mail(str)
{
	return(new RegExp(/^[0-9a-zA-Z]+@(([0-9a-zA-Z]+)[.])+[a-z]{2,4}$/i).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证手机号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_tel(str)
{
	return(new RegExp(/^1[34578][0-9]{9}$/).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;base64的1x1像素间隔gif&#34;&gt;Base64的1x1像素间隔gif&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一个range函数&#34;&gt;一个range函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function range(start, count)
{
	return Array.apply(0, Array(count)).map(function (element, index)
	{
		return index + start;
	});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;简化-console-log&#34;&gt;简化&lt;code&gt;console.log&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var log = console.log.bind(console);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成较短的唯一id&#34;&gt;生成较短的唯一ID&lt;/h3&gt;

&lt;p&gt;一定年限内单线程非连续调用唯一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function shortId()
{
	var time=Date.now()+&#39;&#39;;
	time=parseInt(time.substr(1));
	return time.toString(36);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成随机短ID,仅具备较低的不重复性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var t=(((1+Math.random())*0x10000000)|0).toString(16);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;给jquery的form添加-serializeobject&#34;&gt;给jQuery的form添加&lt;code&gt;serializeObject&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.serializeObject=function()
{
	var a,o,h,i,e;
	a=this.serializeArray();
	o={};
	h=o.hasOwnProperty;
	for(i=0;i&amp;lt;a.length;i++)
	{
		e=a[i];
		if(!h.call(o,e.name))
		{
			o[e.name]=e.value;
		}
	}
	return o;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用效果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery(&amp;quot;form&amp;quot;).serialize(); //&amp;quot;username=&amp;amp;password=&amp;quot;
jQuery(&amp;quot;form&amp;quot;).serializeArray(); //[{name:&amp;quot;username&amp;quot;,value:&amp;quot;&amp;quot;},{name:&amp;quot;password&amp;quot;,value:&amp;quot;&amp;quot;}]
jQuery(&amp;quot;form&amp;quot;).serializeObject(); //{username:&amp;quot;&amp;quot;,password:&amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;资源预取&#34;&gt;资源预取&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function prefetch(url)
{
	var link = document.createElement(&amp;quot;link&amp;quot;);
	link.href = url;
	link.rel=&amp;quot;prefetch&amp;quot;;
	var s = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
	s.appendChild(link);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用-google-analytics-统计js错误&#34;&gt;用&lt;code&gt;Google Analytics&lt;/code&gt;统计JS错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,&#39;script&#39;,&#39;https://www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);
window.addEventListener(&#39;error&#39;, function (err)
{
	ga(&#39;create&#39;, &#39;UA-xxx-1&#39;, &#39;auto&#39;);
    var lineAndColumnInfo = err.colno ? &#39; line:&#39; + err.lineno +&#39;, column:&#39;+ err.colno : &#39; line:&#39; + err.lineno;
    ga(&#39;send&#39;, &#39;event&#39;, &#39;JavaScript Error&#39;, err.message, location.href+&#39; =&amp;gt; &#39;+err.filename + lineAndColumnInfo + &#39; -&amp;gt; &#39; +  navigator.userAgent, 0, true );
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;UA-xxx-1&lt;/code&gt;使用自己的统计ID&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript senior</title>
      <link>http://blog.suconghou.cn/post/javascript-senior/</link>
      <pubDate>Tue, 09 Aug 2016 21:27:39 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-senior/</guid>
      <description>

&lt;h2 id=&#34;javascript-参数传递&#34;&gt;Javascript 参数传递&lt;/h2&gt;

&lt;p&gt;说起参数传递,首先需要弄清楚javascript里的数据类型&lt;/p&gt;

&lt;p&gt;原始数据类型
&lt;code&gt;Undefined&lt;/code&gt; &lt;code&gt;Null&lt;/code&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;code&gt;Number&lt;/code&gt; &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用数据类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; &lt;code&gt;Date&lt;/code&gt; 等&lt;/p&gt;

&lt;p&gt;原始数据类型存储在栈的简单数据段,他们的值直接存储在变量访问的位置(因原始数据类型占据的空间是固定的,可以存储在较小的内存区域&lt;code&gt;栈&lt;/code&gt;中)&lt;/p&gt;

&lt;p&gt;引用数据类型是存储在堆中的对象,存储在变量处的值只是一个指针,指向存储对象的内存地址,这是因为引用类型的大小会改变.&lt;/p&gt;

&lt;p&gt;不同的内存分配机制带来不同的访问机制&lt;/p&gt;

&lt;p&gt;在JavaScript中,是不允许直接访问保存在堆内存中的对象的,访问对象时必须取得对象在堆内存中的地址,然后按地址去取得对象中的值.&lt;/p&gt;

&lt;p&gt;这便是传说中的按引用访问.&lt;/p&gt;

&lt;p&gt;而原始类型则是直接访问到的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复制变量时的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;会将原始值的副本赋值给新变量.此后两个变量完全独立.&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;会把内存地址赋值给新变量,也就是说两个变量都指向堆内存中的同一个对象.
他们中任何一个改变都会反映到另一个身上.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数传递的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最重要的一点:&lt;code&gt;ECMAScript&lt;/code&gt;中所有函数的参数都是按值传递的.&lt;/p&gt;

&lt;p&gt;但原始值和引用值仍会造成不同的后果.&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;把变量里的值传递给参数,之后两个变量互不影响.(就是把实参复制给形参的过程)&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;任然是将实参里面的值复制到形参,但是注意&lt;em&gt;对象变量它里面的值是这个对象的堆内存地址&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;也就是说形参和实参都是指向同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;但是也要记住另外一点:如果形参被赋值为另外一个对象时,那么这个形参将会丢弃对上次指向的堆内存地址,而指向新对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;此时,形参和实参相互脱离,互不影响,原先的实参任然指向原先对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;如果是添加修改形参的属性,那么就是修改堆内存中的对象,形参和实参将同时得到反映,因为他们指向的是同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;这种传递方式被称为&lt;code&gt;Call By Sharing&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function box(obj)
{
	obj.name=&#39;hello&#39;;
	var obj=new Object();
	obj.name=&#39;world&#39;;
}
var obj=new Object();
box(obj);
console.log(obj.name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意两点:
1. &lt;code&gt;var obj=new Object()&lt;/code&gt; 声明提升&lt;/p&gt;

&lt;p&gt;变为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj;
obj.name=&#39;hello&#39;;
obj=new Object();
obj.name=&#39;world&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数的已存在一个变量形参&lt;code&gt;obj&lt;/code&gt;,再次的变量申明会忽略&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;obj=new Object()&lt;/code&gt; 时,obj的修改就不会影响外层obj变量了,因为他此时已经脱离执行那个堆内存对象了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://www.zhihu.com/question/27114726&#34;&gt;http://www.zhihu.com/question/27114726&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;object-create&#34;&gt;Object.create&lt;/h2&gt;

&lt;p&gt;简单来讲，new Object()是一种通过构造函数来创建object的方式，而Object.create(proto, [ propertiesObject ])
不需要通过构造函数就可以创建一个object，Object.create()的第一个参数是必须要的，第二个参数可选。其实Object.create()内部依然是通过new一个构造函数的方式来实现的，它有构造函数，不过这个构造函数是隐式存在的，看一下使老旧浏览器支持Object.create方法的“polyfill”就可以对它们之间的区别一目了然了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
    Object.create = function (o) {
    function F() {}  //定义了一个隐式的构造函数
    F.prototype = o;
    return new F();  //其实还是通过new来实现的
    };
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HAProxy优化应用程序速度</title>
      <link>http://blog.suconghou.cn/post/use-haproxy/</link>
      <pubDate>Fri, 29 Jul 2016 14:27:54 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-haproxy/</guid>
      <description>

&lt;h2 id=&#34;haproxy&#34;&gt;HAProxy&lt;/h2&gt;

&lt;p&gt;HAProxy高性能的反向代理软件,更专注于TCP,HTTP处理,它可以基于四层或七层进行反向代理,尤其适合于高负载且需要进行七层处理的 Web 站点.&lt;/p&gt;

&lt;p&gt;单进程、事件驱动模型,通常用于超高流量的负载均衡.&lt;/p&gt;

&lt;p&gt;我们也可以使用它来作为中转站,使直连连通率不好的请求进过中转提升速度.&lt;/p&gt;

&lt;h3 id=&#34;编译安装&#34;&gt;编译安装&lt;/h3&gt;

&lt;p&gt;编译haproxy时必须制定target,不能直接make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Due to too many reports of suboptimized setups, building without
specifying the target is no longer supported. Please specify the
target OS in the TARGET variable, in the following form:

   make TARGET=xxx

Please choose the target among the following supported list :

   linux2628, linux26, linux24, linux24e, linux22, solaris
   freebsd, openbsd, cygwin, custom, generic

Use &amp;quot;generic&amp;quot; if you don&#39;t want any optimization, &amp;quot;custom&amp;quot; if you
want to precisely tweak every option, or choose the target which
matches your OS the most in order to gain the maximum performance
out of it. Please check the Makefile in case of doubts.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;linux2628 表示  内核版本&amp;gt;=2.6.28&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;HAPROXY_VERSION=haproxy-1.6.7
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.haproxy.org/download/1.6/src/${HAPROXY_VERSION}.tar.gz
tar zxf ${HAPROXY_VERSION}.tar.gz
cd ${HAPROXY_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
make TARGET=linux2628 ARCH=X86_64 -j$CPU_NUM &amp;amp;&amp;amp; make install

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;使用docker版本的haproxy&#34;&gt;使用Docker版本的HAProxy&lt;/h3&gt;

&lt;p&gt;这里提供一份编译好的最新版HAProxy镜像 &lt;a href=&#34;https://hub.docker.com/r/suconghou/haproxy/&#34;&gt;https://hub.docker.com/r/suconghou/haproxy/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;优化国外主机速度&#34;&gt;优化国外主机速度&lt;/h3&gt;

&lt;p&gt;HAProxy有多种连接模型,还有多种负载均衡算法,由于只有一台机器,我们主要侧重于使用它的反向代理.&lt;/p&gt;

&lt;p&gt;HAProxy可以一边保持与代理后端的长连接,一边又保持对客户端的连接.
这样双向保持持久连接,省去了中间反复创建连接可以在一定程度上优化速度.&lt;/p&gt;

&lt;p&gt;其只需要一个配置文件,配置主要有以下几部分功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;：用于为所有其它配置段提供默认参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frontend&lt;/code&gt;：用于定义一系列监听的套接字，这些套接字可接受客户端请求并与之建立连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backend&lt;/code&gt;：用于定义一系列后端服务器，代理将会将对应客户端的请求转发至这些服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;： 通过关联前端和后端定义了一个完整的代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置写在&lt;code&gt;haproxy.cfg&lt;/code&gt;文件中,启动的时候指定使用的配置文件.&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;haproxy -c -f /etc/haproxy/haproxy.cfg&lt;/code&gt;检查配置文件,&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg&lt;/code&gt;使用此配置文件启动&lt;/p&gt;

&lt;p&gt;一个简单的配置文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    log         127.0.0.1 local3
    pidfile     /var/run/haproxy.pid
    user        haproxy
    group       haproxy
    daemon

defaults
    mode                    http
    log                     global
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 30000

frontend http-in
    mode http
    bind 0.0.0.0:1080
    option http-keep-alive
    default_backend  servers

backend servers
	option http-keep-alive
    server myserver 192.243.115.210:80 check maxconn 6000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个在应对高并发时通常都需要改的
&lt;code&gt;ulimit -n 8192&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;重启HAProxy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg -st `cat /var/run/haproxy.pid`
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>react native</title>
      <link>http://blog.suconghou.cn/post/react-native/</link>
      <pubDate>Mon, 11 Jul 2016 11:39:08 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/react-native/</guid>
      <description>

&lt;h2 id=&#34;react-native&#34;&gt;react native&lt;/h2&gt;

&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;

&lt;p&gt;前提是需要node和npm,这里不在赘述.介绍一个npm加速的.&lt;/p&gt;

&lt;p&gt;使用淘宝的npm镜像.控制台运行,或者加入你的bashrc中永久生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias cnpm=&amp;quot;npm --registry=https://registry.npm.taobao.org --cache=$HOME/.npm/.cache/cnpm --disturl=https://npm.taobao.org/dist --userconfig=$HOME/.cnpmrc&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装开发必备的一些package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install -g react-native-cli webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react-native&lt;/code&gt;也调用了&lt;code&gt;npm&lt;/code&gt;命令,所以我们可以再来个alias加速&lt;code&gt;react-native init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alias npm=&#39;cnpm&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者直接将仓库改为淘宝的NPM镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org
npm config set disturl https://npm.taobao.org/dist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在mac上还需要一些东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install flow watchman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完以后可以开始helloworld了.&lt;/p&gt;

&lt;h3 id=&#34;开始第一个例子&#34;&gt;开始第一个例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /data/tmp
react-native init HelloWorld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后正在初始化大致如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This will walk you through creating a new React Native project in /data/tmp/HelloWorld
Installing react-native package from npm...
Setting up new React Native app in /data/tmp/HelloWorld
HelloWorld@0.0.1 /data/tmp/HelloWorld
└── react@15.2.1

To run your app on iOS:
   cd /data/tmp/HelloWorld
   react-native run-ios
   - or -
   Open /data/tmp/HelloWorld/ios/HelloWorld.xcodeproj in Xcode
   Hit the Run button
To run your app on Android:
   Have an Android emulator running (quickest way to get started), or a device connected
   cd /data/tmp/HelloWorld
   react-native run-android
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;React&lt;/code&gt;类名(组件名)必须首字母大写才会被认为是一个组件,否则在JSX里只会当做普通标签&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发IOS的教程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们执行&lt;code&gt;react-native run-ios&lt;/code&gt;开始编译运行,前提是你必须安装了&lt;code&gt;xcode&lt;/code&gt;哦.&lt;/p&gt;

&lt;p&gt;执行后,出现&lt;code&gt;BUILD SUCCEEDED&lt;/code&gt;,同时自动打开新的终端运行了一个server在8081端口.&lt;/p&gt;

&lt;p&gt;模拟器中也会出现刚编译好的app的窗口,使用&lt;code&gt;cmd+r&lt;/code&gt;刷新,&lt;code&gt;cmd+d&lt;/code&gt;弹出开发菜单.&lt;/p&gt;

&lt;p&gt;我们可以修改&lt;code&gt;index.ios.js&lt;/code&gt;开始开发了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发Android的教程&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;fetch&lt;/code&gt;调用接口时,可能会出现&lt;code&gt;The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.&lt;/code&gt;错误&lt;/p&gt;

&lt;p&gt;这是IOS9要求必须使用https通信,需要修改 &lt;a href=&#34;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&#34;&gt;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;react native&lt;/code&gt;创建&lt;code&gt;Info.plist&lt;/code&gt;时就已经为我们说明了,在&lt;code&gt;NSExceptionDomains&lt;/code&gt;下面的&lt;code&gt;dict&lt;/code&gt;里添加一个排除域名就OK了.&lt;/p&gt;

&lt;p&gt;注意,不能将默认的&lt;code&gt;localhost&lt;/code&gt;去掉,否则会出现&lt;code&gt;_fbBatchedBridge is undefined&lt;/code&gt;错误.&lt;/p&gt;

&lt;h2 id=&#34;打包&#34;&gt;打包&lt;/h2&gt;

&lt;h3 id=&#34;对android项目打包&#34;&gt;对android项目打包&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;keytool&lt;/code&gt;生成签名文件,在任意目录下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -v -keystore my-release-key.keystore  -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面&lt;code&gt;my-release-key&lt;/code&gt;可以自己定义,后面的&lt;code&gt;my-key-alias&lt;/code&gt;也可以自己定义.运行后输入一下相关信息后,生成&lt;code&gt;my-release-key.keystore&lt;/code&gt;文件.&lt;/p&gt;

&lt;p&gt;其中输入的两次密码,需要记住.将这个文件移动到&lt;code&gt;android/app&lt;/code&gt;目录下,编译&lt;code&gt;android/app&lt;/code&gt;里的&lt;code&gt;build.gradle&lt;/code&gt;,添加下面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    ...
    defaultConfig { ... }
    signingConfigs {
        release {
            storeFile file(MYAPP_RELEASE_STORE_FILE)
            storePassword MYAPP_RELEASE_STORE_PASSWORD
            keyAlias MYAPP_RELEASE_KEY_ALIAS
            keyPassword MYAPP_RELEASE_KEY_PASSWORD
        }
    }
    ...
    buildTypes {
        release {
              ...
              signingConfig signingConfigs.release
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;android&lt;/code&gt;目录下运行如下命令,就可以打包,安装到自己手机上,前提是手机已usb调试连接到电脑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew assembleRelease
cd app/build/outputs/apk
adb install -r app-release.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://facebook.github.io/react-native/docs/signed-apk-android.html&#34;&gt;https://facebook.github.io/react-native/docs/signed-apk-android.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>都有哪些坑</title>
      <link>http://blog.suconghou.cn/post/some-hole/</link>
      <pubDate>Thu, 07 Jul 2016 15:46:03 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/some-hole/</guid>
      <description>

&lt;h2 id=&#34;总结一下遇到的坑&#34;&gt;总结一下遇到的坑&lt;/h2&gt;

&lt;h3 id=&#34;微信&#34;&gt;微信&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;关于横竖屏的坑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;css3可以使用媒体查询判断设备是横屏还是竖屏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//横屏时显示
@media all and (orientation : landscape) {
#screenMask{display:block}
}

//竖屏时隐藏
@media all and (orientation : portrait) {
#screenMask{display:none}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在手机浏览器中表现良好,微信中看样子也可以,但是微信网页中如果聚焦输入框,弹起键盘就有问题了.&lt;/p&gt;

&lt;p&gt;软键盘弹起后,网页可用面积减小,安卓就自动识别为横屏了,原有的页面消失了,影响非常大.IOS则没有这个问题,媒体查询判断横竖屏在IOS上工作良好.&lt;/p&gt;

&lt;p&gt;并且由此发现,css3媒体查询就是根据宽度是否比高度小来判断横竖屏的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方案1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;javascript&lt;/code&gt;的&lt;code&gt;orientation&lt;/code&gt;和&lt;code&gt;orientationchange&lt;/code&gt;判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;window.orientation   属于window对象上一个属性；共有三个值 ：0为竖屏模式（portrait）,90为向左反转变为横屏模式（landscape），-90为向右反转变为横屏模式（landscape），最后180就是设备上下互换还是竖屏模式。&lt;/li&gt;
&lt;li&gt;orientationchange    是一个event，在设备旋转时，会触发此事件，如同PC上使用的resize事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var init = function(){
        var updateOrientation = function(){
            var orientation = window.orientation;
            switch(orientation){
                case 90:
                case -90:
                    orientation = &#39;landscape&#39;;
                    break;
                default:
                    orientation = &#39;portrait&#39;;
                    break;
            }

           //do something
           //比如在html标签加一个状态
            //然后根据不同状态，显示不同大小
            document.body.parentNode.setAttribute(&#39;class&#39;,orientation);
        };

        window.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        updateOrientation();
    };

    window.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试使用JS判断能够正确得出安卓微信客户端里输入框聚焦时的横竖屏状态.&lt;/p&gt;

&lt;p&gt;orientation和orientationchange只有移动设备有这些属性和事件.&lt;/p&gt;

&lt;p&gt;在不支持这种属性和事件的设备上使用宽高比来判断做一下兼容,这样在不支持&lt;code&gt;orientation&lt;/code&gt;的设备上就相当于使用了媒体查询&lt;/p&gt;

&lt;p&gt;最终总结代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(w)
{
    var supportOrientation = (typeof w.orientation === &#39;number&#39; &amp;amp;&amp;amp; typeof w.onorientationchange === &#39;object&#39;);
    var init = function()
    {
        var htmlNode = document.body.parentNode, orientation;
        var updateOrientation = function()
        {
            if(supportOrientation)
            {
                orientation = w.orientation;
                switch(orientation)
                {
                    case 90:
                    case -90:
                        orientation = &#39;landscape&#39;;
                        break;
                    default:
                        orientation = &#39;portrait&#39;;
                        break;
                }
            }
            else
            {
                orientation = (w.innerWidth &amp;gt; w.innerHeight) ? &#39;landscape&#39; : &#39;portrait&#39;;
            }
            htmlNode.setAttribute(&#39;class&#39;,orientation);
        };
        if(supportOrientation)
        {
            w.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        }
        else
        {
            //监听resize事件
            w.addEventListener(&#39;resize&#39;,updateOrientation,false);
        }
        updateOrientation();
    };
    w.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以访问如下网址测试: /html/wx&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP最佳实践</title>
      <link>http://blog.suconghou.cn/post/php-best-way/</link>
      <pubDate>Thu, 30 Jun 2016 16:40:13 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/php-best-way/</guid>
      <description>

&lt;h2 id=&#34;性能优化&#34;&gt;性能优化&lt;/h2&gt;

&lt;h3 id=&#34;数组相关&#34;&gt;数组相关&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;in_array&lt;/code&gt;在大数据量(数万以上元素)下效率低下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在分析nginx log得出所有不重复IP时,采用&lt;code&gt;in_array&lt;/code&gt;判断,50多万的数据耗时需要五六分钟,而采用存键的方法,用&lt;code&gt;isset&lt;/code&gt;判断仅需要十几秒,效率差别非常大. [php7环境下]&lt;/p&gt;

&lt;p&gt;判断一个数组是否存在某个元素,远比查找一个键消耗的要多.前者时间复杂度O(n),而后者O(1)&lt;/p&gt;

&lt;p&gt;即时使用&lt;code&gt;in_array&lt;/code&gt;,也需要加上第三个参数,设置为严格模式,省略数据类型转化的开销,设置为&lt;code&gt;true&lt;/code&gt;比设置为&lt;code&gt;false&lt;/code&gt;性能要提升好几倍.&lt;/p&gt;

&lt;p&gt;这种情况下使用&lt;code&gt;array_search&lt;/code&gt;情况比&lt;code&gt;in_array&lt;/code&gt;更加糟糕&lt;/p&gt;

&lt;p&gt;如果条件允许使用&lt;code&gt;array_flip&lt;/code&gt;交换键值,在用&lt;code&gt;isset&lt;/code&gt;来判断要比&lt;code&gt;in_array&lt;/code&gt;好得多&lt;/p&gt;

&lt;p&gt;同时,使用&lt;code&gt;isset&lt;/code&gt;来判断数组的键,也比使用&lt;code&gt;array_key_exists&lt;/code&gt;要好&lt;/p&gt;

&lt;p&gt;而对于本题,还可以使用&lt;code&gt;array_unique&lt;/code&gt;最后去重,用空间换时间,效率仅次于用&lt;code&gt;isset&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;bugs&#34;&gt;Bugs&lt;/h2&gt;

&lt;h3 id=&#34;php-pdo-mysql-server-has-gone-away&#34;&gt;php pdo &lt;code&gt;MySQL server has gone away&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在使用PDO长连接时,执行过一次PDO初始化后,php-fpm进程会与mysql server开启一条TCP长连接,下次连接数据库就能加快速度.&lt;/p&gt;

&lt;p&gt;但是却存在一定问题,PDO维持了长连接并没有较好的检测其可用性,如果mysql server kill 掉这个连接,或者mysql重启,都会造成&lt;/p&gt;

&lt;p&gt;重新实例化PDO时得到旧的链接,导致出现&lt;code&gt;MySQL server has gone away&lt;/code&gt;,更让人郁闷的是这个错误并不是一个Exception,无法被catch捕获,即使设置&lt;code&gt;PDO::ATTR_ERRMODE=&amp;gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt;,也不行,还是直接在页面上提示.&lt;/p&gt;

&lt;p&gt;如果你使用了&lt;code&gt;set_error_handler&lt;/code&gt;,那么这个&lt;code&gt;Warning&lt;/code&gt;将会被捕捉,不会直接显示在页面上,但也改变了程序的原有执行逻辑.&lt;/p&gt;

&lt;p&gt;如果你不使用&lt;code&gt;set_error_handler&lt;/code&gt;,页面上报出&lt;code&gt;Warning&lt;/code&gt;,但其实PDO已经返回一个可用的链接了.&lt;/p&gt;

&lt;p&gt;猜测可能是PDO首先得到了不可用的然后报警告,然后又创建了一个新的.&lt;/p&gt;

&lt;p&gt;较好的解决方法是设置&lt;code&gt;set_error_handler&lt;/code&gt;若捕获了这个&lt;code&gt;MySQL server has gone away&lt;/code&gt;,则返回null,程序继续按原有逻辑执行.&lt;/p&gt;

&lt;p&gt;或者不使用PDO长连接.&lt;/p&gt;

&lt;p&gt;注意,&lt;code&gt;set_error_handler&lt;/code&gt;返回false的话,这个错误还是会被交到上一级错误程序处理的.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks libev</title>
      <link>http://blog.suconghou.cn/post/shadowsocks-libev/</link>
      <pubDate>Wed, 18 May 2016 17:37:16 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/shadowsocks-libev/</guid>
      <description>

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;yum update &amp;amp;&amp;amp; yum install -y zip unzip xz curl wget git gcc make zlib zlib-devel openssl openssl-devel
git clone https://github.com/shadowsocks/shadowsocks-libev.git
cd shadowsocks-libev
./configure --enable-static=yes
export CFLAGS=&amp;quot;-O3&amp;quot;
make -j4 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;GO语言版本的也十分方便哦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里提供一个基于&lt;code&gt;docker&lt;/code&gt;的go语言版本,&lt;a href=&#34;https://hub.docker.com/r/suconghou/shadowsocks/&#34;&gt;docker go shadowsocks&lt;/a&gt;,只有3.3MB
十分方便&lt;/p&gt;

&lt;p&gt;同时也含有libev版本的可供选择&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用tcpdump</title>
      <link>http://blog.suconghou.cn/post/tcpdump/</link>
      <pubDate>Mon, 16 May 2016 18:21:04 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/tcpdump/</guid>
      <description>&lt;p&gt;各版本 &lt;code&gt;http://www.tcpdump.org/release/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装依赖 &lt;code&gt;yum install -y flex gcc make byacc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export CFLAGS=&amp;quot;-O3&amp;quot;
cd /tmp
wget http://www.tcpdump.org/release/libpcap-1.7.4.tar.gz
tar zxvf libpcap-1.7.4.tar.gz
cd libpcap-1.7.4
./configure
make -j4
cd ../
wget http://www.tcpdump.org/release/tcpdump-4.7.4.tar.gz
tar zxvf tcpdump-4.7.4.tar.gz
cd tcpdump-4.7.4
./configure
make -j4
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后,位于&lt;code&gt;ls -lh /usr/local/sbin/tcpdump&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;不采用&lt;code&gt;CFLAGS=&amp;quot;-O3&amp;quot;&lt;/code&gt;编译为4.3MB,采用&lt;code&gt;CFLAGS=&amp;quot;-O3&amp;quot;&lt;/code&gt;编译后为1.3MB&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tcpdump -h&lt;/code&gt; 查看版本号以及用法&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译安装Apache Traffic Server</title>
      <link>http://blog.suconghou.cn/post/use-apache-traffic-server/</link>
      <pubDate>Mon, 09 May 2016 22:24:14 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-apache-traffic-server/</guid>
      <description>

&lt;h2 id=&#34;编译安装&#34;&gt;编译安装&lt;/h2&gt;

&lt;p&gt;Centos下编译安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum update -y &amp;amp;&amp;amp; yum install wget gcc g++ gcc-c++ glibc-headers perl openssl openssl-devel tcl-devel libxml2-devel pcre-devel
wget http://apache.fayea.com/trafficserver/trafficserver-6.1.1.tar.bz2
tar xvjf trafficserver-6.1.1.tar.bz2
cd trafficserver-6.1.1
./configure
make &amp;amp;&amp;amp; make install
useradd -s /sbin/nologin trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache镜像&lt;a href=&#34;http://archive.apache.org/dist/&#34;&gt;http://archive.apache.org/dist/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;国内Apache镜像&lt;a href=&#34;http://apache.fayea.com/&#34;&gt;http://apache.fayea.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译完成后,就可以使用了,默认是安装在&lt;code&gt;/usr/local/bin&lt;/code&gt;,编译后是比较大&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total 98M
-rwxr-xr-x 1 root root 692K May  9 14:30 header_rewrite_test
-rwxr-xr-x 1 root root 520K May  9 14:30 traffic_cop
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_crashlog
-rwxr-xr-x 1 root root 259K May  9 14:30 traffic_ctl
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_layout
-rwxr-xr-x 1 root root  41K May  9 14:30 traffic_line
-rwxr-xr-x 1 root root 4.4M May  9 14:30 traffic_logcat
-rwxr-xr-x 1 root root 5.0M May  9 14:30 traffic_logstats
-rwxr-xr-x 1 root root 4.7M May  9 14:30 traffic_manager
-rwxr-xr-x 1 root root  37M May  9 14:30 traffic_sac
-rwxr-xr-x 1 root root  43M May  9 14:30 traffic_server
-rwxr-xr-x 1 root root  42K May  9 14:30 traffic_via
-rwxr-xr-x 1 root root  18K May  9 14:30 trafficserver
-rwxr-xr-x 1 root root 2.1K May  9 14:30 tspush
-rwxr-xr-x 1 root root 5.7K May  9 14:30 tsxs

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;code&gt;traffic_server -R 1&lt;/code&gt;执行测试,经过一系列测试后,显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tests Passed: 177
Tests Failed: 0
    REGRESSION_RESULT PARENTSELECTION:                          PASSED
REGRESSION_TEST DONE: PASSED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全部测试通过&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;默认的配置文件存放在&lt;code&gt;/usr/local/etc/trafficserver&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x 3 nobody nobody 1.0K May  9 14:30 body_factory
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 cache.config
-rw-r--r-- 1 nobody nobody  657 May  9 14:30 cluster.config
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 congestion.config
-rw-r--r-- 1 nobody nobody  746 May  9 14:30 hosting.config
-rw-r--r-- 1 nobody nobody 1.8K May  9 14:30 icp.config
-rw-r--r-- 1 nobody nobody 1.2K May  9 14:30 ip_allow.config
-rw-r--r-- 1 nobody nobody  328 May  9 14:30 log_hosts.config
-rw-r--r-- 1 nobody nobody  17K May  9 14:30 logs_xml.config
-rw-r--r-- 1 nobody nobody 1.4K May  9 14:30 parent.config
-rw-r--r-- 1 nobody nobody  261 May  9 14:30 plugin.config
-rw-r--r-- 1 nobody nobody  13K May  9 14:30 records.config
-rw-r--r-- 1 nobody nobody 8.6K May  9 14:30 remap.config
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 socks.config
-rw-r--r-- 1 nobody nobody 2.1K May  9 14:30 splitdns.config
-rw-r--r-- 1 nobody nobody 2.7K May  9 14:30 ssl_multicert.config
-rw-r--r-- 1 nobody nobody  76K May  9 14:30 stats.config.xml
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 storage.config
-rw-r--r-- 1 root   root     19 May  9 14:30 trafficserver-release
-rw-r--r-- 1 nobody nobody  649 May  9 14:30 vaddrs.config
-rw-r--r-- 1 nobody nobody 1.3K May  9 14:30 volume.config

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;records.config&lt;/code&gt;负责大部分全局的选项设置，即主要配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG proxy.config.reverse_proxy.enabled INT 1                           # 开启反向代理
CONFIG proxy.config.url_remap.remap_required INT 1                        # 1 代理反向代理，0代表正向+反向代理
CONFIG proxy.config.http.cache.http INT 1                                 # 打开http缓存功能
CONFIG proxy.config.cache.ram_cache.size INT 512M                         # RAM 缓存大小
CONFIG proxy.config.http.keep_alive_no_activity_timeout_out INT 120       # 当一个事务结束后同原服务器保持连接的时间
CONFIG proxy.config.cluster.ethernet_interface STRING eth0                # 修改成需要侦听的interface名称

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;remap.config&lt;/code&gt;定义映射规则，用于请求的重定向（rewrite）,反向代理即在此配置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;storage.config&lt;/code&gt; 用于指定磁盘存储&lt;/p&gt;

&lt;p&gt;启动&lt;code&gt;trafficserver start&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在树莓派上使用Docker</title>
      <link>http://blog.suconghou.cn/post/use-docker-on-raspberry/</link>
      <pubDate>Sun, 08 May 2016 20:01:56 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-docker-on-raspberry/</guid>
      <description>

&lt;h2 id=&#34;安装支持docker的系统&#34;&gt;安装支持Docker的系统&lt;/h2&gt;

&lt;p&gt;树莓派官方系统并不支持Docker,需要安装.&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;集成Dcoker的树莓派系统&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -s 50 -c https://downloads.hypriot.com/hypriotos-rpi-v0.8.0.img.zip


diskutil list
diskutil unmountdisk /dev/disk2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用以下命令前必须卸载u盘&lt;code&gt;diskutil unmountdisk /dev/disk2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=hypriotos-rpi-v0.8.0.img of=/dev/disk2 bs=8k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成重启就可以啦,启动后登陆的用户是pirate,密码hypriot&lt;/p&gt;

&lt;p&gt;修改密码:执行&lt;code&gt;passwd&lt;/code&gt;,输入当前密码,输入新密码,再输入新密码,更新完成&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;exit&lt;/code&gt;退出,或者&lt;code&gt;sudo reboot&lt;/code&gt;重启&lt;/p&gt;

&lt;p&gt;创建用户:&lt;code&gt;useradd -g test -d /home/test1 -s /etc/bash -m test1&lt;/code&gt;
注解：-g 所属组 -d 家目录 -s 所用的SHELL
passwd abc&lt;/p&gt;

&lt;p&gt;获得sudo权限:编辑&lt;code&gt;/etc/sudoers&lt;/code&gt; 加入新添加的用户名&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>linux相关操作</title>
      <link>http://blog.suconghou.cn/post/linux/</link>
      <pubDate>Thu, 21 Jan 2016 13:40:53 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/linux/</guid>
      <description>

&lt;h2 id=&#34;linux实用命令&#34;&gt;Linux实用命令&lt;/h2&gt;

&lt;h2 id=&#34;w&#34;&gt;w&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;w&lt;/code&gt;命令能容清晰的显示,服务器在线时间,负载以及当前登陆的用户&lt;/p&gt;

&lt;h2 id=&#34;vmstat&#34;&gt;vmstat&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vmstat&lt;/code&gt; 显示开机以来的平均值，而不是前一秒的值
&lt;code&gt;vmstat 1&lt;/code&gt;命令指定一个参数 1 运行，来打印每一秒的统计摘要.
这些列代表的信息:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;r：CPU 中正在运行和等待运行的进程的数量。其提供了一个比平均负载更好的信号来确定 CPU 是否饱和，因为其不包含 I/O。解释：&amp;rdquo;r&amp;rdquo;的值大于了 CPU 的数量就表示已经饱和了。
free：以 kb 为单位显式的空闲内存。如果数字位数很多，说明你有足够的空闲内存。&amp;rdquo;free -m&amp;rdquo; 命令，是下面的第七个命令，其可以更好的说明空闲内存的状态。
si, so：Swap-ins 和 swap-outs。如果它们不是零，则代表你的内存不足了。
us, sy, id, wa, st：这些都是平均了所有 CPU 的 CPU 分解时间。它们分别是用户时间（user）、系统时间（内核）（system）、空闲（idle）、等待 I/O（wait）、以及占用时间（stolen）（被其他访客，或使用 Xen，访客自己独立的驱动域）。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CPU 分解时间将会通过用户时间加系统时间确认 CPU 是否为忙碌状态。等待 I/O 的时间一直不变则表明了一个磁盘瓶颈；这就是 CPU 的闲置，因为任务都阻塞在等待挂起磁盘 I/O 上了。你可以把等待 I/O 当成是 CPU 闲置的另一种形式，其给出了为什么 CPU 闲置的一个线索。
对于 I/O 处理来说，系统时间是很重要的。一个高于 20% 的平均系统时间，可以值得进一步的探讨：也许内核在处理 I/O 时效率太低了。&lt;/p&gt;

&lt;p&gt;SIZE(VIRT): 进程使用的地址空间, 如果进程映射了100M的内存, 进程的地址空间将报告为100M内存. 事实上, 这个大小不是一个程序实际使用的内存数.&lt;/p&gt;

&lt;p&gt;RSS(RES): &amp;ldquo;Resident Set Size&amp;rdquo;, 实际驻留&amp;rdquo;在内存中&amp;rdquo;的内存数. 不包括已经交换出去的代码. 举一个例子: 如果你有一个程序使用了100K内存, 操作系统交换出40K内存, 那么RSS为60K. RSS还包括了与其它进程共享的内存区域. 这些区域通常用于libc库等.&lt;/p&gt;

&lt;p&gt;SHARE(SHR): RSS中与其它进程共享的内存部分大小.&lt;/p&gt;

&lt;p&gt;VMSIZE: 一个进程占用的总的地址空间大小. 它包括了没有映射到内存中的页面。&lt;/p&gt;

&lt;p&gt;SZ（DATA）: 映射到内存中的页面, 这些页面仅由进程单独使用. 这也是我们最关心地方: 进程实际占用的内存数。&lt;/p&gt;

&lt;h2 id=&#34;top&#34;&gt;top&lt;/h2&gt;

&lt;h2 id=&#34;free&#34;&gt;free&lt;/h2&gt;

&lt;h2 id=&#34;ssh&#34;&gt;ssh&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub root@host&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ssh-copy-id -i ~/.ssh/id_rsa.pub -p 26671 root@host&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pgrep&#34;&gt;pgrep&lt;/h2&gt;

&lt;p&gt;根据名字或其他属性查询出进程的PID&lt;/p&gt;

&lt;p&gt;如:&lt;code&gt;pgrep nginx -fl&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;pkill&#34;&gt;pkill&lt;/h2&gt;

&lt;p&gt;和&lt;code&gt;pgrep&lt;/code&gt;类似,不同的是向进程发送信号,默认发送&lt;code&gt;SIGTERM&lt;/code&gt;信号,查看都有哪些信号可用,可以使用&lt;code&gt;kill -l&lt;/code&gt;查看&lt;/p&gt;

&lt;p&gt;类似&lt;code&gt;pkill&lt;/code&gt;的命令是&lt;code&gt;killall&lt;/code&gt;,后面都是可以直接加进程名字批量杀死进程&lt;/p&gt;

&lt;h2 id=&#34;pstree&#34;&gt;pstree&lt;/h2&gt;

&lt;p&gt;用树的形式显示正在运行的进程,树的节点为指定的PID(忽略则为init进程)&lt;/p&gt;

&lt;h2 id=&#34;ss&#34;&gt;ss&lt;/h2&gt;

&lt;p&gt;用于显示socket的统计信息,&lt;code&gt;-s&lt;/code&gt;用于显示汇总&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-l&lt;/code&gt;用于列出正在监听的&lt;code&gt;socket&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-p&lt;/code&gt;显示进程信息,&lt;code&gt;ss -pl&lt;/code&gt; 可以查看使用网络端口的进程名字&lt;/p&gt;

&lt;h2 id=&#34;磁盘相关&#34;&gt;磁盘相关&lt;/h2&gt;

&lt;h3 id=&#34;dd&#34;&gt;dd&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;dd&lt;/code&gt;把指定的输入文件拷贝到指定的输出文件中,并且在拷贝的过程中可以进行格式转换。&lt;/p&gt;

&lt;p&gt;if =输入文件(或设备名称)
of =输出文件(或设备名称)
bs = bytes 同时设置读/写缓冲区的字节数(等于设置obs和obs)
count = blocks 只拷贝输入的blocks块&lt;/p&gt;

&lt;p&gt;创建一个100M的空文件
&lt;code&gt;dd if=/dev/zero of=hello.txt bs=100m count=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小&#34;&gt;查看当前目录下所有一级子目录文件夹大小&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;查看当前目录下所有一级子目录文件夹大小-并排序&#34;&gt;查看当前目录下所有一级子目录文件夹大小 并排序&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;du -h --max-depth=1 |sort&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;以上两条命令不适用于MacOs,可以使用&lt;code&gt;du -sh *&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;ps&#34;&gt;ps&lt;/h2&gt;

&lt;p&gt;ps ef  查看进程的状态&lt;/p&gt;

&lt;p&gt;ps auxw 查看进程的CPU,内存占用&lt;/p&gt;

&lt;p&gt;ps 默认是按照PID排序的,若要按内存使用排序&lt;code&gt;ps auxw --sort=rss&lt;/code&gt;,同理按虚拟内存排序&lt;code&gt;ps auxw --sort=vsz&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;mac上无法使用&lt;code&gt;--sort&lt;/code&gt;,可以采用&lt;code&gt;sort&lt;/code&gt;排序,如rss在第六列,则&lt;code&gt;ps auxw | sort -k6,6n&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;一份linux别名和函数库&#34;&gt;一份Linux别名和函数库&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;alias tree=&amp;quot;find . -print | sed -e &#39;s;[^/]*/;|____;g;s;____|; |;g&#39; &amp;quot;;
alias cls=&amp;quot;cd $1;ls -lh;&amp;quot;;
# 获得你的公网IP地址和主机名。
alias ipinfo=&amp;quot;curl ifconfig.me &amp;amp;&amp;amp; curl ifconfig.me/host&amp;quot;;
# 显示出哪个应用程序连接到网络。
alias listen=&amp;quot;lsof -P -i -n&amp;quot;;
# 显示出活动的端口。
alias port=&#39;netstat -uanltp&#39;
# 统计TCP连接个数
alias tcpstatus=&amp;quot;netstat -n|awk &#39;/^tcp/{++S[\$NF]} END {for(a in S) print a,S[a]}&#39;&amp;quot;
# 回到上层目录
alias ..=&#39;cd ..&#39;
# 去到上两层目录
alias ...=&#39;cd ../..&#39;
# 按列格式化输出mount信息。
alias cmount=&amp;quot;mount | column -t&amp;quot;
# 查看你还有剩下多少内存
alias meminfo=&#39;free -m -l -t&#39;
# 按照文件在磁盘存储的大小排序，显示当前目录的文件列表。
sbs() { du -b --max-depth 1 | sort -nr | perl -pe &#39;s{([0-9]+)}{sprintf &amp;quot;%.1f%s&amp;quot;, $1&amp;gt;=2**30? ($1/2**30, &amp;quot;G&amp;quot;): $1&amp;gt;=2**20? ($1/2**20, &amp;quot;M&amp;quot;): $1&amp;gt;=2**10? ($1/2**10, &amp;quot;K&amp;quot;): ($1, &amp;quot;&amp;quot;)}e&#39;;}
# 找出指定目录中最大的10个文件
largefile() { find . -type f -exec du -k {} \; | sort  -nrk 1 | head; }
# 查看当前目录大于[多少]kb的文件,速度更快
bigthan() { size=${1:-100}; find . -type f -size +&amp;quot;$size&amp;quot;k |xargs  ls  -lh ; }
# 返回你的当前IP地址的地理位置。
getlocation() { lynx -dump http://www.ip-adress.com/ip_tracer/?QRY=$1|grep address|egrep &#39;city|state|country&#39;|awk &#39;{print $3,$4,$5,$6,$7,$8}&#39;|sed &#39;s\ip address flag \\&#39;|sed &#39;s\My\\&#39;;}
# 删除.log.1.gz 或者 .log.1.bz2
delog(){ ls | grep &amp;quot;log.\d\+.\(bz2\|gz\)&amp;quot; | xargs rm}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 这几个Mac不兼容
# 查看最占用内存的前五个进程
topmem()
{
	ps aux | sort -k4nr | head -n5;
}
# 查看某一程序占用的内存
mem()
{
    top -n1 -b | head -n7 | sed &#39;1,6d&#39; &amp;amp;&amp;amp; top -n1 -b | sed &#39;1,7d&#39; | grep --color=auto $1;
    ps aux | grep --color=auto $1 | grep --color=auto -v grep | awk -F &amp;quot; &amp;quot; &#39;{ sum += $6 } END { printf &amp;quot;Total Memory Usage: %.1f MB\n&amp;quot;, sum/1024 }&#39;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;# 查看你机器的CPU个数,超线程信息
sysinfo() {
physicalNumber=0
coreNumber=0
logicalNumber=0
HTNumber=0
logicalNumber=$(grep &amp;quot;processor&amp;quot; /proc/cpuinfo|sort -u|wc -l)
physicalNumber=$(grep &amp;quot;physical id&amp;quot; /proc/cpuinfo|sort -u|wc -l)
coreNumber=$(grep &amp;quot;cpu cores&amp;quot; /proc/cpuinfo|uniq|awk -F&#39;:&#39; &#39;{print $2}&#39;|xargs)
HTNumber=$((logicalNumber / (physicalNumber * coreNumber)))
echo &amp;quot;****** CPU Information ******&amp;quot;
echo &amp;quot;Logical CPU Number  : ${logicalNumber}&amp;quot;
echo &amp;quot;Physical CPU Number : ${physicalNumber}&amp;quot;
echo &amp;quot;CPU Core Number     : ${coreNumber}&amp;quot;
echo &amp;quot;HT Number           : ${HTNumber}&amp;quot;
echo &amp;quot;*****************************&amp;quot;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;使用脚本清理一些文件&#34;&gt;使用脚本清理一些文件&lt;/h2&gt;

&lt;p&gt;删除当前目录超过30天未变动过的log文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; | xargs rm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;find . -mtime +30 -type f -name &#39;*.log*&#39; -exec rm -i {} \;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所有的操作都包含子目录&lt;/p&gt;

&lt;p&gt;-exec  参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&lt;/p&gt;

&lt;p&gt;{}   花括号代表前面find查找出来的文件名。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -type f -exec ls -l {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;find . -name &amp;quot;*.log&amp;quot; -mtime +60 -ok rm {} \;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-mtime +30 设定时间为30天前&lt;/p&gt;

&lt;p&gt;-type f 查找的类型为文件&lt;/p&gt;

&lt;p&gt;-name 文件路径需要匹配的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用全文查找&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;grep -lr &amp;lsquo;string&amp;rsquo; /etc/&lt;/p&gt;

&lt;p&gt;这个命令就可以搞定。搜索etc下面的文件，包含所有目录下的文件。这样就搞定了。&lt;/p&gt;

&lt;p&gt;-i，乎略大小写
-l，找出含有这个字符串的文件
-r，不放过子目录&lt;/p&gt;

&lt;h2 id=&#34;解决can-t-set-the-locale-make-sure-lc-and-lang-are-correct&#34;&gt;解决can&amp;rsquo;t set the locale; make sure $LC_* and $LANG are correct&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&#34;&gt;https://www.thomas-krenn.com/en/wiki/Perl_warning_Setting_locale_failed_in_Debian&lt;/a&gt;
&lt;code&gt;照着全部做下来&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;vim乱码解决&#34;&gt;Vim乱码解决&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;vim ~/.vimrc&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936
set termencoding=utf-8
set encoding=utf-8
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;开机启动的&#34;&gt;开机启动的&lt;/h2&gt;

&lt;p&gt;检视和控制systemd的主要命令是systemctl&lt;/p&gt;

&lt;p&gt;详细使用见&lt;a href=&#34;https://wiki.archlinux.org/index.php/systemd_(简体中文)&#34;&gt;https://wiki.archlinux.org/index.php/systemd_(简体中文)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CentOS7 用&lt;code&gt;systemctl&lt;/code&gt;取代了&lt;code&gt;service&lt;/code&gt;
旧版本的 &lt;code&gt;service docker start&lt;/code&gt; 改为&lt;code&gt;systemctl start docker&lt;/code&gt;
设置开机启动
旧版本的 &lt;code&gt;chkconfig docker on&lt;/code&gt; 改为 &lt;code&gt;systemctl enable docker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/usr/lib/systemd/system/&lt;/code&gt;
&lt;code&gt;/etc/systemd/system/&lt;/code&gt;
后者有较高优先级会覆盖前者&lt;/p&gt;

&lt;p&gt;/etc/profile 和 ~/.bash_profile 是在启动 一个交互登陆shell的时候 被调用。
/etc/bashrc 和 ~/.bashrc 是在一个交互的非登陆shell启动 的时候 被调用。
~/.bash_logout 在用户注销登陆的时候 被读取&lt;/p&gt;

&lt;p&gt;系统脚本 可以放置在/etc/rc.d/init.d中并建立/etc/rc.d/rc?.d链接，也可以直接放置在/etc/rc.d/rc.local中。
init.d脚本 包含完整的start,stop,status,reload等参数，是标准做法，推荐使用。&lt;/p&gt;

&lt;h2 id=&#34;linux-家族&#34;&gt;Linux 家族&lt;/h2&gt;

&lt;p&gt;一般来说著名的linux系统基本上分两大类：&lt;/p&gt;

&lt;p&gt;1.RedHat系列：Redhat、Centos、Fedora等&lt;/p&gt;

&lt;p&gt;2.Debian系列：Debian、Ubuntu等
RedHat 系列
1 常见的安装包格式 rpm包,安装rpm包的命令是“rpm -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 yum&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;Debian系列
1 常见的安装包格式 deb包,安装deb包的命令是“dpkg -参数”&lt;/p&gt;

&lt;p&gt;2 包管理工具 apt-get&lt;/p&gt;

&lt;p&gt;3 支持tar包&lt;/p&gt;

&lt;p&gt;&lt;code&gt;soft rlimits too low. Number of files is 256, should be at least 1000&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;https://www.fdzh.org/slides/2015/06/20/linux-distr/&#34;&gt;https://www.fdzh.org/slides/2015/06/20/linux-distr/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://dn-copr.qbox.me/49d503bf47879ffe8a169dd81c744d83_b.jpg&#34; alt=&#34;家族示意图&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;判断一个命令是否存在&#34;&gt;判断一个命令是否存在&lt;/h2&gt;

&lt;p&gt;如判断&lt;code&gt;nc&lt;/code&gt;是否存在&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;command -v nc &amp;gt;/dev/null 2&amp;gt;&amp;amp;1 || { echo &amp;gt;&amp;amp;2 &amp;quot;I require nc but it&#39;s not installed.  Aborting.&amp;quot;; exit 1; }

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if ! command -v pip &amp;gt; /dev/null 2&amp;gt;&amp;amp;1;then
    echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;PIP=$(which pip)
if [ ! -x &amp;quot;${PIP}&amp;quot; ];then
	echo &amp;quot;NO&amp;quot;
else
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;[[ ! -x $(which pip) ]] &amp;amp;&amp;amp; echo &amp;quot;No&amp;quot; || echo &amp;quot;Yes&amp;quot;

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;if (( ${+commands[pip]} )); then
	echo &amp;quot;YES&amp;quot;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;shell基本语法&#34;&gt;Shell基本语法&lt;/h2&gt;

&lt;p&gt;声明数组&lt;/p&gt;

&lt;p&gt;&lt;code&gt;arr=(item1 item2 item3)&lt;/code&gt; 使用空格分开&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;echo ${arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${arr[@]}&lt;/code&gt; 可以查看数组内的元素,&lt;code&gt;echo $arr&lt;/code&gt;只能取得第一个元素&lt;/p&gt;

&lt;p&gt;要取得数组长度,只需在名字前面加一个#,如&lt;code&gt;echo ${#arr[*]}&lt;/code&gt; 或者 &lt;code&gt;echo ${#arr[@]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;数组下标以0开始,取得第二个元素为&lt;code&gt;echo ${arr[1]}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;赋值使用&lt;code&gt;arr[5]=5555&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>玩转树莓派</title>
      <link>http://blog.suconghou.cn/post/play-with-raspberrypi/</link>
      <pubDate>Sun, 17 Jan 2016 22:21:49 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/play-with-raspberrypi/</guid>
      <description>

&lt;h2 id=&#34;安装其他操作系统&#34;&gt;安装其他操作系统&lt;/h2&gt;

&lt;h3 id=&#34;centos&#34;&gt;CentOS&lt;/h3&gt;

&lt;p&gt;CentOS7官方支持了AMRV7发布了树莓派2、香蕉派、以及CubitTruck单片机的版本&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://mirror.centos.org/altarch/7/isos/armhfp/&#34;&gt;CentOS7官方下载&lt;/a&gt;
root 密码 centos&lt;/p&gt;

&lt;h3 id=&#34;archlinux&#34;&gt;ArchLinux&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://archlinuxarm.org/platforms/armv7/broadcom/raspberry-pi-2&#34;&gt;armv7 raspberry-pi-2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://archlinuxarm.org/platforms/armv6/raspberry-pi&#34;&gt;armv6 raspberry-pi&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;安装osmc&#34;&gt;安装OSMC&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://software.opensuse.org/download.html?project=home:osmc&amp;amp;package=osmc-installer&amp;amp;hcolor=17394a&amp;amp;fcolor=17394a&amp;amp;acolor=17394a&#34;&gt;osmc-installer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或者安装OSMC转为树莓派制作的系统&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://osmc.tv/download/&#34;&gt;下载一览&lt;/a&gt;,选择&lt;code&gt;Disk images&lt;/code&gt;,此系统较省资源,默认开机进入OSMC,img.gz 大小约160M&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;OSMC_FILE=OSMC_TGT_rbp2_20160621.img.gz
cd /data/tmp
axel -n 20 http://download.osmc.tv/installers/diskimages/$OSMC_FILE
md5sum $OSMC_FILE
ls -lh
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;使用清华大学镜像站国内下载速度更快: &lt;a href=&#34;https://mirrors.tuna.tsinghua.edu.cn/osmc/osmc/download/installers/&#34;&gt;https://mirrors.tuna.tsinghua.edu.cn/osmc/osmc/download/installers/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;插入内存卡,开始烧写到内存卡中.烧写之前需要取消挂载&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diskutil list&lt;/code&gt; 查看你的内存卡的挂载位置,取消挂载&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;diskutil unmountdisk /dev/disk2&lt;/code&gt; 取消挂载,需要稍等一小会.&lt;/p&gt;

&lt;p&gt;烧写,烧写过程中读卡器不断闪烁.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gzip -dc /data/tmp/$OSMC_FILE | sudo dd of=/dev/disk2 bs=8k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;dd的用法: &lt;code&gt;dd if=/dev/zero of=hello.txt bs=1024&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;dd过程中看不到进度,如果确实想要了解进度,可以再开一个终端&lt;code&gt;pkill -USR1 -n -x dd&lt;/code&gt;查看进度.&lt;/p&gt;

&lt;p&gt;除了OSMC默认皮肤,还有一些好看的皮肤推荐&lt;/p&gt;

&lt;p&gt;1.&lt;a href=&#34;http://forum.kodi.tv/showthread.php?tid=187071&#34;&gt;Eminence&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;2.&lt;a href=&#34;http://forum.kodi.tv/showthread.php?tid=214146&#34;&gt;Bello&lt;/a&gt; 看github,支持中文&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://forum.kodi.tv/forumdisplay.php?fid=26&#34;&gt;官方论坛&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OSMC默认的ssh连接用户是 osmc 密码 osmc&lt;/p&gt;

&lt;h2 id=&#34;安装openelec&#34;&gt;安装openelec&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://openelec.tv/get-openelec&#34;&gt;openelec&lt;/a&gt; 镜像下载,osmc是基于debain的,系统更加完善.此系统相比osmc更加精简,是专为跑kodi精简的系统. img.gz 大小约102M&lt;/p&gt;

&lt;h2 id=&#34;安装xbian&#34;&gt;安装xbian&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://www.xbian.org/&#34;&gt;http://www.xbian.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;与openelec,osmc都是类似,img.gz较大,大约316MB&lt;/p&gt;

&lt;h2 id=&#34;安装chromeos&#34;&gt;安装ChromeOs&lt;/h2&gt;

&lt;p&gt;ChromeOs已经有支持树莓派的版本了,&lt;a href=&#34;www.chromiumosforsbc.org&#34;&gt;www.chromiumosforsbc.org&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用镜像加速homebrew</title>
      <link>http://blog.suconghou.cn/post/homebrew-speedup/</link>
      <pubDate>Fri, 15 Jan 2016 12:56:53 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/homebrew-speedup/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;http://mirrors.ustc.edu.cn/&#34;&gt;中国科大镜像站&lt;/a&gt; 提供 Debian, Ubuntu, Fedora, Archlinux, CentOS 等多个发行版的官方源.
还有brew 的二进制源,brew使用此配置能大大提升速度.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /usr/local
git remote set-url origin git://mirrors.ustc.edu.cn/brew.git
git remote -v
brew update
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;修改二进制源见&lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/homebrew-bottles&#34;&gt;https://lug.ustc.edu.cn/wiki/mirrors/help/homebrew-bottles&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;即&lt;code&gt;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;brew config&lt;/code&gt; 查看&lt;code&gt;ORIGIN&lt;/code&gt;和&lt;code&gt;HOMEBREW_BOTTLE_DOMAIN&lt;/code&gt;已经是新的&lt;code&gt;mirrors.ustc.edu.cn&lt;/code&gt;即为配置成功&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew list&lt;/code&gt; 列出所有安装的模块&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew search mysql&lt;/code&gt; 查找&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew commands&lt;/code&gt; 查看所有命令&lt;/p&gt;

&lt;p&gt;安装（需要 Ruby）：
&lt;code&gt;ruby -e &amp;quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&amp;quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;搜索：&lt;code&gt;brew search mysql&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;查询：&lt;code&gt;brew info mysql&lt;/code&gt; 主要看具体的信息，比如目前的版本，依赖，安装后注意事项等&lt;/p&gt;

&lt;p&gt;更新：&lt;code&gt;brew update&lt;/code&gt; 这会更新 Homebrew 自己，并且使得接下来的两个操作有意义——&lt;/p&gt;

&lt;p&gt;检查过时（是否有新版本）：&lt;code&gt;brew outdated&lt;/code&gt; 这回列出所有安装的软件里可以升级的那些&lt;/p&gt;

&lt;p&gt;升级：&lt;code&gt;brew upgrade&lt;/code&gt; 升级所有可以升级的软件们&lt;/p&gt;

&lt;p&gt;清理：&lt;code&gt;brew cleanup&lt;/code&gt; 清理不需要的版本极其安装包缓存&lt;/p&gt;

&lt;p&gt;一些必备的软件.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; brew install vim git git-lfs subversion node go python3 nginx hugo openssl htop ffmpeg xz aria2 wget axel memcached redis mcrypt md5sha1sum fswatch mpv
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Chrome浏览器安装</title>
      <link>http://blog.suconghou.cn/post/broswer-chrome/</link>
      <pubDate>Thu, 14 Jan 2016 17:11:34 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/broswer-chrome/</guid>
      <description>

&lt;h2 id=&#34;配置chrome跨域&#34;&gt;配置Chrome跨域&lt;/h2&gt;

&lt;p&gt;Chrome 浏览器配置可以跨域&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --disable-web-security&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者&lt;/p&gt;

&lt;p&gt;&lt;code&gt;open -a &amp;quot;Google Chrome&amp;quot; --args --disable-web-security&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;必须完全退出Chrome,再使用上述方法.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Crontab与自动备份</title>
      <link>http://blog.suconghou.cn/post/use-crontab-in-your-server/</link>
      <pubDate>Tue, 12 Jan 2016 13:10:21 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-crontab-in-your-server/</guid>
      <description>

&lt;h2 id=&#34;crontab使用&#34;&gt;Crontab使用&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;crontab -l&lt;/code&gt; 查看当前用户的crontab列表
使用&lt;code&gt;crontab -e&lt;/code&gt;开始编辑规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;基本格式 :
*　　*　　*　　*　　*　　command
分　 时 　日 　月　 周　 命令

* 第1列表示分钟1～59 每分钟用*或者*/1表示
* 第2列表示小时1～23（0表示0点）
* 第3列表示日期1～31
* 第4列表示月份1～12
* 第5列标识号星期0～6（0表示星期天）
* 第6列要运行的命令
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;禁止Crontab产生邮件:
在crontab末尾加上&lt;code&gt;&amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 或者 &lt;code&gt;&amp;gt; &amp;amp;&amp;gt; /dev/null&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 1 5 10 * /path/to/script.sh &amp;gt; /dev/null 2&amp;gt;&amp;amp;1
0 1 5 10 * /path/to/script.sh &amp;gt; &amp;amp;&amp;gt; /dev/null
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;定时备份数据库&#34;&gt;定时备份数据库&lt;/h2&gt;

&lt;p&gt;先写好shell脚本存入&lt;code&gt;/home/cron1.sh&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;quot;root&amp;quot;
pass=&amp;quot;root&amp;quot;
host=&amp;quot;127.0.0.1&amp;quot;
port=&amp;quot;3306&amp;quot;
dbs=&amp;quot;db1 db2 db3&amp;quot;
dir=&amp;quot;/data/backup/&amp;quot;

nowDate=`date &#39;+%Y%m%d&#39;`
nowTime=`date &#39;+%H%M&#39;`
backupdir=$dir$nowDate
timeold=`date -d &amp;quot;-1 week&amp;quot; +%Y%m%d`
delold=$dir$timeold
if [ ! -d $backupdir ]; then
  mkdir -p $backupdir
fi
if [ -d $delold ]; then
  rm -rf $delold
fi
for i in $dbs
	do
		backupFile=$backupdir/$i-$nowTime.sql
		mysqldump -u$user -p$pass -h$host -P$port --databases $i &amp;gt; $backupFile
		xz $backupFile
	done

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后定时任务&lt;code&gt;crontab -e&lt;/code&gt; 每5个小时备份一次数据库.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 */5 * * * sh /home/cron1.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用此脚本建议每20个小时以内备份一次数据库,此脚本保留最近7天备份,删除过期备份&lt;/p&gt;

&lt;h2 id=&#34;增量备份数据库&#34;&gt;增量备份数据库&lt;/h2&gt;

&lt;p&gt;先写好shell脚本存入&lt;code&gt;/home/cron2.sh&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;user=&amp;quot;root&amp;quot;
pass=&amp;quot;root&amp;quot;
host=&amp;quot;127.0.0.1&amp;quot;
port=&amp;quot;3306&amp;quot;
storedb=&amp;quot;backup&amp;quot;
backup=&amp;quot;db1.table1 db1.table2&amp;quot;

mysql -u$user -p$pass -h$host -P$port -e &amp;quot;create database if not exists $storedb&amp;quot;
for i in $backup
	do
		table=${i##*.}
		sql=&amp;quot;create table if not exists $storedb.$table like $i;replace into $storedb.$table  select * from $i ;&amp;quot;
		mysql -u$user -p$pass -h$host -P$port -e &amp;quot;$sql&amp;quot;
	done

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;数据表从源数据库中增量备份至备份数据库中的同名数据表&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 */20 * * * sh /home/cron2.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每20个小时增量备份一次&lt;/p&gt;

&lt;h2 id=&#34;更高级的文件实时同步&#34;&gt;更高级的文件实时同步&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Mac&lt;/code&gt;上可以使用&lt;code&gt;fswatch + rsync&lt;/code&gt;进行实时同步&lt;/p&gt;

&lt;p&gt;首先安装&lt;code&gt;fswatch&lt;/code&gt;,&lt;code&gt;rsync&lt;/code&gt;应该是自带了&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brew install fswatch&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;!-- fswatch -o ./ | xargs -n1 -I{} md5 --&amp;gt;

fswatch -0 /tmp | xargs -0 -n 1 echo $1

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 苏苏的博客</title>
    <link>http://blog.suconghou.cn/post/index.xml</link>
    <description>Recent content in Posts on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 13 Jan 2017 14:01:02 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>gcc</title>
      <link>http://blog.suconghou.cn/post/gcc/</link>
      <pubDate>Fri, 13 Jan 2017 14:01:02 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/gcc/</guid>
      <description>

&lt;h2 id=&#34;gcc-静态编译&#34;&gt;gcc 静态编译&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;1.c&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;

void main()
{
	printf(&amp;quot;hello&amp;quot;);
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;gcc -static --verbose -fno-builtin 1.c&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;--verbose&lt;/code&gt;是为了输入编译的详细信息&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-fno-builtin&lt;/code&gt;是阻止编译器把printf变成puts&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如果出现错误&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/bin/ld: cannot find -lc
collect2: 错误：ld 返回 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可能你还需要安装glibc的静态库&lt;/p&gt;

&lt;p&gt;&lt;code&gt;yum update &amp;amp;&amp;amp; yum install glibc-static -y&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;优化选项&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://www.zhihu.com/question/27090458&#34;&gt;https://www.zhihu.com/question/27090458&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -static -O  1.c
gcc -static -O2 1.c
gcc -static -O3 1.c
gcc -static -Os 1.c
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;错误提示&#34;&gt;错误提示&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;-pedantic&lt;/code&gt;编译选项并不能保证被编译程序与ANSI/ISO C标准的完全兼容，它仅仅只能用来帮助Linux程序员离这个目标越来越近。或者换句话说，&lt;code&gt;-pedantic&lt;/code&gt;选项能够帮助程序员发现一些不符合 ANSI/ISO C标准的代码，但不是全部，事实上只有ANSI/ISO C语言标准中要求进行编译器诊断的那些情况，才有可能被GCC发现并提出警告。&lt;/p&gt;

&lt;p&gt;除了&lt;code&gt;-pedantic&lt;/code&gt;之外，GCC还有一些其它编译选项也能够产生有用的警告信息。这些选项大多以-W开头，其中最有价值的当数&lt;code&gt;-Wall&lt;/code&gt;了，使用它能够使GCC产生尽可能多的警告信息。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -Wall test.c -o test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;GCC给出的警告信息虽然从严格意义上说不能算作错误，但却很可能成为错误的栖身之所。一个优秀的Linux程序员应该尽量避免产生警告信息，使自己的代码始终保持标准、健壮的特性。所以将警告信息当成编码错误来对待，是一种值得赞扬的行为！所以，在编译程序时带上-Werror选项，那么GCC会在所有产生警告的地方停止编译，迫使程序员对自己的代码进行修改，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;gcc -Werror test.c -o test
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;调试选项&#34;&gt;调试选项&lt;/h2&gt;

&lt;p&gt;1) -g选项，产生供gdb调试用的可执行文件：&lt;code&gt;gcc -g helloworld.c&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;产生一个叫作a.out的可执行文件，大小明显比只用-o选项编译汇编连接后的文件大。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;2) -pg选项，产生供gprof剖析用的可执行文件：&lt;code&gt;gcc -pg helloworld.c&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;产生一个叫作a.out的执行文件，大小明显比用-g选项后产生的文件还大。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>系统安全</title>
      <link>http://blog.suconghou.cn/post/server-safe/</link>
      <pubDate>Sun, 20 Nov 2016 22:12:25 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/server-safe/</guid>
      <description>

&lt;h2 id=&#34;nginx安全配置&#34;&gt;Nginx安全配置&lt;/h2&gt;

&lt;p&gt;如果你是用&lt;code&gt;git&lt;/code&gt;或者&lt;code&gt;svn&lt;/code&gt;来部署代码,默认情况下,你的网站很可能已经泄露了&lt;code&gt;.git&lt;/code&gt;目录,或者&lt;code&gt;.svn&lt;/code&gt;目录&lt;/p&gt;

&lt;p&gt;使用nginx配置过滤一切以&lt;code&gt;.&lt;/code&gt;开头的文件和文件夹,防止被用户下载.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;location ~ /\. {
	deny all;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个网站都需要这么配置可能有些麻烦,你可以在统一的文件中定义好&lt;code&gt;/etc/nginx/default.d/php.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;listen 80;
index index.html index.php;
try_files $uri $uri/ /index.php?$args;
location ~ /\. {
	deny all;
}
location ~ ^.+\.php$ {
	try_files $uri =404;
	fastcgi_pass 127.0.0.1:9000;
	include fastcgi.conf;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用时,类似与下面,还不用每次写这么多配置了.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;server{
  server_name fed-wx.xxx.cn;
  root /data/www/fed-wx;
  include /etc/nginx/default.d/php.conf;
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给http段添加,开启一些gzip特性,关闭显示服务器版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;default_type        application/octet-stream;
sendfile            on;
tcp_nopush          on;
tcp_nodelay         on;
keepalive_timeout   65;
types_hash_max_size 2048;
server_tokens off;
ssi on;
gzip on;
gzip_min_length 1024;
gzip_proxied any;
gzip_comp_level 3;
gzip_types text/plain text/javascript text/css text/json application/xml application/javascript  application/json image/jpeg image/gif image/png;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;修改你的ssh默认端口-并且使用强密码&#34;&gt;修改你的SSH默认端口,并且使用强密码&lt;/h2&gt;

&lt;p&gt;每天都有大量的端口扫描来扫描你服务器IP的22端口,如果你的22端口密码又不强,很可能已被黑客侵入.&lt;/p&gt;

&lt;p&gt;如果发现已经有大量的错误登陆,请立即更换端口.必要时考虑使用&lt;code&gt;fail2ban&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;所有的网络通信都应该使用-https&#34;&gt;所有的网络通信都应该使用&lt;code&gt;HTTPS&lt;/code&gt;&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;http&lt;/code&gt;并不安全,很有可能你收到和发出的信息,已被中间人劫持.&lt;/p&gt;

&lt;p&gt;中间人劫持能查看你发送的信息,修改返回给你的数据包.&lt;/p&gt;

&lt;p&gt;为此,使用http时,务必加盐加密你的密码,以减少在传输过程中被窃取的可能.&lt;/p&gt;

&lt;p&gt;更有效的是使用&lt;code&gt;https&lt;/code&gt;来有效防止中间人劫持.&lt;/p&gt;

&lt;h2 id=&#34;你的身份认证令牌应该多方关联&#34;&gt;你的身份认证令牌应该多方关联.&lt;/h2&gt;

&lt;p&gt;即便使用&lt;code&gt;https&lt;/code&gt;,你的身份认证令牌,一旦从其他渠道泄漏,黑客便能使用你的身份进行操作.&lt;/p&gt;

&lt;p&gt;特别是具有管理员权限的身份令牌,更是会带来严重后果,在&lt;code&gt;CSRF&lt;/code&gt;攻击中偷走令牌是常有的事.&lt;/p&gt;

&lt;p&gt;因此你起码需要将cookie关键信息设置为&lt;code&gt;httponly&lt;/code&gt;和&lt;code&gt;security&lt;/code&gt;(使用https时),并小心过滤允许用户输入的链接地址(包含图片,视频地址)和富文本等.
必要时开启&lt;code&gt;csrf-token&lt;/code&gt;认证.&lt;/p&gt;

&lt;p&gt;还需要确保你的认证&lt;code&gt;token&lt;/code&gt;在丢失以后也不能在黑客手中登陆.&lt;/p&gt;

&lt;p&gt;这需要你在生成&lt;code&gt;token&lt;/code&gt;时,进行多方关联,哈希时可包括&lt;code&gt;IP地址&lt;/code&gt;,&lt;code&gt;User Agent&lt;/code&gt;,当然用户ID也需要关联,这个&lt;code&gt;token&lt;/code&gt;只能这个用户用.&lt;/p&gt;

&lt;p&gt;服务器验证时并不是从&lt;code&gt;token&lt;/code&gt;能找到用户,就验证通过,还需要对这些信息进行校验,验证还是不是那个客户端发出的.&lt;/p&gt;

&lt;p&gt;除此之外,哈希时不能简单的哈希,还需要加盐哈希,防止黑客拆解出哈希包含的字段进而可以自己算出token.&lt;/p&gt;

&lt;p&gt;即使黑客不能拆解你的哈希算法,也不知道哈希字段有哪些,只要他能捕获你发出的请求,(或窃取走你的token和所有可能参与哈希的字段),一样可以模拟请求,使用你的身份进行操作,除非你哈希时包含了IP.
因为来源IP黑客是无法模拟的,除非他和你在同一个外网出口IP路由下.&lt;/p&gt;

&lt;p&gt;但如果客户的IP经常变动,IP参与哈希可能体验太不好了,于是还是回到最初的问题,&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;使用&lt;code&gt;https&lt;/code&gt;,使用&lt;code&gt;httponly&lt;/code&gt;和&lt;code&gt;security&lt;/code&gt;的cookie,便能有效防止黑客捕获你的请求和偷走&lt;code&gt;token&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;再加上&lt;strong&gt;&lt;code&gt;token&lt;/code&gt;关联校验策略&lt;/strong&gt;, 再加上&lt;strong&gt;&lt;code&gt;token&lt;/code&gt;有效期滚动延期策略&lt;/strong&gt;,三道屏障保护你的身份不被黑客冒用.&lt;/p&gt;

&lt;h2 id=&#34;合适和正确的验证码&#34;&gt;合适和正确的验证码&lt;/h2&gt;

&lt;p&gt;一上来就给用户弹验证码未免也太不友好了,合适的做法是账户最近连续3次登陆都是错误登陆再弹出高强度的验证码.&lt;/p&gt;

&lt;p&gt;这很好实现,只需一个字段就能带来好的体验.&lt;/p&gt;

&lt;p&gt;毕竟正常的用户大部分时间都是一次登陆成功.&lt;/p&gt;

&lt;p&gt;用户使用过的验证码一定不能再次用来验证,要保证每次身份验证都是一个新的验证码.&lt;/p&gt;

&lt;p&gt;不能拿一次对的验证码去重复尝试验证用户名,密码,否则等同于没有验证码.&lt;/p&gt;

&lt;p&gt;即便使用了验证码,也是不可信的,现在的打码平台已近非常成熟了,简单的验证码也很容易做到机器识别了.&lt;/p&gt;

&lt;p&gt;还应该限制用户登陆错误次数,一小时10次或一天30次不能再多了.&lt;/p&gt;

&lt;h2 id=&#34;登陆和找回密码返回合适的信息&#34;&gt;登陆和找回密码返回合适的信息&lt;/h2&gt;

&lt;p&gt;别再返回&lt;code&gt;用户名不存在&lt;/code&gt;了,或者&lt;code&gt;密码不正确&lt;/code&gt;了&lt;/p&gt;

&lt;p&gt;为了这一点点的客户体验,你将带来巨大的安全隐患.你的网站存在用户遍历漏洞.&lt;/p&gt;

&lt;p&gt;黑客可以很轻松的知道一个用户有没有在你的网站注册.&lt;/p&gt;

&lt;p&gt;黑客手中有大量的泄漏账户信息,一些有价值的账户就值得黑客深挖,通过此漏洞,黑客很容易找到哪些用户都有哪些账户.&lt;/p&gt;

&lt;p&gt;更可怕的是,大部分人不同网站的密码是相同的.也许你的网站安全性很好,还使用了https,但是黑客只要攻破了防线最弱的那个网站拿到用户的密码,你所说的安全也就全瓦解了.&lt;/p&gt;

&lt;p&gt;因此给出&lt;code&gt;用户名或密码错误&lt;/code&gt;和找回密码每次都需要高强度验证码,并且返回&lt;code&gt;如果你已注册,邮件已发送到您注册时的邮箱&lt;/code&gt;才是有效安全的方式.&lt;/p&gt;

&lt;h2 id=&#34;可怕的撞库&#34;&gt;可怕的撞库&lt;/h2&gt;

&lt;p&gt;大部分人不同网站的密码相同,作为使用者个人值得注意,需要为每个网站设置不同的密码,防止一个的密码泄露,其他网站的密码也不安全了.&lt;/p&gt;

&lt;p&gt;作为系统设计者,也需要注意,最基本的密码不能明文存储,其次密码需要加盐存储.再者所有用户的盐不能都是一个,需要每个用户都有自己的盐.&lt;/p&gt;

&lt;p&gt;做到即使被脱库,也不能直接得到密码,即使观测所有密文和盐,知道部分用户的明文密码,也不能拆解出其他用户的明文密码.(这就需要每个用户有自己的盐)&lt;/p&gt;

&lt;p&gt;密文切记不要直接md5,或者md5加固定盐.这些都已不在安全.&lt;/p&gt;

&lt;h2 id=&#34;修改关键信息时必须验证&#34;&gt;修改关键信息时必须验证&lt;/h2&gt;

&lt;p&gt;为避免黑客盗取了身份认证信息,冒用正常用户,去修改邮箱,手机号等关键信息.&lt;/p&gt;

&lt;p&gt;在修改之前一定需要二次验证.&lt;/p&gt;

&lt;p&gt;否则手机号被修改,您账户里的财产在做变动时,验证码就发送到黑客修改过的手机上了,黑客顺利成章的就完成了交易.&lt;/p&gt;

&lt;h2 id=&#34;邮箱和手机号已不在是有效凭据&#34;&gt;邮箱和手机号已不在是有效凭据&lt;/h2&gt;

&lt;p&gt;即使使用手机号和邮箱来标示一个用户,那也不一定是正确的.&lt;/p&gt;

&lt;p&gt;目前黑市上已经有很多成熟的产业链,黑客花少量的钱就能很快拥有数以万计的手机号和邮箱,能便捷的发送和接收验证码.&lt;/p&gt;

&lt;p&gt;有利可图的地方就有黑客存在,在发放红利时须倍加小心.&lt;/p&gt;

&lt;h2 id=&#34;手势解锁安全吗&#34;&gt;手势解锁安全吗&lt;/h2&gt;

&lt;p&gt;大部分的手势解锁都是靠次数和时间限制,但是程序在客户端,黑客很容易修改程序配置文件,达到无限次尝试.&lt;/p&gt;

&lt;p&gt;并且手势密码的验证大部分都是本地验证,意味着黑客根本不需要与服务器端交互,有很多方式攻破程序里的本地认证&lt;/p&gt;

&lt;p&gt;因此手势密码只防君子,不妨小人,不要把它作为十分安全的验证,在做敏感操作时务必联网验证用户密码.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>use kvm</title>
      <link>http://blog.suconghou.cn/post/use-kvm/</link>
      <pubDate>Tue, 18 Oct 2016 19:18:24 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-kvm/</guid>
      <description>

&lt;h1 id=&#34;安装和配置kvm&#34;&gt;安装和配置KVM&lt;/h1&gt;

&lt;h2 id=&#34;kvm与xen区别&#34;&gt;KVM与XEN区别&lt;/h2&gt;

&lt;p&gt;OPENVZ就不说了,是半虚拟化,不能安装Windows操作系统&lt;/p&gt;

&lt;p&gt;KVM是内核模块,从2.6.20内核开始,kvm模块就包含在Linux内核中,只需加载此模块即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#查看宿主机CPU是否在硬件上支持虚拟化扩展特性
cat /proc/cpuinfo | grep -E &amp;quot;(vmx|svm)&amp;quot;

#加载kvm模块（Intel VT）
modprobe kvm
modprobe kvm-intel
#注意：如果加载失败，说明服务器硬件不支持或BIOS中未开启虚拟化扩展
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行命令&lt;code&gt;lsmod | grep kvm&lt;/code&gt;检查 KVM 模块是否成功安装&lt;/p&gt;

&lt;p&gt;XEN是一套虚拟化方案,可以直接安装,不需要先安装操作系统.&lt;/p&gt;

&lt;p&gt;KVM起步较晚,XEN起步早发展成熟,但目前KVM潜力较大.&lt;/p&gt;

&lt;h2 id=&#34;kvm-与-qemu&#34;&gt;KVM 与 qemu&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;yum install qemu-kvm libvirt virt-install bridge-utils&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;qemu-kvm 该软件包主要包含KVM内核模块和适用于KVM的QEMU模拟器。KVM模块负责CPU和内存的调度，QEMU负责虚拟机I/O设备的模拟。&lt;/p&gt;

&lt;p&gt;libvirt 提供Hypervisor和虚拟机的管理功能。&lt;/p&gt;

&lt;p&gt;virt-install 创建和克隆虚拟机的命令行工具包。&lt;/p&gt;

&lt;p&gt;bridge-utils 网桥管理工具包，负责桥接网络的创建、配置和管理等工作。&lt;/p&gt;

&lt;h2 id=&#34;激活并启动libvirtd服务&#34;&gt;激活并启动libvirtd服务&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable libvirtd
systemctl start libvirtd
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装centos7&#34;&gt;安装CentOS7&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;diskutil list&lt;/code&gt;查看所有磁盘&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diskutil unmountdisk /dev/disk1&lt;/code&gt; 解除其挂载&lt;/p&gt;

&lt;p&gt;用dd将ISO文件写入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo dd if=/data/files/iso/CentOS-7-x86_64-Minimal-1511.iso of=/dev/disk2 bs=1m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装好系统后,更换网易的源 &lt;a href=&#34;http://mirrors.163.com/.help/centos.html&#34;&gt;http://mirrors.163.com/.help/centos.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
cd /etc/yum.repos.d
wget http://mirrors.163.com/.help/CentOS7-Base-163.repo
yum clean all
yum makecache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜狐也有,但版本太老 &lt;a href=&#34;http://mirrors.sohu.com/help/centos.html&#34;&gt;http://mirrors.sohu.com/help/centos.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以使用清华大学的. &lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/centos&#34;&gt;https://lug.ustc.edu.cn/wiki/mirrors/help/centos&lt;/a&gt; 速度都十分快.&lt;/p&gt;

&lt;h2 id=&#34;启用kvm后-需要配置网卡&#34;&gt;启用KVM后,需要配置网卡&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cd /etc/sysconfig/network-scripts/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;桥接网卡&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl addbr br0&lt;/code&gt; 添加一个虚拟网卡&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl addif br0 em2&lt;/code&gt; 将网卡&lt;code&gt;br0&lt;/code&gt;桥接到&lt;code&gt;em2&lt;/code&gt; ,这一步将会导致em2断网,远程ssh将会断开&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl stp br0 on&lt;/code&gt; 将br0设置为启用STP协议&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ifconfig em2 0&lt;/code&gt; #将em2的IP设置为0&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dhclient br0&lt;/code&gt; #将br0网络配置好&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl show&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后&lt;code&gt;systemctl restart network&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;route&lt;/code&gt; 查看默认网关&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://wiki.centos.org/zh/HowTos/KVM&#34;&gt;https://wiki.centos.org/zh/HowTos/KVM&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;创建虚拟机磁盘镜像文件&#34;&gt;创建虚拟机磁盘镜像文件&lt;/h2&gt;

&lt;p&gt;不能创建太小,建议5G-50G&lt;/p&gt;

&lt;p&gt;qcow2格式是kvm支持的标准格式，raw格式为虚拟磁盘文件通用格式。有测试数据表明raw格式的I/O性能略高于qcow2格式，但是在加密，容量，快照方面qcow2格式有优势&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qemu-img create -f qcow2 test.qcow2 20G  //建立qcow2格式磁盘文件
qemu-img create -f raw test.raw 20G      //建立raw格式磁盘文件
qemu-img info test.qcow2                 //查看已经创建的虚拟磁盘文件

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;创建虚拟机&#34;&gt;创建虚拟机&lt;/h2&gt;

&lt;p&gt;使用&lt;code&gt;osinfo-query os&lt;/code&gt;可以查看&lt;code&gt;os-variant&lt;/code&gt;都有哪些代号&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://raymii.org/s/articles/virt-install_introduction_and_copy_paste_distro_install_commands.html&#34;&gt;https://raymii.org/s/articles/virt-install_introduction_and_copy_paste_distro_install_commands.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;创建 Ubuntu&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name ubuntu \
--ram 512 --vcpus 1 \
--boot network,cdrom,menu=on \
--disk path=/disk/kvm/disk1,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--nographics --accelerate \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--cdrom=/data/iso/ubuntu-16.04.1-server-amd64.iso \
--extra-args=&#39;console=tty0 console=ttyS0,115200n8 serial&#39; \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建CentOS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name centos \
--ram 512 --vcpus 1 \
--disk path=/disk/kvm/disk1,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--accelerate \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--location=/data/iso/CentOS-7-x86_64-Minimal-1511.iso \
--extra-args=&#39;console=tty0 console=ttyS0,115200n8 serial&#39; \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;virsh &amp;ndash;connect qemu:///system&lt;/p&gt;

&lt;p&gt;创建Debain&lt;/p&gt;

&lt;p&gt;先挂载 &lt;code&gt;sudo mount -o loop,unhide -t iso9660 -r /data/iso/debian-8.6.0-amd64-CD-1.iso /mnt/cdrom&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要nfs启动 &lt;code&gt;service nfs start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;/mnt/cdrom    *(ro,insecure,all_squash)&lt;/code&gt;到文件&lt;code&gt;/etc/exports&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;并刷新&lt;code&gt;exportfs -r&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name debain \
--ram 512 --vcpus 1 \
--boot network,cdrom,menu=on \
--disk path=/disk/kvm/disk4,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--accelerate \
--location=/mnt/cdrom \
--extra-args=&#39;console=tty0 console=ttyS0,115200n8 serial&#39; \
--vnc --vncport=5911 --vnclisten=0.0.0.0 \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建Windows Server&lt;/p&gt;

&lt;p&gt;&lt;code&gt;qemu-img create -f qcow2 /disk/kvm/windisk1 50G&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;针对Windows需要安装一些驱动&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo wget https://fedorapeople.org/groups/virt/virtio-win/virtio-win.repo -O /etc/yum.repos.d/virtio-win.repo&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo yum install virtio-win&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fedoraproject.org/wiki/Windows_Virtio_Drivers&#34;&gt;https://fedoraproject.org/wiki/Windows_Virtio_Drivers&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name windows2012 \
--ram 4096 --vcpus 2 \
--disk path=/data/iso/cn_windows_server_2012_r2_with_update_x64_dvd_4048415.iso,device=cdrom \
--disk path=/disk/kvm/windisk1,size=50,format=qcow2,bus=virtio,cache=writeback \
--cdrom=/usr/share/virtio-win/virtio-win-0.1.126.iso \
--os-type windows \
--os-variant win2k12r2 \
--bridge=br0,model=virtio \
--accelerate \
--graphics vnc,port=5999,listen=0.0.0.0 \
--console pty,target_type=serial \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name xp1 \
--ram 1024 --vcpus 1 \
--disk path=/data/iso/Deepin_Windows_LiteXP_v6.2_SP3.iso,device=cdrom \
--disk path=/disk/kvm/winxp1,size=10,format=qcow2,bus=virtio,cache=writeback \
--cdrom=/usr/share/virtio-win/virtio-win-0.1.126.iso \
--os-type windows \
--os-variant winxp \
--bridge=br0,model=virtio \
--accelerate \
--graphics vnc,port=5999,listen=0.0.0.0 \
--console pty,target_type=serial \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;出现&lt;code&gt;ERROR    不能混用 --graphics 和旧式的图形选项&lt;/code&gt;可能是需要去掉&lt;code&gt;--keymap&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;关于 加载 virtio 驱动可以参考  &lt;a href=&#34;http://www.ilanni.com/?p=5877&#34;&gt;http://www.ilanni.com/?p=5877&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;选择加载&lt;code&gt;viostor&lt;/code&gt;磁盘驱动&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;disk属性就是指虚拟机使用哪一个磁盘镜像文件作为存储地方，指定刚才创建的镜像文件位置即可，size=10,format=qcow2,bus=virtio分别是指大小，格式（跟镜像格式一致），磁盘总线类型（指Value can be ’ide’, ’scsi’, ’usb’, ’virtio’ or ’xen’，virtio是专门为kvm制定的bus，比较常用），大小需要比镜像文件大小要小，相当于镜像是容器，这个disk是里面的水，水太多就溢出了。&lt;/p&gt;

&lt;p&gt;bridge=br0,model=virtio –keymap=en-us分别指网卡使用，网卡模式即驱动模式，和键盘制式，桥接模式都使用br0，而虚拟机需要使用virtio这个驱动才能使用虚拟网卡，这个虚拟网卡驱动在linux下支持很好，在windows下支持一般，键盘制式如果不指定的话会出现键位错乱的情况，一般我们使用英式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用&lt;code&gt;virsh&lt;/code&gt;可以管理已创建的虚拟机&lt;/p&gt;

&lt;p&gt;virsh shutdown demo 正常关闭虚拟机&lt;/p&gt;

&lt;p&gt;virsh destroy demo 直接销毁虚拟机&lt;/p&gt;

&lt;p&gt;可见 &lt;a href=&#34;http://www.cnblogs.com/lin1/p/5776280.html&#34;&gt;http://www.cnblogs.com/lin1/p/5776280.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;启动并进入虚拟机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virsh start 域名 --console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10，彻底删除虚拟机&lt;/p&gt;

&lt;p&gt;1,删除虚拟机   virsh destroy +域名&lt;/p&gt;

&lt;p&gt;2，解除标记     virsh undefine +域名&lt;/p&gt;

&lt;p&gt;3，删除虚拟机文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;virsh destroy windows2012 &amp;amp;&amp;amp;  virsh undefine windows2012&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过virt-clone命令克隆虚拟机&lt;/p&gt;

&lt;p&gt;&lt;code&gt;virt-clone -o centos -n centos2 -f /disk/kvm/disk2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;virsh -c qemu:///system list&lt;/code&gt; 可以查看正在运行的机器&lt;/p&gt;

&lt;p&gt;&lt;code&gt;virsh vncdisplay windows2012&lt;/code&gt;查看vnc端口&lt;/p&gt;

&lt;p&gt;可以使用其他机器上的vnc  viewer 连接&lt;/p&gt;

&lt;p&gt;本机 &lt;code&gt;virt-viewer --connect qemu:///system windows2012&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;windows系统可使用 vncviewer (&lt;a href=&#34;http://share.suconghou.cn/files/bin/vncviewer.zip&#34;&gt;http://share.suconghou.cn/files/bin/vncviewer.zip&lt;/a&gt;) 连接&lt;/p&gt;

&lt;p&gt;全屏下用F8键可唤出菜单.&lt;/p&gt;

&lt;h3 id=&#34;修改相关&#34;&gt;修改相关&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;hostnamectl&lt;/code&gt; 可以查看主机相关信息,主机名,内核版本,64位等&lt;/p&gt;

&lt;p&gt;只查看静态、瞬态或灵活主机名，分别使用&lt;code&gt;--static&lt;/code&gt;,&lt;code&gt;--transient&lt;/code&gt;或&lt;code&gt;--pretty&lt;/code&gt;选项&lt;/p&gt;

&lt;p&gt;要同时修改所有三个主机名：静态、瞬态和灵活主机名：
&lt;code&gt;hostnamectl set-hostname Linuxidc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;hostname -I&lt;/code&gt; 可以获取所有网卡上配置的IP&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>iptables</title>
      <link>http://blog.suconghou.cn/post/iptables/</link>
      <pubDate>Wed, 14 Sep 2016 12:24:02 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/iptables/</guid>
      <description>

&lt;h1 id=&#34;iptables相关配置&#34;&gt;iptables相关配置&lt;/h1&gt;

&lt;p&gt;配置&lt;code&gt;iptables&lt;/code&gt;之前,建议添加一个crontab定时重置iptables,防止将自己阻挡.&lt;/p&gt;

&lt;p&gt;建议写入&lt;code&gt;/usr/iptab.sh&lt;/code&gt;,加入&lt;code&gt;crontab&lt;/code&gt;,每个整点执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -P INPUT ACCEPT
iptables -P OUTPUT ACCEPT
iptables -P FORWARD ACCEPT
iptables -F
iptables -X
iptables -Z
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;查看本机关于iptables的设置情况&#34;&gt;查看本机关于IPTABLES的设置情况&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;iptables -L -n
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;清除原有规则&#34;&gt;清除原有规则.&lt;/h2&gt;

&lt;p&gt;不管你在安装linux时是否启动了防火墙,如果你想配置属于自己的防火墙,那就清除现在filter的所有规则.
清除预设表filter中的所有规则链的规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -F
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;清除预设表filter中使用者自定链中的规则&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -X
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;保存配置&#34;&gt;保存配置&lt;/h2&gt;

&lt;p&gt;刚刚配置的重启以后就会丢失,想要保存使用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables save
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;有的可能是&lt;code&gt;iptables-save&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这样就写到&lt;code&gt;/etc/sysconfig/iptables&lt;/code&gt; 文件里了.
写入后记得把防火墙重起一下,才能起作用.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;service iptables restart
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;设定预设规则&#34;&gt;设定预设规则&lt;/h2&gt;

&lt;p&gt;默认的入口,出口,转发策略都是ACCEPT
下面要改变这种规则&lt;/p&gt;

&lt;p&gt;iptables 采用黑名单加白名单的方式, 未命中白名单的将采用预设规则&lt;/p&gt;

&lt;p&gt;下面操作注意,为避免ssh端口22被拦截,首先添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --dport 22 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保证22端口入口畅通,注意如果你的OUTPUT模式设置为DROP(上面已经清空了,默认为ACCEPT),还需要添加&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;保证出口22端口畅通
下面开始折腾吧&lt;/p&gt;

&lt;p&gt;1.修改入口流量默认规则为DROP,除非命中用户规则,否则拦截所有入口流量(注意上面一定要排除ssh的端口,否则直接掉线)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -P INPUT DROP
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果你使用了docker,这里好像会对docker的网络造成影响&lt;/p&gt;

&lt;p&gt;2.允许所有出口流量(重置iptables时,这其实就是默认的规则)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -P OUTPUT ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.禁止所有转发流量,除了命中用户规则的&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -P FORWARD DROP
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用端口开启&#34;&gt;常用端口开启&lt;/h3&gt;

&lt;p&gt;开启80,443端口,http,https服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启21端口,ftp服务&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p tcp --dport 21 -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;开启基本端口&#34;&gt;开启基本端口&lt;/h3&gt;

&lt;p&gt;允许icmp包通过,也就是允许ping&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -A INPUT -p icmp -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;允许loopback!(不然会导致DNS无法正常关闭等问题)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果未启用此项,常见的fastcgi_pass 127.0.0.1 将会有问题&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;iptables -A INPUT -i lo -p all -j ACCEPT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;iptables 配置实时生效,如果拦截了ssh端口,将立即掉线!&lt;/p&gt;

&lt;p&gt;无论iptabes启动与否，ps -ef都不会看到iptables的进程，这是因为iptables是由内核来实现的，也就是说iptables的功能已经融入到内核里面了&lt;/p&gt;

&lt;p&gt;iptables只是一个工具，将IP规则写入内核，让内核去处理。所以iptables只有在加规则的时候才会看得到进程，加完了就退出了&lt;/p&gt;

&lt;p&gt;iptables并不是一个普通的daemon，只是一个普通的工具，添加一些规则到kernel的filter列表里面。&lt;/p&gt;

&lt;h3 id=&#34;ip-拦截&#34;&gt;IP 拦截&lt;/h3&gt;

&lt;p&gt;拦截一个IP&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iptables -I INPUT -s 1.2.3.4 -j DROP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;解封此IP&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iptables -D INPUT -s 1.2.3.4 -j DROP&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;参数-I是表示Insert（添加），-D表示Delete（删除）&lt;/p&gt;

&lt;p&gt;INPUT表示入站，DROP表示放弃连接&lt;/p&gt;

&lt;p&gt;IP段&lt;/p&gt;

&lt;p&gt;192.168.1.x 可以写 &lt;code&gt;192.168.1.0/24&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;192.168.x.x 可以写 &lt;code&gt;192.168.0.0/16&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;192.x.x.x   可以写 &lt;code&gt;192.0.0.0/8&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
#清除配置
/sbin/iptables -P INPUT ACCEPT
/sbin/iptables -F
/sbin/iptables -X
#开放本地和Ping
/sbin/iptables -A INPUT -i lo -j ACCEPT
/sbin/iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
/sbin/iptables -A INPUT -p icmp -j ACCEPT
#配置内网白名单
/sbin/iptables -A INPUT -s 10.0.0.0/8 -j ACCEPT
/sbin/iptables -A INPUT -s 172.16.0.0/12 -j ACCEPT
/sbin/iptables -A INPUT -s 192.168.0.0/16 -j ACCEPT
#配置外网白名单
/sbin/iptables -A INPUT -s 180.168.36.198 -j ACCEPT
/sbin/iptables -A INPUT -s 180.168.34.218 -j ACCEPT
/sbin/iptables -A INPUT -s 222.73.202.251 -j ACCEPT
#控制端口
/sbin/iptables -A INPUT -p tcp --dport 80 -j ACCEPT
/sbin/iptables -A INPUT -p tcp --dport 22 -j ACCEPT
#拒绝其它
/sbin/iptables -A INPUT -j DROP
/sbin/iptables -A FORWARD -j DROP
#开放出口
/sbin/iptables -A OUTPUT -j ACCEPT

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>pc hardware</title>
      <link>http://blog.suconghou.cn/post/pc-hardware/</link>
      <pubDate>Sun, 04 Sep 2016 14:37:51 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/pc-hardware/</guid>
      <description>

&lt;h2 id=&#34;修电脑相关知识&#34;&gt;修电脑相关知识&lt;/h2&gt;

&lt;h3 id=&#34;较好的pe&#34;&gt;较好的PE&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;微PE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wepe.com.cn/&#34;&gt;http://www.wepe.com.cn/&lt;/a&gt; 自带刻录,可以一键安装到U盘,硬盘等,支持UEFI,CMS等多种启动方式.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一般的BIOS里找不到UEFI/CMS的切换设置,可能是&lt;code&gt;security boot&lt;/code&gt;的配置,禁用&lt;code&gt;security boot&lt;/code&gt;试试&lt;/p&gt;

&lt;p&gt;如果在BIOS里找不到U盘,可能是&lt;code&gt;fastboot&lt;/code&gt;的问题,可以禁用fastboot,安装好系统后在开启.&lt;/p&gt;

&lt;p&gt;硬盘的设置模式里,找不到U盘或者硬盘,可以尝试切换&lt;code&gt;AHCI/IDE&lt;/code&gt;,注意安装好系统后,此选项不能够再随意切换,否知导致系统进不去.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;休眠能将现有所有工作保存到硬盘,下次开机恢复上次的会话,Windows8及以后采用了混合休眠机制&lt;/p&gt;

&lt;p&gt;你可能找不到单纯的休眠按钮.&lt;/p&gt;

&lt;p&gt;可以使用&lt;code&gt;shutdown -h&lt;/code&gt;休眠&lt;/p&gt;

&lt;p&gt;其他一些补充&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关机计算机：shutdown.exe -s -t 00
重启计算机：shutdown.exe -r -t 00
注销计算机：shutdown.exe -l -t 00
锁定计算机：rundll32.exe user32.dll,LockWorkStation
休眠计算机：rundll32.exe powrProf.dll,SetSuspendState
睡眠计算机：rundll32.exe powrprof.dll,SetSuspendState 0,1,0,
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;性能天梯图&#34;&gt;性能天梯图&lt;/h2&gt;

&lt;p&gt;在新标签查看大图&lt;/p&gt;

&lt;p&gt;CPU天梯图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.alicdn.com/imgextra/i4/693806815/TB2ulpikCxjpuFjSszeXXaeMVXa_!!693806815.jpg&#34; alt=&#34;CPU天梯图1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CPU天梯图其他版本&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.alicdn.com/imgextra/i3/693806815/TB2KExqkwRkpuFjy1zeXXc.6FXa_!!693806815.jpg&#34; alt=&#34;CPU天梯图2&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显卡天梯图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://img.alicdn.com/imgextra/i1/693806815/TB2heFDkB8lpuFjSspaXXXJKpXa_!!693806815.jpg&#34; alt=&#34;显卡天梯图&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>memcached usage</title>
      <link>http://blog.suconghou.cn/post/memcached-usage/</link>
      <pubDate>Wed, 24 Aug 2016 14:44:23 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/memcached-usage/</guid>
      <description>

&lt;h2 id=&#34;安装memcached&#34;&gt;安装memcached&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://memcached.org/downloads&#34;&gt;http://memcached.org/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;memcached所有版本见&lt;a href=&#34;http://www.memcached.org/files/&#34;&gt;http://www.memcached.org/files/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
MEMCACHE_VERSION=memcached-1.4.31
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.memcached.org/files/${MEMCACHE_VERSION}.tar.gz
tar xzf ${MEMCACHE_VERSION}.tar.gz
cd ${MEMCACHE_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
./configure
make -j$CPU_NUM &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker版本见:&lt;a href=&#34;https://hub.docker.com/r/suconghou/memcached/&#34;&gt;https://hub.docker.com/r/suconghou/memcached/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动memcached&#34;&gt;启动Memcached&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;memcached -d -u memcached -p 11211 -m 8 -P /var/run/memcached/memcached.pid

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-d 以daemon方式运行&lt;/li&gt;
&lt;li&gt;-u 绑定使用指定用户运行进程(仅在以root运行的时候有效)&lt;/li&gt;
&lt;li&gt;-p 设置TCP端口号(默认11211)&lt;/li&gt;
&lt;li&gt;-m 允许最大内存用量，单位M (默认: 64 MB)&lt;/li&gt;
&lt;li&gt;-M 内存耗尽时返回错误，而不是删除项&lt;/li&gt;
&lt;li&gt;-l 是监听的服务器IP地址，默认应该是本机&lt;/li&gt;
&lt;li&gt;-P 将PID写入文件&lt;file&gt;，这样可以使得后边进行快速进程终止, 需要与-d 一起使用&lt;/li&gt;
&lt;li&gt;-c 最大同时连接数，默认是1024&lt;/li&gt;
&lt;li&gt;-t 线程数,默认为4&lt;/li&gt;
&lt;li&gt;-v 输出警告和错误信息&lt;/li&gt;
&lt;li&gt;-vv 打印客户端的请求和返回信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下是不限制访问IP的,相当于是外网和内网都能访问,-l 使只有这个IP能访问&lt;/p&gt;

&lt;p&gt;尽量不要用root用户运行.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;状态查看&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 telnet 连接 memcached
&lt;code&gt;stats settings&lt;/code&gt;可以查看所有参数设置&lt;/p&gt;

&lt;p&gt;memcached状态和性能查看&lt;/p&gt;

&lt;p&gt;stats命令&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://static.suconghou.cn/document/memcached.jpg&#34; alt=&#34;memcached stats命令&#34; /&gt;&lt;/p&gt;

&lt;p&gt;官方也提供监控工具&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/memcached/memcached/blob/master/scripts/memcached-tool&#34;&gt;https://github.com/memcached/memcached/blob/master/scripts/memcached-tool&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript code snippet</title>
      <link>http://blog.suconghou.cn/post/javascript-code-snippet/</link>
      <pubDate>Thu, 11 Aug 2016 10:27:18 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-code-snippet/</guid>
      <description>

&lt;h2 id=&#34;实用的javascript代码锦集&#34;&gt;实用的Javascript代码锦集&lt;/h2&gt;

&lt;h3 id=&#34;获取查询查询字符串get参数值&#34;&gt;获取查询查询字符串get参数值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function getParam()
{
	var data = decodeURIComponent(location.href).split(&amp;quot;?&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;);
	var param = {};
	for(var i = 0; i&amp;lt;data .length; i++)
	{
		param[data [i].split(&amp;quot;=&amp;quot;)[0]] = data [i].split(&amp;quot;=&amp;quot;)[1];
	}
	return param;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于PHP中的&lt;code&gt;$_GET&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $_GET = (function()
{
	var url = decodeURIComponent(location.href);
	var u = url.split( &amp;quot;?&amp;quot; );
	if ( typeof (u[1]) == &amp;quot;string&amp;quot; )
	{
		u = u[1].split( &amp;quot;&amp;amp;&amp;quot; );
		var get = {};
		for ( var i in u)
		{
			var j = u[i].split( &amp;quot;=&amp;quot; );
			get[j[0]] = j[1];
		}
		return get;
	}
	else
	{
		return {};
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给出要获取的参数,每次都会解析一遍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getPar(par)
{
	//获取当前URL
	var local_url = decodeURIComponent(location.href);
	//获取要取得的get参数位置
	var get = local_url.indexOf(par + &amp;quot;=&amp;quot; );
	if (get == -1)
	{
		return false ;
	}
	//截取字符串
	var get_par = local_url.slice(par.length + get + 1);
	//判断截取后的字符串是否还有其他get参数
	var nextPar = get_par.indexOf( &amp;quot;&amp;amp;&amp;quot; );
	if (nextPar != -1)
	{
		get_par = get_par.slice(0, nextPar);
	}
	return get_par;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QueryString&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function QueryString(item)
{
	var value = location.search.match(new RegExp(&#39;[\?\&amp;amp;]&#39; + item + &#39;=([^\&amp;amp;]*)(\&amp;amp;?)&#39;,&#39;i&#39;));
	return value ? value[1] : value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;取得cookie中某个键的值&#34;&gt;取得Cookie中某个键的值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$.getCookie = function(name)
{
	 if(document.cookie.indexOf(name)!=-1) return document.cookie.split(name+&#39;=&#39;)[1].split(&#39;;&#39;)[0]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getcookie(cookieid)
{
	//获取cookie字符串
	var strCookie=document.cookie;
	//将多cookie切割为多个名/值对
	var arrCookie=strCookie.split(&amp;quot;; &amp;quot;);
	var cookieval;
	//遍历cookie数组，处理每个cookie对
	for(var i=0;i&amp;lt;arrCookie.length;i++)
	{
		var arr=arrCookie[i].split(&amp;quot;=&amp;quot;);
		//找到名称为userId的cookie，并返回它的值
		if(cookieid==arr[0])
		{
			cookieval=arr[1];
			break;
		}
	}
	return(cookieval);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;进入全屏&#34;&gt;进入全屏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function gofull()
{
	var el=document.documentElement;
	el.webkitRequestFullScreen&amp;amp;&amp;amp;el.webkitRequestFullScreen();
	el.mozRequestFullScreen&amp;amp;&amp;amp;el.mozRequestFullScreen();
	el.requestFullscreen&amp;amp;&amp;amp;el.requestFullscreen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串去空格&#34;&gt;字符串去空格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;String.prototype.trim=function() {return this.replace(/(^\s*)|(\s*$)/g,&amp;quot;&amp;quot;); }
String.prototype.ltrim=function(){return this.replace(/(^\s*)/g,&amp;quot;&amp;quot;); }
String.prototype.rtrim=function(){return this.replace(/(\s*$)/g,&amp;quot;&amp;quot;); }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字节格式化&#34;&gt;字节格式化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function size(size)
{
	var name=[&#39;B&#39;,&#39;KB&#39;,&#39;MB&#39;,&#39;GB&#39;,&#39;TB&#39;,&#39;PB&#39;];
	var pos=0;
	while(size&amp;gt;=1204)
	{
	    size/=1024;
	    pos++;
	}
	return size.toFixed(2)+&amp;quot; &amp;quot;+name[pos];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;判断页面滚动到底部和顶部&#34;&gt;判断页面滚动到底部和顶部&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$(document).scroll(function()
{
	if ($(document).scrollTop()&amp;lt;=0)
	{
		console.log(&amp;quot;滚动条已经到达顶部为0&amp;quot;);
	}
	if ($(document).scrollTop() &amp;gt;= $(document).height() - $(window).height())
	{
		console.log(&amp;quot;滚动条已经到达底部为&amp;quot; + $(document).scrollTop());
	}
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;运行js代码&#34;&gt;运行JS代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// execute code in the content page scope
var injectScript = function(source) {
    var script = document.createElement(&#39;script&#39;);
    script.setAttribute(&#39;type&#39;, &#39;text/javascript&#39;);
    script.textContent = &#39;;(&#39; + source.toString() + &#39;)()&#39;;
    document.body.appendChild(script);
    document.body.removeChild(script)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;添加css代码&#34;&gt;添加CSS代码&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;// insert css
function injectStyle(css) {
    var script = document.createElement(&#39;style&#39;)
    script.setAttribute(&#39;type&#39;, &#39;text/css&#39;)
    script.textContent = css
    document.head.appendChild(script)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;利用注释,可也生成html,css,js 等代码&lt;/p&gt;

&lt;p&gt;如&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(){/* body{background:#f00} */}).toString().slice(15,-4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然利用es6的字符串模板更加方便,&lt;a href=&#34;http://babeljs.io/repl/&#34;&gt;http://babeljs.io/repl/&lt;/a&gt; 在线转换为es5代码&lt;/p&gt;

&lt;h3 id=&#34;一些正则验证&#34;&gt;一些正则验证&lt;/h3&gt;

&lt;p&gt;验证邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_mail(str)
{
	return(new RegExp(/^[0-9a-zA-Z]+@(([0-9a-zA-Z]+)[.])+[a-z]{2,4}$/i).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证手机号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_tel(str)
{
	return(new RegExp(/^1[34578][0-9]{9}$/).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;base64的1x1像素间隔gif&#34;&gt;Base64的1x1像素间隔gif&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一个range函数&#34;&gt;一个range函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function range(start, count)
{
	return Array.apply(0, Array(count)).map(function (element, index)
	{
		return index + start;
	});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;简化-console-log&#34;&gt;简化&lt;code&gt;console.log&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var log = console.log.bind(console);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成较短的唯一id&#34;&gt;生成较短的唯一ID&lt;/h3&gt;

&lt;p&gt;一定年限内单线程非连续调用唯一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function shortId()
{
	var time=Date.now()+&#39;&#39;;
	time=parseInt(time.substr(1));
	return time.toString(36);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成随机短ID,仅具备较低的不重复性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var t=(((1+Math.random())*0x10000000)|0).toString(16);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成指定长度随机字符串
&lt;code&gt;PHP代码&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function code($nc, $a=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;)
{
    $l=strlen($a)-1; $r=&#39;&#39;;
    while($nc--&amp;gt;0) $r.=$a{mt_rand(0,$l)};
    return $r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;给jquery的form添加-serializeobject&#34;&gt;给jQuery的form添加&lt;code&gt;serializeObject&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.serializeObject=function()
{
	var a,o,h,i,e;
	a=this.serializeArray();
	o={};
	h=o.hasOwnProperty;
	for(i=0;i&amp;lt;a.length;i++)
	{
		e=a[i];
		if(!h.call(o,e.name))
		{
			o[e.name]=e.value;
		}
	}
	return o;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用效果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery(&amp;quot;form&amp;quot;).serialize(); //&amp;quot;username=&amp;amp;password=&amp;quot;
jQuery(&amp;quot;form&amp;quot;).serializeArray(); //[{name:&amp;quot;username&amp;quot;,value:&amp;quot;&amp;quot;},{name:&amp;quot;password&amp;quot;,value:&amp;quot;&amp;quot;}]
jQuery(&amp;quot;form&amp;quot;).serializeObject(); //{username:&amp;quot;&amp;quot;,password:&amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;资源预取&#34;&gt;资源预取&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function prefetch(url)
{
	var link = document.createElement(&amp;quot;link&amp;quot;);
	link.href = url;
	link.rel=&amp;quot;prefetch&amp;quot;;
	document.head.appendChild(link);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cookie操作&#34;&gt;Cookie操作&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function setCookie(cookiename, cookievalue, hours)
{
	var date = new Date();
	date.setTime(date.getTime() + Number(hours) * 3600 * 1000);
	document.cookie = cookiename + &amp;quot;=&amp;quot; + cookievalue + &amp;quot;; path=/;expires = &amp;quot; + date.toGMTString();
}

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用-google-analytics-统计js错误&#34;&gt;用&lt;code&gt;Google Analytics&lt;/code&gt;统计JS错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,&#39;script&#39;,&#39;https://www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);
window.addEventListener(&#39;error&#39;, function (err)
{
	ga(&#39;create&#39;, &#39;UA-xxx-1&#39;, &#39;auto&#39;);
    var lineAndColumnInfo = err.colno ? &#39; line:&#39; + err.lineno +&#39;, column:&#39;+ err.colno : &#39; line:&#39; + err.lineno;
    ga(&#39;send&#39;, &#39;event&#39;, &#39;JavaScript Error&#39;, err.message, location.href+&#39; =&amp;gt; &#39;+err.filename + lineAndColumnInfo + &#39; -&amp;gt; &#39; +  navigator.userAgent, 0, true );
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;UA-xxx-1&lt;/code&gt;使用自己的统计ID&lt;/p&gt;

&lt;h3 id=&#34;并发发送ajax&#34;&gt;并发发送ajax&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$.when($.get(&#39;assets/misc/1.json&#39;), $.get(&#39;assets/misc/2.json&#39;)).then(function(r1, r2)
{
    console.log(r1[0].message + &amp;quot; &amp;quot; + r2[0].message);
})
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;fetch跨域带cookie&#34;&gt;Fetch跨域带cookie&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fetch(url, {credentials: &#39;include&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery ajax 跨域带 cookie&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajaxSetup({xhrFields: {withCredentials: true }});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>javascript senior</title>
      <link>http://blog.suconghou.cn/post/javascript-senior/</link>
      <pubDate>Tue, 09 Aug 2016 21:27:39 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-senior/</guid>
      <description>

&lt;h2 id=&#34;javascript-参数传递&#34;&gt;Javascript 参数传递&lt;/h2&gt;

&lt;p&gt;说起参数传递,首先需要弄清楚javascript里的数据类型&lt;/p&gt;

&lt;p&gt;原始数据类型
&lt;code&gt;Undefined&lt;/code&gt; &lt;code&gt;Null&lt;/code&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;code&gt;Number&lt;/code&gt; &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用数据类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; &lt;code&gt;Date&lt;/code&gt; 等&lt;/p&gt;

&lt;p&gt;原始数据类型存储在栈的简单数据段,他们的值直接存储在变量访问的位置(因原始数据类型占据的空间是固定的,可以存储在较小的内存区域&lt;code&gt;栈&lt;/code&gt;中)&lt;/p&gt;

&lt;p&gt;引用数据类型是存储在堆中的对象,存储在变量处的值只是一个指针,指向存储对象的内存地址,这是因为引用类型的大小会改变.&lt;/p&gt;

&lt;p&gt;不同的内存分配机制带来不同的访问机制&lt;/p&gt;

&lt;p&gt;在JavaScript中,是不允许直接访问保存在堆内存中的对象的,访问对象时必须取得对象在堆内存中的地址,然后按地址去取得对象中的值.&lt;/p&gt;

&lt;p&gt;这便是传说中的按引用访问.&lt;/p&gt;

&lt;p&gt;而原始类型则是直接访问到的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复制变量时的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;会将原始值的副本赋值给新变量.此后两个变量完全独立.&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;会把内存地址赋值给新变量,也就是说两个变量都指向堆内存中的同一个对象.
他们中任何一个改变都会反映到另一个身上.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数传递的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最重要的一点:&lt;code&gt;ECMAScript&lt;/code&gt;中所有函数的参数都是按值传递的.&lt;/p&gt;

&lt;p&gt;但原始值和引用值仍会造成不同的后果.&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;把变量里的值传递给参数,之后两个变量互不影响.(就是把实参复制给形参的过程)&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;任然是将实参里面的值复制到形参,但是注意&lt;em&gt;对象变量它里面的值是这个对象的堆内存地址&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;也就是说形参和实参都是指向同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;但是也要记住另外一点:如果形参被赋值为另外一个对象时,那么这个形参将会丢弃对上次指向的堆内存地址,而指向新对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;此时,形参和实参相互脱离,互不影响,原先的实参任然指向原先对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;如果是添加修改形参的属性,那么就是修改堆内存中的对象,形参和实参将同时得到反映,因为他们指向的是同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;这种传递方式被称为&lt;code&gt;Call By Sharing&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function box(obj)
{
	obj.name=&#39;hello&#39;;
	var obj=new Object();
	obj.name=&#39;world&#39;;
}
var obj=new Object();
box(obj);
console.log(obj.name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意两点:
1. &lt;code&gt;var obj=new Object()&lt;/code&gt; 声明提升&lt;/p&gt;

&lt;p&gt;变为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj;
obj.name=&#39;hello&#39;;
obj=new Object();
obj.name=&#39;world&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数的已存在一个变量形参&lt;code&gt;obj&lt;/code&gt;,再次的变量申明会忽略&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;obj=new Object()&lt;/code&gt; 时,obj的修改就不会影响外层obj变量了,因为他此时已经脱离执行那个堆内存对象了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://www.zhihu.com/question/27114726&#34;&gt;http://www.zhihu.com/question/27114726&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;object-create&#34;&gt;Object.create&lt;/h2&gt;

&lt;p&gt;简单来讲，new Object()是一种通过构造函数来创建object的方式，而Object.create(proto, [ propertiesObject ])
不需要通过构造函数就可以创建一个object，Object.create()的第一个参数是必须要的，第二个参数可选。其实Object.create()内部依然是通过new一个构造函数的方式来实现的，它有构造函数，不过这个构造函数是隐式存在的，看一下使老旧浏览器支持Object.create方法的“polyfill”就可以对它们之间的区别一目了然了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
    Object.create = function (o) {
    function F() {}  //定义了一个隐式的构造函数
    F.prototype = o;
    return new F();  //其实还是通过new来实现的
    };
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HAProxy优化应用程序速度</title>
      <link>http://blog.suconghou.cn/post/use-haproxy/</link>
      <pubDate>Fri, 29 Jul 2016 14:27:54 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-haproxy/</guid>
      <description>

&lt;h2 id=&#34;haproxy&#34;&gt;HAProxy&lt;/h2&gt;

&lt;p&gt;HAProxy高性能的反向代理软件,更专注于TCP,HTTP处理,它可以基于四层或七层进行反向代理,尤其适合于高负载且需要进行七层处理的 Web 站点.&lt;/p&gt;

&lt;p&gt;单进程、事件驱动模型,通常用于超高流量的负载均衡.&lt;/p&gt;

&lt;p&gt;我们也可以使用它来作为中转站,使直连连通率不好的请求进过中转提升速度.&lt;/p&gt;

&lt;h3 id=&#34;编译安装&#34;&gt;编译安装&lt;/h3&gt;

&lt;p&gt;编译haproxy时必须制定target,不能直接make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Due to too many reports of suboptimized setups, building without
specifying the target is no longer supported. Please specify the
target OS in the TARGET variable, in the following form:

   make TARGET=xxx

Please choose the target among the following supported list :

   linux2628, linux26, linux24, linux24e, linux22, solaris
   freebsd, openbsd, cygwin, custom, generic

Use &amp;quot;generic&amp;quot; if you don&#39;t want any optimization, &amp;quot;custom&amp;quot; if you
want to precisely tweak every option, or choose the target which
matches your OS the most in order to gain the maximum performance
out of it. Please check the Makefile in case of doubts.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;linux2628 表示  内核版本&amp;gt;=2.6.28&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y wget gcc g++ make libpcre++0v5 libpcre++-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;yum update &amp;amp;&amp;amp; yum install wget gcc make
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;HAPROXY_VERSION=haproxy-1.7.0
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.haproxy.org/download/1.7/src/${HAPROXY_VERSION}.tar.gz
tar zxf ${HAPROXY_VERSION}.tar.gz
cd ${HAPROXY_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
make TARGET=linux2628 ARCH=X86_64 USE_STATIC_PCRE=1 -j$CPU_NUM &amp;amp;&amp;amp; make install

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译32位版本&lt;code&gt;make TARGET=linux26 ARCH=i686 USE_STATIC_PCRE=1 -j$CPU_NUM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在64位系统下编译32位需要&lt;code&gt;apt-get install gcc-multilib g++-multilib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我编译好的haproxy version 1.7.0&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/files/bin/haproxy.xz&#34;&gt;http://share.suconghou.cn/files/bin/haproxy.xz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;32位 &lt;a href=&#34;http://share.suconghou.cn/files/bin/haproxy.gz&#34;&gt;http://share.suconghou.cn/files/bin/haproxy.gz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;使用docker版本的haproxy&#34;&gt;使用Docker版本的HAProxy&lt;/h3&gt;

&lt;p&gt;这里提供一份编译好的最新版HAProxy镜像 &lt;a href=&#34;https://hub.docker.com/r/suconghou/haproxy/&#34;&gt;https://hub.docker.com/r/suconghou/haproxy/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;useradd -M -s /sbin/nologin haproxy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-M：不创建家目录&lt;/p&gt;

&lt;p&gt;-s：指定用户登陆时使用的shell，nologin就是登陆不了&lt;/p&gt;

&lt;h3 id=&#34;优化国外主机速度&#34;&gt;优化国外主机速度&lt;/h3&gt;

&lt;p&gt;HAProxy有多种连接模型,还有多种负载均衡算法,由于只有一台机器,我们主要侧重于使用它的反向代理.&lt;/p&gt;

&lt;p&gt;HAProxy可以一边保持与代理后端的长连接,一边又保持对客户端的连接.
这样双向保持持久连接,省去了中间反复创建连接可以在一定程度上优化速度.&lt;/p&gt;

&lt;p&gt;其只需要一个配置文件,配置主要有以下几部分功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;：用于为所有其它配置段提供默认参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frontend&lt;/code&gt;：用于定义一系列监听的套接字，这些套接字可接受客户端请求并与之建立连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backend&lt;/code&gt;：用于定义一系列后端服务器，代理将会将对应客户端的请求转发至这些服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;： 通过关联前端和后端定义了一个完整的代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置写在&lt;code&gt;haproxy.cfg&lt;/code&gt;文件中,启动的时候指定使用的配置文件.&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;haproxy -c -f /etc/haproxy/haproxy.cfg&lt;/code&gt;检查配置文件,&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg&lt;/code&gt;使用此配置文件启动&lt;/p&gt;

&lt;p&gt;一个简单的配置文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    pidfile     /var/run/haproxy.pid
    user        haproxy
    group       haproxy
    daemon

defaults
    mode                    http
    log                     global
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 30000

frontend http-in
    mode http
    bind 0.0.0.0:1080
    option http-keep-alive
    default_backend  servers

backend servers
	option http-keep-alive
    server myserver 192.243.115.210:80 check maxconn 6000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;八种负载算法&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;lsquo;roundrobin&amp;rsquo;,  简单的轮询
&amp;lsquo;static-rr&amp;rsquo;,    根据权重
 &amp;lsquo;leastconn&amp;rsquo;, 最少连接者先处理
&amp;lsquo;source&amp;rsquo;,  根据请求源IP
&amp;lsquo;uri&amp;rsquo;,    根据请求的URI
&amp;lsquo;url_param&amp;rsquo;,  根据请求的URl参数
&amp;lsquo;hdr(name)&amp;rsquo; 根据HTTP请求头来锁定每一次HTTP请求
 &amp;lsquo;rdp-cookie(name)&amp;rsquo; 很据cookie(name)来锁定并哈希每一次TCP请求&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;还有一个在应对高并发时通常都需要改的
&lt;code&gt;ulimit -n 8192&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-st&lt;/code&gt; 是立即结束原有进程(SIGTERM,立即重启)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-sf&lt;/code&gt; 是原有进程执行完后退出(SIGUSR1,平滑重启)&lt;/p&gt;

&lt;p&gt;重启HAProxy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg -st `cat /var/run/haproxy.pid`

# 不能放入.bashrc,``会立即执行的
# haproxy-reload
haproxy -f /etc/haproxy/haproxy.cfg -st `cat /var/run/haproxy.pid`
# haproxy-hot-reload
haproxy -f /etc/haproxy/haproxy.cfg -sf `cat /var/run/haproxy.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/rc.local&lt;/code&gt;(软连接到&lt;code&gt;/etc/rc.d/rc.local&lt;/code&gt;)是开机后自动执行的脚本&lt;/p&gt;

&lt;p&gt;可以加入&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg&lt;/code&gt;到其中实现开机启动.&lt;/p&gt;

&lt;p&gt;配置文件参考 &lt;a href=&#34;https://github.com/chenzhiwei/linux/tree/master/haproxy&#34;&gt;https://github.com/chenzhiwei/linux/tree/master/haproxy&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一份haproxy加速ss&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
        pidfile   /var/run/haproxy.pid
        ulimit-n  15000

defaults
        log global
        mode    tcp
        option  dontlognull
        timeout connect 1000
        timeout client  150000
        timeout server  150000

frontend ss-in
        bind *:80
        default_backend ss-out

backend ss-out
        server server1 208.81.202.208:443 maxconn 20480

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;haproxy -D -f /etc/haproxy/haproxy.cfg&lt;/code&gt;启动,参数&lt;code&gt;-D&lt;/code&gt;为goes daemon&lt;/p&gt;

&lt;h2 id=&#34;升级-glibc-版本-最新发布-http-www-gnu-org-software-libc&#34;&gt;升级&lt;code&gt;glibc&lt;/code&gt;版本,最新发布 &lt;a href=&#34;http://www.gnu.org/software/libc/&#34;&gt;http://www.gnu.org/software/libc/&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;所有版本见&lt;code&gt;http://mirror.hust.edu.cn/gnu/libc/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;错误 &lt;code&gt;libc.so.6: version GLIBC_2.14 not found&lt;/code&gt; 表明当前系统的glibc版本较低&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strings libc.so.6 |grep GLIBC_&lt;/code&gt;可以查看当前系统支持的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://mirror.hust.edu.cn/gnu/libc/glibc-2.19.tar.xz
tar Jxf glibc-2.19.tar.xz
cd glibc-2.19
mkdir build
cd build
../configure
make -j4 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;a href=&#34;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&#34;&gt;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&lt;/a&gt;
此编译需要较长时间&lt;/p&gt;

&lt;h2 id=&#34;dog-tunnel端口映射&#34;&gt;dog-tunnel端口映射&lt;/h2&gt;

&lt;p&gt;开启服务器端(须有外网IP)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dtunnel_lite -service 0.0.0.0:1234 -v -tcp -xor 121333 &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启客户端(任意一台可联网的机器)&lt;/p&gt;

&lt;p&gt;反向映射客户机22端口到服务器的30222端口,代理ssh建议使用tcp,pipe通道为1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dtunnel_lite -service 服务器端IP:1234 -v -action 127.0.0.1:22 -encrypt -tcp -xor 121333 -local 172.168.1.99:30222 -r &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用客户端连接多个服务器,将22端口映射到多个服务器端.&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;crontab&lt;/code&gt;守护进程,每5分钟检查一次&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*/5 * * * * sh /data/bin/connect.sh &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;`date` start shell process &amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
if test $( pgrep -f dtunnel_lite | wc -l ) -eq 0
then
    while true
    do
        echo &amp;quot;`date` dtunnel_lite process is starting...&amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
        touch /run/connect.lock
        dtunnel_lite -service 114.242.25.173:1234 -v -action 127.0.0.1:22 -encrypt -tcp -xor 121333 -local 172.168.1.99:30222  -r
        echo &amp;quot;`date` dtunnel_lite process killed,todo restart &amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
        sleep 5
    done
else
    touch /run/connect.lock
    echo &amp;quot;`date` dtunnel_lite process is already running &amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
fi

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先手动启动一次 &lt;code&gt;sh /data/bin/connect.sh &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>react native</title>
      <link>http://blog.suconghou.cn/post/react-native/</link>
      <pubDate>Mon, 11 Jul 2016 11:39:08 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/react-native/</guid>
      <description>

&lt;h2 id=&#34;react-native&#34;&gt;react native&lt;/h2&gt;

&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;

&lt;p&gt;前提是需要node和npm,这里不在赘述.介绍一个npm加速的.&lt;/p&gt;

&lt;p&gt;使用淘宝的npm镜像.控制台运行,或者加入你的bashrc中永久生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias cnpm=&amp;quot;npm --registry=https://registry.npm.taobao.org --cache=$HOME/.npm/.cache/cnpm --disturl=https://npm.taobao.org/dist --userconfig=$HOME/.cnpmrc&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装开发必备的一些package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install -g react-native-cli webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react-native&lt;/code&gt;也调用了&lt;code&gt;npm&lt;/code&gt;命令,所以我们可以再来个alias加速&lt;code&gt;react-native init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alias npm=&#39;cnpm&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者直接将仓库改为淘宝的NPM镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org
npm config set disturl https://npm.taobao.org/dist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在mac上还需要一些东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install flow watchman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完以后可以开始helloworld了.&lt;/p&gt;

&lt;h3 id=&#34;开始第一个例子&#34;&gt;开始第一个例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /data/tmp
react-native init HelloWorld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后正在初始化大致如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This will walk you through creating a new React Native project in /data/tmp/HelloWorld
Installing react-native package from npm...
Setting up new React Native app in /data/tmp/HelloWorld
HelloWorld@0.0.1 /data/tmp/HelloWorld
└── react@15.2.1

To run your app on iOS:
   cd /data/tmp/HelloWorld
   react-native run-ios
   - or -
   Open /data/tmp/HelloWorld/ios/HelloWorld.xcodeproj in Xcode
   Hit the Run button
To run your app on Android:
   Have an Android emulator running (quickest way to get started), or a device connected
   cd /data/tmp/HelloWorld
   react-native run-android
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;React&lt;/code&gt;类名(组件名)必须首字母大写才会被认为是一个组件,否则在JSX里只会当做普通标签&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发IOS的教程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们执行&lt;code&gt;react-native run-ios&lt;/code&gt;开始编译运行,前提是你必须安装了&lt;code&gt;xcode&lt;/code&gt;哦.&lt;/p&gt;

&lt;p&gt;执行后,出现&lt;code&gt;BUILD SUCCEEDED&lt;/code&gt;,同时自动打开新的终端运行了一个server在8081端口.&lt;/p&gt;

&lt;p&gt;模拟器中也会出现刚编译好的app的窗口,使用&lt;code&gt;cmd+r&lt;/code&gt;刷新,&lt;code&gt;cmd+d&lt;/code&gt;弹出开发菜单.&lt;/p&gt;

&lt;p&gt;我们可以修改&lt;code&gt;index.ios.js&lt;/code&gt;开始开发了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发Android的教程&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;fetch&lt;/code&gt;调用接口时,可能会出现&lt;code&gt;The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.&lt;/code&gt;错误&lt;/p&gt;

&lt;p&gt;这是IOS9要求必须使用https通信,需要修改 &lt;a href=&#34;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&#34;&gt;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;react native&lt;/code&gt;创建&lt;code&gt;Info.plist&lt;/code&gt;时就已经为我们说明了,在&lt;code&gt;NSExceptionDomains&lt;/code&gt;下面的&lt;code&gt;dict&lt;/code&gt;里添加一个排除域名就OK了.&lt;/p&gt;

&lt;p&gt;注意,不能将默认的&lt;code&gt;localhost&lt;/code&gt;去掉,否则会出现&lt;code&gt;_fbBatchedBridge is undefined&lt;/code&gt;错误.&lt;/p&gt;

&lt;h2 id=&#34;打包&#34;&gt;打包&lt;/h2&gt;

&lt;h3 id=&#34;对android项目打包&#34;&gt;对android项目打包&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;keytool&lt;/code&gt;生成签名文件,在任意目录下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -v -keystore my-release-key.keystore  -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面&lt;code&gt;my-release-key&lt;/code&gt;可以自己定义,后面的&lt;code&gt;my-key-alias&lt;/code&gt;也可以自己定义.运行后输入一下相关信息后,生成&lt;code&gt;my-release-key.keystore&lt;/code&gt;文件.&lt;/p&gt;

&lt;p&gt;其中输入的两次密码,需要记住.将这个文件移动到&lt;code&gt;android/app&lt;/code&gt;目录下,编译&lt;code&gt;android/app&lt;/code&gt;里的&lt;code&gt;build.gradle&lt;/code&gt;,添加下面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    ...
    defaultConfig { ... }
    signingConfigs {
        release {
            storeFile file(MYAPP_RELEASE_STORE_FILE)
            storePassword MYAPP_RELEASE_STORE_PASSWORD
            keyAlias MYAPP_RELEASE_KEY_ALIAS
            keyPassword MYAPP_RELEASE_KEY_PASSWORD
        }
    }
    ...
    buildTypes {
        release {
              ...
              signingConfig signingConfigs.release
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;android&lt;/code&gt;目录下运行如下命令,就可以打包,安装到自己手机上,前提是手机已usb调试连接到电脑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew assembleRelease
cd app/build/outputs/apk
adb install -r app-release.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://facebook.github.io/react-native/docs/signed-apk-android.html&#34;&gt;https://facebook.github.io/react-native/docs/signed-apk-android.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>都有哪些坑</title>
      <link>http://blog.suconghou.cn/post/some-hole/</link>
      <pubDate>Thu, 07 Jul 2016 15:46:03 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/some-hole/</guid>
      <description>

&lt;h2 id=&#34;总结一下遇到的坑&#34;&gt;总结一下遇到的坑&lt;/h2&gt;

&lt;h3 id=&#34;微信&#34;&gt;微信&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;关于横竖屏的坑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;css3可以使用媒体查询判断设备是横屏还是竖屏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//横屏时显示
@media all and (orientation : landscape) {
#screenMask{display:block}
}

//竖屏时隐藏
@media all and (orientation : portrait) {
#screenMask{display:none}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在手机浏览器中表现良好,微信中看样子也可以,但是微信网页中如果聚焦输入框,弹起键盘就有问题了.&lt;/p&gt;

&lt;p&gt;软键盘弹起后,网页可用面积减小,安卓就自动识别为横屏了,原有的页面消失了,影响非常大.IOS则没有这个问题,媒体查询判断横竖屏在IOS上工作良好.&lt;/p&gt;

&lt;p&gt;并且由此发现,css3媒体查询就是根据宽度是否比高度小来判断横竖屏的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方案1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;javascript&lt;/code&gt;的&lt;code&gt;orientation&lt;/code&gt;和&lt;code&gt;orientationchange&lt;/code&gt;判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;window.orientation   属于window对象上一个属性；共有三个值 ：0为竖屏模式（portrait）,90为向左反转变为横屏模式（landscape），-90为向右反转变为横屏模式（landscape），最后180就是设备上下互换还是竖屏模式。&lt;/li&gt;
&lt;li&gt;orientationchange    是一个event，在设备旋转时，会触发此事件，如同PC上使用的resize事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var init = function(){
        var updateOrientation = function(){
            var orientation = window.orientation;
            switch(orientation){
                case 90:
                case -90:
                    orientation = &#39;landscape&#39;;
                    break;
                default:
                    orientation = &#39;portrait&#39;;
                    break;
            }

           //do something
           //比如在html标签加一个状态
            //然后根据不同状态，显示不同大小
            document.body.parentNode.setAttribute(&#39;class&#39;,orientation);
        };

        window.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        updateOrientation();
    };

    window.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试使用JS判断能够正确得出安卓微信客户端里输入框聚焦时的横竖屏状态.&lt;/p&gt;

&lt;p&gt;orientation和orientationchange只有移动设备有这些属性和事件.&lt;/p&gt;

&lt;p&gt;在不支持这种属性和事件的设备上使用宽高比来判断做一下兼容,这样在不支持&lt;code&gt;orientation&lt;/code&gt;的设备上就相当于使用了媒体查询&lt;/p&gt;

&lt;p&gt;最终总结代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(w)
{
    var supportOrientation = (typeof w.orientation === &#39;number&#39; &amp;amp;&amp;amp; typeof w.onorientationchange === &#39;object&#39;);
    var init = function()
    {
        var htmlNode = document.body.parentNode, orientation;
        var updateOrientation = function()
        {
            if(supportOrientation)
            {
                orientation = w.orientation;
                switch(orientation)
                {
                    case 90:
                    case -90:
                        orientation = &#39;landscape&#39;;
                        break;
                    default:
                        orientation = &#39;portrait&#39;;
                        break;
                }
            }
            else
            {
                orientation = (w.innerWidth &amp;gt; w.innerHeight) ? &#39;landscape&#39; : &#39;portrait&#39;;
            }
            htmlNode.setAttribute(&#39;class&#39;,orientation);
        };
        if(supportOrientation)
        {
            w.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        }
        else
        {
            //监听resize事件
            w.addEventListener(&#39;resize&#39;,updateOrientation,false);
        }
        updateOrientation();
    };
    w.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以访问如下网址测试: /html/wx&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP最佳实践</title>
      <link>http://blog.suconghou.cn/post/php-best-way/</link>
      <pubDate>Thu, 30 Jun 2016 16:40:13 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/php-best-way/</guid>
      <description>

&lt;h2 id=&#34;性能优化&#34;&gt;性能优化&lt;/h2&gt;

&lt;h3 id=&#34;数组相关&#34;&gt;数组相关&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;in_array&lt;/code&gt;在大数据量(数万以上元素)下效率低下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在分析nginx log得出所有不重复IP时,采用&lt;code&gt;in_array&lt;/code&gt;判断,50多万的数据耗时需要五六分钟,而采用存键的方法,用&lt;code&gt;isset&lt;/code&gt;判断仅需要十几秒,效率差别非常大. [php7环境下]&lt;/p&gt;

&lt;p&gt;判断一个数组是否存在某个元素,远比查找一个键消耗的要多.前者时间复杂度O(n),而后者O(1)&lt;/p&gt;

&lt;p&gt;即时使用&lt;code&gt;in_array&lt;/code&gt;,也需要加上第三个参数,设置为严格模式,省略数据类型转化的开销,设置为&lt;code&gt;true&lt;/code&gt;比设置为&lt;code&gt;false&lt;/code&gt;性能要提升好几倍.&lt;/p&gt;

&lt;p&gt;这种情况下使用&lt;code&gt;array_search&lt;/code&gt;情况比&lt;code&gt;in_array&lt;/code&gt;更加糟糕&lt;/p&gt;

&lt;p&gt;如果条件允许使用&lt;code&gt;array_flip&lt;/code&gt;交换键值,在用&lt;code&gt;isset&lt;/code&gt;来判断要比&lt;code&gt;in_array&lt;/code&gt;好得多&lt;/p&gt;

&lt;p&gt;同时,使用&lt;code&gt;isset&lt;/code&gt;来判断数组的键,也比使用&lt;code&gt;array_key_exists&lt;/code&gt;要好&lt;/p&gt;

&lt;p&gt;而对于本题,还可以使用&lt;code&gt;array_unique&lt;/code&gt;最后去重,用空间换时间,效率仅次于用&lt;code&gt;isset&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;bugs&#34;&gt;Bugs&lt;/h2&gt;

&lt;h3 id=&#34;php-pdo-mysql-server-has-gone-away&#34;&gt;php pdo &lt;code&gt;MySQL server has gone away&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在使用PDO长连接时,执行过一次PDO初始化后,php-fpm进程会与mysql server开启一条TCP长连接,下次连接数据库就能加快速度.&lt;/p&gt;

&lt;p&gt;但是却存在一定问题,PDO维持了长连接并没有较好的检测其可用性,如果mysql server kill 掉这个连接,或者mysql重启,都会造成&lt;/p&gt;

&lt;p&gt;重新实例化PDO时得到旧的链接,导致出现&lt;code&gt;MySQL server has gone away&lt;/code&gt;,更让人郁闷的是这个错误并不是一个Exception,无法被catch捕获,即使设置&lt;code&gt;PDO::ATTR_ERRMODE=&amp;gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt;,也不行,还是直接在页面上提示.&lt;/p&gt;

&lt;p&gt;如果你使用了&lt;code&gt;set_error_handler&lt;/code&gt;,那么这个&lt;code&gt;Warning&lt;/code&gt;将会被捕捉,不会直接显示在页面上,但也改变了程序的原有执行逻辑.&lt;/p&gt;

&lt;p&gt;如果你不使用&lt;code&gt;set_error_handler&lt;/code&gt;,页面上报出&lt;code&gt;Warning&lt;/code&gt;,但其实PDO已经返回一个可用的链接了.&lt;/p&gt;

&lt;p&gt;猜测可能是PDO首先得到了不可用的然后报警告,然后又创建了一个新的.&lt;/p&gt;

&lt;p&gt;较好的解决方法是设置&lt;code&gt;set_error_handler&lt;/code&gt;若捕获了这个&lt;code&gt;MySQL server has gone away&lt;/code&gt;,则返回null,程序继续按原有逻辑执行.&lt;/p&gt;

&lt;p&gt;或者不使用PDO长连接.&lt;/p&gt;

&lt;p&gt;注意,&lt;code&gt;set_error_handler&lt;/code&gt;返回false的话,这个错误还是会被交到上一级错误程序处理的.&lt;/p&gt;

&lt;h3 id=&#34;编码转换中的若干问题&#34;&gt;编码转换中的若干问题&lt;/h3&gt;

&lt;p&gt;我们经常会遇到将utf8编码字符转化为gbk编码的字符,例如生成csv表格,在windows上的cmd窗口输出文字,以及操作windows上的有关文件路径的操作都需要使用gbk编码.&lt;/p&gt;

&lt;p&gt;常使用&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $str);&lt;/code&gt;将utf8字符转为gbk&lt;/p&gt;

&lt;p&gt;这里 utf gbk 不区分大小写,也可以混写,不区分是&lt;code&gt;utf8&lt;/code&gt;还是&lt;code&gt;utf-8&lt;/code&gt;,都能都正常使用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk//ignore&#39;, $str);&lt;/code&gt; 加上&lt;code&gt;//ignore&lt;/code&gt;使有些字符无法装换时略过.&lt;/p&gt;

&lt;p&gt;但是&lt;code&gt;//ignore&lt;/code&gt;在php5.4及以下,和个别php5.6版本上无效,任然是报NOTICE错误.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	echo iconv(&#39;UTF8&#39;, &#39;GBK//IGNORE&#39;, &#39;l l l&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;code&gt;https://3v4l.org/7vCFW&lt;/code&gt; 和 &lt;code&gt;http://www.php.net/manual/en/function.iconv.php&lt;/code&gt;第一条评论&lt;/p&gt;

&lt;p&gt;可以考虑使用&lt;code&gt;$content = mb_convert_encoding($content, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;);&lt;/code&gt; 从UTF8转为GBK&lt;/p&gt;

&lt;p&gt;这样不会报错,不能装换的被替换为?,参数也是不区分大小写,utf8和utf-8&lt;/p&gt;

&lt;h3 id=&#34;filter-var-filter-validate-url&#34;&gt;filter_var FILTER_VALIDATE_URL&lt;/h3&gt;

&lt;p&gt;filter_var FILTER_VALIDATE_URL 中不能包含中文,包含中文被判定为false&lt;/p&gt;

&lt;h3 id=&#34;内存是拷贝还是内存引用&#34;&gt;内存是拷贝还是内存引用&lt;/h3&gt;

&lt;p&gt;例1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
echo intval(memory_get_usage()/1024);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
$b=$a;
$c=$a;
$d=$a;
echo intval(memory_get_usage()/1024);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
$b=$a.&#39;&#39;;
$c=$a.&#39;&#39;;
$d=$a.&#39;&#39;;
echo intval(memory_get_usage()/1024);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例1与例2,内存差距基本不大,例2与例3有较大差距,例3约为例2的3倍,但小于3倍&lt;/p&gt;

&lt;p&gt;一般数据类型&lt;/p&gt;

&lt;p&gt;php在内存上是写时拷贝,一个变量复制多份内存不会占用多份,只有变量被改变时才会新申请一份内存给此变量.&lt;/p&gt;

&lt;h3 id=&#34;memcached-中的问题&#34;&gt;Memcached 中的问题&lt;/h3&gt;

&lt;p&gt;如果你安装了php的&lt;code&gt;memcached&lt;/code&gt;扩展,但是&lt;code&gt;igbinary&lt;/code&gt;扩展没有被启用,&lt;/p&gt;

&lt;p&gt;会使得memcache存储简单数据类型没有问题,但是存储复杂数据类型,如数组等,便会出现问题,&lt;/p&gt;

&lt;p&gt;对一个复杂数据类型的set将会导致php worker进程崩溃,类似&lt;code&gt;[pool www] child 4573 exited on signal 5 (SIGTRAP) after 20.831438 seconds from start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;nginx将会收到类似&lt;code&gt;upstream prematurely closed connection while reading response header from upstream&lt;/code&gt;,用户看到的将是502错误.&lt;/p&gt;

&lt;p&gt;故启用&lt;code&gt;memcached&lt;/code&gt;时最好启用&lt;code&gt;igbinary&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;php-worker&#34;&gt;php worker&lt;/h3&gt;

&lt;p&gt;python 简单的空worker 消耗内存比php空worker更少,但是随着python&lt;code&gt;import&lt;/code&gt;的模块增加,消耗的内存也随之上升,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import&lt;/code&gt;大多数常用模块后,内存消耗较php稍大,php进程只有业务处理会波动内存,python的CPU占用明显比php高.&lt;/p&gt;

&lt;p&gt;但python有多线程,多线程下内存消耗也较少,都适合写一些worker,相比之下,node的worker占用较多内存,引入常用模块后内存更是占用更大,CPU占用也比PHP多,优点是异步可以媲美多线程&lt;/p&gt;

&lt;h3 id=&#34;domdocument-loadhtml-内存泄漏&#34;&gt;DOMDocument loadHTML 内存泄漏&lt;/h3&gt;

&lt;p&gt;在大量使用DOMDocument的loadHTML后,php的进程占用内存不断增长,最终内存泄漏被强行杀死.&lt;/p&gt;

&lt;p&gt;其实这是&lt;code&gt;libxml_use_internal_errors&lt;/code&gt;所引起的问题,&lt;code&gt;loadHTML&lt;/code&gt;产生的警告被内部收集,但没有清除,所以一直堆积.&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;http://stackoverflow.com/questions/8379829/domdocument-php-memory-leak&#34;&gt;http://stackoverflow.com/questions/8379829/domdocument-php-memory-leak&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;php-gzip-压缩&#34;&gt;php gzip 压缩&lt;/h3&gt;

&lt;p&gt;压缩函数：gzcompress gzdeflate gzencode&lt;/p&gt;

&lt;p&gt;解压函数：gzuncompress gzinflate gzdecode&lt;/p&gt;

&lt;p&gt;他们都有第三个参数,并且第三个参数相同时,产生的结果也相同,其实他们都是使用了DEFLATE压缩算法,第三个参数控制他们压缩后添加的一些其他信息,只不过默认参数不同.&lt;/p&gt;

&lt;p&gt;ZLIB_ENCODING_RAW 对应于纯DEFLATE格式；
ZLIB_ENCODING_GZIP 对应于GZIP格式；
ZLIB_ENCODING_DEFLATE 对应于ZLIB格式（注意不是纯DEFLATE格式）&lt;/p&gt;

&lt;p&gt;默认配置下压缩后大小 gzdeflate &amp;lt; gzcompress &amp;lt; gzencode&lt;/p&gt;

&lt;p&gt;大小差别是6字节,12字节,18字节&lt;/p&gt;

&lt;p&gt;函数 &lt;code&gt;readgzfile&lt;/code&gt;类似于&lt;code&gt;readfile&lt;/code&gt;但是可以在输出之前解压然后输出&lt;/p&gt;

&lt;p&gt;Content-Encoding:deflate  对应于 gzdeflate&lt;/p&gt;

&lt;h2 id=&#34;foreach-vs-array-filter&#34;&gt;foreach vs array_filter&lt;/h2&gt;

&lt;p&gt;大数据量下,使用foreach过滤数组控制不如用array_filter,array_filter不加第二个参数,默认就是返回值,&lt;/p&gt;

&lt;p&gt;array_filter加上array_values也要比foreach快,在php7下更加明显&lt;/p&gt;

&lt;h2 id=&#34;php5-与-php7&#34;&gt;php5 与 php7&lt;/h2&gt;

&lt;p&gt;php5下关键字&lt;code&gt;list&lt;/code&gt;既不能作为一个函数也不能作为一个方法,也不能作为一个类.&lt;/p&gt;

&lt;p&gt;在php7下有了改善,能作为一个类中的方法了.&lt;/p&gt;

&lt;h2 id=&#34;array-merge-vs-array-array&#34;&gt;array_merge vs array+array&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7059721/array-merge-versus&#34;&gt;http://stackoverflow.com/questions/7059721/array-merge-versus&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;正则-w匹不匹配中文&#34;&gt;正则\w匹不匹配中文&lt;/h2&gt;

&lt;p&gt;\w在ASCII下等价于[A-Za-z0-9_],在Unicode下表示字符(包括汉字)和数字和下划线.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/\w+/u&lt;/code&gt; 不添加u修饰符是不能匹配汉字的.&lt;/p&gt;

&lt;p&gt;匹配全是汉字的正则&lt;code&gt;/^[\x{4e00}-\x{9fa5}]+$/u&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Unicode的中文字范围是u4e00-u9fa5，4e00对应的字是&amp;rdquo;一&amp;rdquo;,9fa5对应的汉字是&amp;rdquo;龥&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/[\x{4e00}-\x{9fa5}]/u&lt;/code&gt; 等同于 &lt;code&gt;/[一-龥]/u&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;readfile-stream-copy-to-stream&#34;&gt;readfile stream_copy_to_stream&lt;/h2&gt;

&lt;p&gt;大文件操作&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks libev</title>
      <link>http://blog.suconghou.cn/post/shadowsocks-libev/</link>
      <pubDate>Wed, 18 May 2016 17:37:16 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/shadowsocks-libev/</guid>
      <description>

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;yum update &amp;amp;&amp;amp; yum install -y zip unzip xz curl wget git gcc make zlib zlib-devel openssl openssl-devel
git clone https://github.com/shadowsocks/shadowsocks-libev.git
cd shadowsocks-libev
./configure --enable-static=yes
export CFLAGS=&amp;quot;-O3&amp;quot;
make -j4 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在alpine里静态编译&lt;/p&gt;

&lt;p&gt;需要将生成的&lt;code&gt;./src/Makefile&lt;/code&gt;修改&lt;code&gt;LDFLAGS = -all-static&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk update &amp;amp;&amp;amp; apk upgrade
apk --update add gcc g++ make curl zlib-dev pcre-dev openssl-dev linux-headers asciidoc xmlto
cd /tmp
SHADOWSOCKS_LIBEV_VERSION=2.5.6
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
curl -sSL https://github.com/shadowsocks/shadowsocks-libev/archive/v${SHADOWSOCKS_LIBEV_VERSION}.tar.gz |  tar xz
cd shadowsocks-libev-${SHADOWSOCKS_LIBEV_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
./configure
LDFLAGS=&amp;quot;-all-static&amp;quot; make -j$CPU_NUM &amp;amp;&amp;amp; make install
strip -s /usr/local/bin/ss-server

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;启动server端&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ss-server -s 0.0.0.0 -p 443 -k 123456 -m rc4-md5 -t 300 -d 8.8.8.8 -u&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;with Linux kernel &amp;gt; 3.7.0 可以加上&lt;code&gt;--fast-open&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ss-server -s 0.0.0.0 -p 443 -k 123456 -m rc4-md5 -t 300 -d 8.8.8.8 --fast-open -u&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;后台运行:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ss-server -s 0.0.0.0 -p 443 -k 123456 -m rc4-md5 -t 300 -d 8.8.8.8 -u &amp;gt; /tmp/ss.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;GO语言版本的也十分方便哦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里提供一个基于&lt;code&gt;docker&lt;/code&gt;的go语言版本,&lt;a href=&#34;https://hub.docker.com/r/suconghou/shadowsocks/&#34;&gt;docker go shadowsocks&lt;/a&gt;,只有3.3MB
十分方便&lt;/p&gt;

&lt;p&gt;同时也含有libev版本的可供选择&lt;/p&gt;

&lt;h2 id=&#34;网络内核参数优化&#34;&gt;网络内核参数优化&lt;/h2&gt;

&lt;p&gt;修改&lt;code&gt;ulimit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vim /etc/security/limits.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加一下两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* soft nofile 51200
* hard nofile 51200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;KVM 和 XEN 可以修改内核,明显提升网络环境差的情况下的表现,使用&lt;code&gt;hybla&lt;/code&gt;控制算法,效果明显,能提速30%&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.core.somaxconn = 4096
net.netfilter.nf_conntrack_max = 64000
fs.file-max = 51200
#提高整个系统的文件限制
net.ipv4.tcp_syncookies = 1
#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 0
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；
#为了对NAT设备更友好，建议设置为0。
net.ipv4.tcp_fin_timeout = 30
#修改系統默认的 TIMEOUT 时间。
net.ipv4.tcp_keepalive_time = 1200
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
net.ipv4.ip_local_port_range = 10000 65000 #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）
net.ipv4.tcp_max_syn_backlog = 8192
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_tw_buckets = 5000
#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。
#额外的，对于内核版本新于**3.7.1**的，我们可以开启tcp_fastopen：
net.ipv4.tcp_fastopen = 3

#increase TCP max buffer size settable using setsockopt()
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
#increase Linux autotuning TCP buffer limit
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
#increase the length of the processor input queue
net.core.netdev_max_backlog = 250000
#recommended for hosts with jumbo frames enabled
net.ipv4.tcp_mtu_probing=1
#使用拥塞算法Hybla
net.ipv4.tcp_congestion_control = hybla
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后&lt;code&gt;sysctl -p&lt;/code&gt;使之生效&lt;/p&gt;

&lt;p&gt;可参见 &lt;a href=&#34;https://github.com/Long-live-shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks&#34;&gt;https://github.com/Long-live-shadowsocks/shadowsocks/wiki/Optimizing-Shadowsocks&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;OPENVZ只能修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.core.somaxconn = 4096
net.ipv4.tcp_syncookies = 1
net.netfilter.nf_conntrack_max = 64000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用kcptun加速&lt;/p&gt;

&lt;p&gt;服务器上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias kcptun_start=&#39;server_linux_amd64 -t 127.0.0.1:443 -l :4433 -sndwnd 2048 -rcvwnd 2048 -mode fast2 &amp;gt; /var/log/kcptun.log 2&amp;gt;&amp;amp;1 &amp;amp; &#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户机上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias kcptun_start=&#39;kcptun_client -r 192.243.115.210:4433 -l :4433 -sndwnd 2048 -rcvwnd 2048 -mode fast2 &amp;gt; /var/log/kcptun.log 2&amp;gt;&amp;amp;1 &amp;amp;&#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;python-版本&#34;&gt;python 版本&lt;/h2&gt;

&lt;p&gt;升级pip本身&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pip install --upgrade pip
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;pip install shadowsocks --upgrade
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;--upgrade 同 -U&lt;/code&gt; 代表如果已安装则升级到最新版&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>使用tcpdump与ngrep</title>
      <link>http://blog.suconghou.cn/post/tcpdump/</link>
      <pubDate>Mon, 16 May 2016 18:21:04 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/tcpdump/</guid>
      <description>

&lt;p&gt;各版本 &lt;code&gt;http://www.tcpdump.org/release/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装依赖 &lt;code&gt;yum install -y flex gcc make byacc&lt;/code&gt; or &lt;code&gt;apt-get install flex gcc make byacc wget bzip2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
wget http://www.tcpdump.org/release/libpcap-1.7.4.tar.gz
tar zxf libpcap-1.7.4.tar.gz
cd libpcap-1.7.4
./configure --prefix=/tmp/lib
make -j4 &amp;amp;&amp;amp; make install
cd ../
wget http://www.tcpdump.org/release/tcpdump-4.7.4.tar.gz
tar zxf tcpdump-4.7.4.tar.gz
cd tcpdump-4.7.4
./configure --prefix=/tmp  --disable-ipv6 CFLAGS=&#39;-O3 -I/tmp/lib/include&#39; LDFLAGS=&#39;-L/tmp/lib/lib/libpcap.a&#39;
make -j4
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后,位于&lt;code&gt;ls -lh /tmp/sbin/tcpdump&lt;/code&gt; &lt;code&gt;ldd&lt;/code&gt;查看此文件依赖较少,可直接复制到其他Linux上使用.&lt;/p&gt;

&lt;p&gt;采用&lt;code&gt;CFLAGS=&amp;quot;-O3&amp;quot;&lt;/code&gt;编译后为1.2MB&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tcpdump -h&lt;/code&gt; 查看版本号以及用法&lt;/p&gt;

&lt;p&gt;我编译好的tcpdump version 4.7.4&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/files/bin/tcpdump.xz&#34;&gt;http://share.suconghou.cn/files/bin/tcpdump.xz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也可以直接&lt;code&gt;yum install tcpdump&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用tcpdump&#34;&gt;使用tcpdump&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;-a 　　　将网络地址和广播地址转变成名字；&lt;/p&gt;

&lt;p&gt;-d 　　　将匹配信息包的代码以人们能够理解的汇编格式给出；&lt;/p&gt;

&lt;p&gt;-dd 　　 将匹配信息包的代码以c语言程序段的格式给出；&lt;/p&gt;

&lt;p&gt;-ddd 　　将匹配信息包的代码以十进制的形式给出；&lt;/p&gt;

&lt;p&gt;-e 　　　在输出行打印出数据链路层的头部信息；&lt;/p&gt;

&lt;p&gt;-f 　　　将外部的Internet地址以数字的形式打印出来；&lt;/p&gt;

&lt;p&gt;-l 　　　使标准输出变为缓冲行形式；&lt;/p&gt;

&lt;p&gt;-n 　　　不把网络地址转换成名字；&lt;/p&gt;

&lt;p&gt;-t 　　　在输出的每一行不打印时间戳；&lt;/p&gt;

&lt;p&gt;-v 　　　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；&lt;/p&gt;

&lt;p&gt;-vv 　　 输出详细的报文信息；&lt;/p&gt;

&lt;p&gt;-c 　　　在收到指定的包的数目后，tcpdump就会停止；&lt;/p&gt;

&lt;p&gt;-F 　　　从指定的文件中读取表达式,忽略其它的表达式；&lt;/p&gt;

&lt;p&gt;-i 　　　指定监听的网络接口；&lt;/p&gt;

&lt;p&gt;-r 　　　从指定的文件中读取包(这些包一般通过-w选项产生)；&lt;/p&gt;

&lt;p&gt;-w 　　　直接将包写入文件中，并不分析和打印出来；&lt;/p&gt;

&lt;p&gt;-T 　　　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;tcpdump host 210.27.48.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-A&lt;/code&gt;和&lt;code&gt;-X&lt;/code&gt;有助于你查看详细的报文数据&lt;/p&gt;

&lt;h2 id=&#34;ngrep&#34;&gt;ngrep&lt;/h2&gt;

&lt;p&gt;ngrep 编译总是出问题,建议直接安装:&lt;code&gt;apt-get install ngrep&lt;/code&gt; &lt;code&gt;yum install ngrep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果更关注于TCP流量内容,可以使用&lt;code&gt;ngrep&lt;/code&gt;,他是grep命令的网络版,同样需要libpcap库,能识别TCP、UDP和ICMP包，理解bpf的过滤机制&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngrep -W byline -d eno1 port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用-d指定网卡,使用&lt;code&gt;ifconfig&lt;/code&gt;可以查看网卡信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-e ：显示空数据包
-i ：忽略大小写
-v ：反转匹配
-R ：don&#39;t do privilege revocation logic
-x ：以16进制格式显示
-X ：以16进制格式匹配
-w ：整字匹配
-p ：不使用混杂模式
-l ：make stdout line buffered
-D ：replay pcap_dumps with their recorded time intervals
-t ：在每个匹配的包之前显示时间戳
-T ：显示上一个匹配的数据包之间的时间间隔
-M ：仅进行单行匹配
-I ：从文件中读取数据进行匹配
-O ：将匹配的数据保存到文件
-n ：仅捕获指定数目的数据包进行查看
-A ：匹配到数据包后dump随后的指定数目的数据包
-s ：set the bpf caplen
-S ：set the limitlen on matched packets
-W ：设置显示格式byline将解析包中的换行符
-c ：强制显示列的宽度
-q ：is be quiet (don’t print packet reception hash marks)静默模式，如果没有此开关，未匹配的数据包都以&amp;quot;#&amp;quot;显示
-P ：set the non-printable display char to what is specified
-F ：使用文件中定义的bpf(Berkeley Packet Filter)
-N ：显示由IANA定义的子协议号
-d ：使用哪个网卡，可以用-L选项查询
-L ：查询网卡接口

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要匹配关键字可以在-d参数之后, port 参数之前添加字符串匹配&lt;/p&gt;

&lt;p&gt;同时可以使用-i忽略大小写,-w整字匹配等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo ngrep  -W byline -d en0 -iw &amp;quot;easy&amp;quot;  port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以使用这种过滤 &lt;code&gt;host www.google.com and port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;具体使用见
&lt;a href=&#34;http://man.linuxde.net/ngrep&#34;&gt;http://man.linuxde.net/ngrep&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译安装Apache Traffic Server</title>
      <link>http://blog.suconghou.cn/post/use-apache-traffic-server/</link>
      <pubDate>Mon, 09 May 2016 22:24:14 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-apache-traffic-server/</guid>
      <description>

&lt;h2 id=&#34;编译安装&#34;&gt;编译安装&lt;/h2&gt;

&lt;p&gt;Centos下编译安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum update -y &amp;amp;&amp;amp; yum install wget gcc g++ gcc-c++ glibc-headers perl openssl openssl-devel tcl-devel libxml2-devel pcre-devel
wget http://apache.fayea.com/trafficserver/trafficserver-6.1.1.tar.bz2
tar xvjf trafficserver-6.1.1.tar.bz2
cd trafficserver-6.1.1
./configure
make &amp;amp;&amp;amp; make install
useradd -s /sbin/nologin trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache镜像&lt;a href=&#34;http://archive.apache.org/dist/&#34;&gt;http://archive.apache.org/dist/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;国内Apache镜像&lt;a href=&#34;http://apache.fayea.com/&#34;&gt;http://apache.fayea.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译完成后,就可以使用了,默认是安装在&lt;code&gt;/usr/local/bin&lt;/code&gt;,编译后是比较大&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total 98M
-rwxr-xr-x 1 root root 692K May  9 14:30 header_rewrite_test
-rwxr-xr-x 1 root root 520K May  9 14:30 traffic_cop
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_crashlog
-rwxr-xr-x 1 root root 259K May  9 14:30 traffic_ctl
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_layout
-rwxr-xr-x 1 root root  41K May  9 14:30 traffic_line
-rwxr-xr-x 1 root root 4.4M May  9 14:30 traffic_logcat
-rwxr-xr-x 1 root root 5.0M May  9 14:30 traffic_logstats
-rwxr-xr-x 1 root root 4.7M May  9 14:30 traffic_manager
-rwxr-xr-x 1 root root  37M May  9 14:30 traffic_sac
-rwxr-xr-x 1 root root  43M May  9 14:30 traffic_server
-rwxr-xr-x 1 root root  42K May  9 14:30 traffic_via
-rwxr-xr-x 1 root root  18K May  9 14:30 trafficserver
-rwxr-xr-x 1 root root 2.1K May  9 14:30 tspush
-rwxr-xr-x 1 root root 5.7K May  9 14:30 tsxs

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;code&gt;traffic_server -R 1&lt;/code&gt;执行测试,经过一系列测试后,显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tests Passed: 177
Tests Failed: 0
    REGRESSION_RESULT PARENTSELECTION:                          PASSED
REGRESSION_TEST DONE: PASSED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全部测试通过&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;默认的配置文件存放在&lt;code&gt;/usr/local/etc/trafficserver&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x 3 nobody nobody 1.0K May  9 14:30 body_factory
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 cache.config
-rw-r--r-- 1 nobody nobody  657 May  9 14:30 cluster.config
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 congestion.config
-rw-r--r-- 1 nobody nobody  746 May  9 14:30 hosting.config
-rw-r--r-- 1 nobody nobody 1.8K May  9 14:30 icp.config
-rw-r--r-- 1 nobody nobody 1.2K May  9 14:30 ip_allow.config
-rw-r--r-- 1 nobody nobody  328 May  9 14:30 log_hosts.config
-rw-r--r-- 1 nobody nobody  17K May  9 14:30 logs_xml.config
-rw-r--r-- 1 nobody nobody 1.4K May  9 14:30 parent.config
-rw-r--r-- 1 nobody nobody  261 May  9 14:30 plugin.config
-rw-r--r-- 1 nobody nobody  13K May  9 14:30 records.config
-rw-r--r-- 1 nobody nobody 8.6K May  9 14:30 remap.config
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 socks.config
-rw-r--r-- 1 nobody nobody 2.1K May  9 14:30 splitdns.config
-rw-r--r-- 1 nobody nobody 2.7K May  9 14:30 ssl_multicert.config
-rw-r--r-- 1 nobody nobody  76K May  9 14:30 stats.config.xml
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 storage.config
-rw-r--r-- 1 root   root     19 May  9 14:30 trafficserver-release
-rw-r--r-- 1 nobody nobody  649 May  9 14:30 vaddrs.config
-rw-r--r-- 1 nobody nobody 1.3K May  9 14:30 volume.config

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;records.config&lt;/code&gt;负责大部分全局的选项设置，即主要配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG proxy.config.reverse_proxy.enabled INT 1                           # 开启反向代理
CONFIG proxy.config.url_remap.remap_required INT 1                        # 1 代理反向代理，0代表正向+反向代理
CONFIG proxy.config.http.cache.http INT 1                                 # 打开http缓存功能
CONFIG proxy.config.cache.ram_cache.size INT 512M                         # RAM 缓存大小
CONFIG proxy.config.http.keep_alive_no_activity_timeout_out INT 120       # 当一个事务结束后同原服务器保持连接的时间
CONFIG proxy.config.cluster.ethernet_interface STRING eth0                # 修改成需要侦听的interface名称

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;remap.config&lt;/code&gt;定义映射规则，用于请求的重定向（rewrite）,反向代理即在此配置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;storage.config&lt;/code&gt; 用于指定磁盘存储&lt;/p&gt;

&lt;p&gt;启动&lt;code&gt;trafficserver start&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;varnish编译&#34;&gt;varnish编译&lt;/h3&gt;

&lt;p&gt;alpine中编译&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;apk update &amp;amp;&amp;amp; apk upgrade
apk --update add gcc g++ make wget curl m4 automake autoconf libtool linux-headers py-docutils ncurses-dev pcre-dev libedit-dev
cd /tmp
VARNISH_VERSION=varnish-4.1.3
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget https://repo.varnish-cache.org/source/${VARNISH_VERSION}.tar.gz
tar xzf ${VARNISH_VERSION}.tar.gz
cd ${VARNISH_VERSION}
./configure
make CFLAGS=&amp;quot;-Os&amp;quot; CPPFLAGS=-D__NEED_mode_t -j$CPU_NUM &amp;amp;&amp;amp; make install
strip -s /usr/local/bin/* /usr/local/sbin/* /usr/local/lib/varnish/*.so /usr/local/lib/varnish/vmods/*.so
varnishd  -V
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;varnish基本使用&#34;&gt;varnish基本使用&lt;/h4&gt;

&lt;p&gt;varnish / squid / nginx 优缺点讨论 见 &lt;a href=&#34;http://www.zhihu.com/question/20143441&#34;&gt;http://www.zhihu.com/question/20143441&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
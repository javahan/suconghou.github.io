<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>苏苏的博客</title>
    <link>http://blog.suconghou.cn/</link>
    <description>Recent content on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Aug 2016 14:44:23 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>memcached usage</title>
      <link>http://blog.suconghou.cn/post/memcached-usage/</link>
      <pubDate>Wed, 24 Aug 2016 14:44:23 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/memcached-usage/</guid>
      <description>

&lt;h2 id=&#34;安装memcached&#34;&gt;安装memcached&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://memcached.org/downloads&#34;&gt;http://memcached.org/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;memcached所有版本见&lt;a href=&#34;http://www.memcached.org/files/&#34;&gt;http://www.memcached.org/files/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
MEMCACHE_VERSION=memcached-1.4.31
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.memcached.org/files/${MEMCACHE_VERSION}.tar.gz
tar xzf ${MEMCACHE_VERSION}.tar.gz
cd ${MEMCACHE_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
./configure
make -j$CPU_NUM &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker版本见:&lt;a href=&#34;https://hub.docker.com/r/suconghou/memcached/&#34;&gt;https://hub.docker.com/r/suconghou/memcached/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动memcached&#34;&gt;启动Memcached&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;memcached -d -u memcached -p 11211 -m 8 -P /var/run/memcached/memcached.pid

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-d 以daemon方式运行&lt;/li&gt;
&lt;li&gt;-u 绑定使用指定用户运行进程(仅在以root运行的时候有效)&lt;/li&gt;
&lt;li&gt;-p 设置TCP端口号(默认11211)&lt;/li&gt;
&lt;li&gt;-m 允许最大内存用量，单位M (默认: 64 MB)&lt;/li&gt;
&lt;li&gt;-M 内存耗尽时返回错误，而不是删除项&lt;/li&gt;
&lt;li&gt;-l 是监听的服务器IP地址，默认应该是本机&lt;/li&gt;
&lt;li&gt;-P 将PID写入文件&lt;file&gt;，这样可以使得后边进行快速进程终止, 需要与-d 一起使用&lt;/li&gt;
&lt;li&gt;-c 最大同时连接数，默认是1024&lt;/li&gt;
&lt;li&gt;-t 线程数,默认为4&lt;/li&gt;
&lt;li&gt;-v 输出警告和错误信息&lt;/li&gt;
&lt;li&gt;-vv 打印客户端的请求和返回信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下是不限制访问IP的,相当于是外网和内网都能访问,-l 使只有这个IP能访问&lt;/p&gt;

&lt;p&gt;尽量不要用root用户运行.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript code snippet</title>
      <link>http://blog.suconghou.cn/post/javascript-code-snippet/</link>
      <pubDate>Thu, 11 Aug 2016 10:27:18 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-code-snippet/</guid>
      <description>

&lt;h2 id=&#34;实用的javascript代码锦集&#34;&gt;实用的Javascript代码锦集&lt;/h2&gt;

&lt;h3 id=&#34;获取查询查询字符串get参数值&#34;&gt;获取查询查询字符串get参数值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function getParam()
{
	var data = decodeURIComponent(location.href).split(&amp;quot;?&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;);
	var param = {};
	for(var i = 0; i&amp;lt;data .length; i++)
	{
		param[data [i].split(&amp;quot;=&amp;quot;)[0]] = data [i].split(&amp;quot;=&amp;quot;)[1];
	}
	return param;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于PHP中的&lt;code&gt;$_GET&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $_GET = (function()
{
	var url = decodeURIComponent(location.href);
	var u = url.split( &amp;quot;?&amp;quot; );
	if ( typeof (u[1]) == &amp;quot;string&amp;quot; )
	{
		u = u[1].split( &amp;quot;&amp;amp;&amp;quot; );
		var get = {};
		for ( var i in u)
		{
			var j = u[i].split( &amp;quot;=&amp;quot; );
			get[j[0]] = j[1];
		}
		return get;
	}
	else
	{
		return {};
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给出要获取的参数,每次都会解析一遍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getPar(par)
{
	//获取当前URL
	var local_url = decodeURIComponent(location.href);
	//获取要取得的get参数位置
	var get = local_url.indexOf(par + &amp;quot;=&amp;quot; );
	if (get == -1)
	{
		return false ;
	}
	//截取字符串
	var get_par = local_url.slice(par.length + get + 1);
	//判断截取后的字符串是否还有其他get参数
	var nextPar = get_par.indexOf( &amp;quot;&amp;amp;&amp;quot; );
	if (nextPar != -1)
	{
		get_par = get_par.slice(0, nextPar);
	}
	return get_par;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QueryString&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function QueryString(item)
{
	var value = location.search.match(new RegExp(&#39;[\?\&amp;amp;]&#39; + item + &#39;=([^\&amp;amp;]*)(\&amp;amp;?)&#39;,&#39;i&#39;));
	return value ? value[1] : value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;取得cookie中某个键的值&#34;&gt;取得Cookie中某个键的值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$.getCookie = function(name)
{
	 if(document.cookie.indexOf(name)!=-1) return document.cookie.split(name+&#39;=&#39;)[1].split(&#39;;&#39;)[0]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getcookie(cookieid)
{
	//获取cookie字符串
	var strCookie=document.cookie;
	//将多cookie切割为多个名/值对
	var arrCookie=strCookie.split(&amp;quot;; &amp;quot;);
	var cookieval;
	//遍历cookie数组，处理每个cookie对
	for(var i=0;i&amp;lt;arrCookie.length;i++)
	{
		var arr=arrCookie[i].split(&amp;quot;=&amp;quot;);
		//找到名称为userId的cookie，并返回它的值
		if(cookieid==arr[0])
		{
			cookieval=arr[1];
			break;
		}
	}
	return(cookieval);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;进入全屏&#34;&gt;进入全屏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function gofull()
{
	var el=document.documentElement;
	el.webkitRequestFullScreen&amp;amp;&amp;amp;el.webkitRequestFullScreen();
	el.mozRequestFullScreen&amp;amp;&amp;amp;el.mozRequestFullScreen();
	el.requestFullscreen&amp;amp;&amp;amp;el.requestFullscreen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串去空格&#34;&gt;字符串去空格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;String.prototype.trim=function() {return this.replace(/(^\s*)|(\s*$)/g,&amp;quot;&amp;quot;); }
String.prototype.ltrim=function(){return this.replace(/(^\s*)/g,&amp;quot;&amp;quot;); }
String.prototype.rtrim=function(){return this.replace(/(\s*$)/g,&amp;quot;&amp;quot;); }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字节格式化&#34;&gt;字节格式化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function size(size)
{
	var name=[&#39;B&#39;,&#39;KB&#39;,&#39;MB&#39;,&#39;GB&#39;,&#39;TB&#39;,&#39;PB&#39;];
	var pos=0;
	while(size&amp;gt;=1204)
	{
	    size/=1024;
	    pos++;
	}
	return size.toFixed(2)+&amp;quot; &amp;quot;+name[pos];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一些正则验证&#34;&gt;一些正则验证&lt;/h3&gt;

&lt;p&gt;验证邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_mail(str)
{
	return(new RegExp(/^[0-9a-zA-Z]+@(([0-9a-zA-Z]+)[.])+[a-z]{2,4}$/i).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证手机号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_tel(str)
{
	return(new RegExp(/^1[34578][0-9]{9}$/).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;base64的1x1像素间隔gif&#34;&gt;Base64的1x1像素间隔gif&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一个range函数&#34;&gt;一个range函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function range(start, count)
{
	return Array.apply(0, Array(count)).map(function (element, index)
	{
		return index + start;
	});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;简化-console-log&#34;&gt;简化&lt;code&gt;console.log&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var log = console.log.bind(console);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成较短的唯一id&#34;&gt;生成较短的唯一ID&lt;/h3&gt;

&lt;p&gt;一定年限内单线程非连续调用唯一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function shortId()
{
	var time=Date.now()+&#39;&#39;;
	time=parseInt(time.substr(1));
	return time.toString(36);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成随机短ID,仅具备较低的不重复性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var t=(((1+Math.random())*0x10000000)|0).toString(16);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成指定长度随机字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function code($nc, $a=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;)
{
    $l=strlen($a)-1; $r=&#39;&#39;;
    while($nc--&amp;gt;0) $r.=$a{mt_rand(0,$l)};
    return $r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;给jquery的form添加-serializeobject&#34;&gt;给jQuery的form添加&lt;code&gt;serializeObject&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.serializeObject=function()
{
	var a,o,h,i,e;
	a=this.serializeArray();
	o={};
	h=o.hasOwnProperty;
	for(i=0;i&amp;lt;a.length;i++)
	{
		e=a[i];
		if(!h.call(o,e.name))
		{
			o[e.name]=e.value;
		}
	}
	return o;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用效果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery(&amp;quot;form&amp;quot;).serialize(); //&amp;quot;username=&amp;amp;password=&amp;quot;
jQuery(&amp;quot;form&amp;quot;).serializeArray(); //[{name:&amp;quot;username&amp;quot;,value:&amp;quot;&amp;quot;},{name:&amp;quot;password&amp;quot;,value:&amp;quot;&amp;quot;}]
jQuery(&amp;quot;form&amp;quot;).serializeObject(); //{username:&amp;quot;&amp;quot;,password:&amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;资源预取&#34;&gt;资源预取&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function prefetch(url)
{
	var link = document.createElement(&amp;quot;link&amp;quot;);
	link.href = url;
	link.rel=&amp;quot;prefetch&amp;quot;;
	var s = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
	s.appendChild(link);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用-google-analytics-统计js错误&#34;&gt;用&lt;code&gt;Google Analytics&lt;/code&gt;统计JS错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,&#39;script&#39;,&#39;https://www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);
window.addEventListener(&#39;error&#39;, function (err)
{
	ga(&#39;create&#39;, &#39;UA-xxx-1&#39;, &#39;auto&#39;);
    var lineAndColumnInfo = err.colno ? &#39; line:&#39; + err.lineno +&#39;, column:&#39;+ err.colno : &#39; line:&#39; + err.lineno;
    ga(&#39;send&#39;, &#39;event&#39;, &#39;JavaScript Error&#39;, err.message, location.href+&#39; =&amp;gt; &#39;+err.filename + lineAndColumnInfo + &#39; -&amp;gt; &#39; +  navigator.userAgent, 0, true );
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;UA-xxx-1&lt;/code&gt;使用自己的统计ID&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript senior</title>
      <link>http://blog.suconghou.cn/post/javascript-senior/</link>
      <pubDate>Tue, 09 Aug 2016 21:27:39 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-senior/</guid>
      <description>

&lt;h2 id=&#34;javascript-参数传递&#34;&gt;Javascript 参数传递&lt;/h2&gt;

&lt;p&gt;说起参数传递,首先需要弄清楚javascript里的数据类型&lt;/p&gt;

&lt;p&gt;原始数据类型
&lt;code&gt;Undefined&lt;/code&gt; &lt;code&gt;Null&lt;/code&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;code&gt;Number&lt;/code&gt; &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用数据类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; &lt;code&gt;Date&lt;/code&gt; 等&lt;/p&gt;

&lt;p&gt;原始数据类型存储在栈的简单数据段,他们的值直接存储在变量访问的位置(因原始数据类型占据的空间是固定的,可以存储在较小的内存区域&lt;code&gt;栈&lt;/code&gt;中)&lt;/p&gt;

&lt;p&gt;引用数据类型是存储在堆中的对象,存储在变量处的值只是一个指针,指向存储对象的内存地址,这是因为引用类型的大小会改变.&lt;/p&gt;

&lt;p&gt;不同的内存分配机制带来不同的访问机制&lt;/p&gt;

&lt;p&gt;在JavaScript中,是不允许直接访问保存在堆内存中的对象的,访问对象时必须取得对象在堆内存中的地址,然后按地址去取得对象中的值.&lt;/p&gt;

&lt;p&gt;这便是传说中的按引用访问.&lt;/p&gt;

&lt;p&gt;而原始类型则是直接访问到的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复制变量时的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;会将原始值的副本赋值给新变量.此后两个变量完全独立.&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;会把内存地址赋值给新变量,也就是说两个变量都指向堆内存中的同一个对象.
他们中任何一个改变都会反映到另一个身上.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数传递的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最重要的一点:&lt;code&gt;ECMAScript&lt;/code&gt;中所有函数的参数都是按值传递的.&lt;/p&gt;

&lt;p&gt;但原始值和引用值仍会造成不同的后果.&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;把变量里的值传递给参数,之后两个变量互不影响.(就是把实参复制给形参的过程)&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;任然是将实参里面的值复制到形参,但是注意&lt;em&gt;对象变量它里面的值是这个对象的堆内存地址&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;也就是说形参和实参都是指向同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;但是也要记住另外一点:如果形参被赋值为另外一个对象时,那么这个形参将会丢弃对上次指向的堆内存地址,而指向新对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;此时,形参和实参相互脱离,互不影响,原先的实参任然指向原先对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;如果是添加修改形参的属性,那么就是修改堆内存中的对象,形参和实参将同时得到反映,因为他们指向的是同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;这种传递方式被称为&lt;code&gt;Call By Sharing&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function box(obj)
{
	obj.name=&#39;hello&#39;;
	var obj=new Object();
	obj.name=&#39;world&#39;;
}
var obj=new Object();
box(obj);
console.log(obj.name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意两点:
1. &lt;code&gt;var obj=new Object()&lt;/code&gt; 声明提升&lt;/p&gt;

&lt;p&gt;变为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj;
obj.name=&#39;hello&#39;;
obj=new Object();
obj.name=&#39;world&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数的已存在一个变量形参&lt;code&gt;obj&lt;/code&gt;,再次的变量申明会忽略&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;obj=new Object()&lt;/code&gt; 时,obj的修改就不会影响外层obj变量了,因为他此时已经脱离执行那个堆内存对象了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://www.zhihu.com/question/27114726&#34;&gt;http://www.zhihu.com/question/27114726&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;object-create&#34;&gt;Object.create&lt;/h2&gt;

&lt;p&gt;简单来讲，new Object()是一种通过构造函数来创建object的方式，而Object.create(proto, [ propertiesObject ])
不需要通过构造函数就可以创建一个object，Object.create()的第一个参数是必须要的，第二个参数可选。其实Object.create()内部依然是通过new一个构造函数的方式来实现的，它有构造函数，不过这个构造函数是隐式存在的，看一下使老旧浏览器支持Object.create方法的“polyfill”就可以对它们之间的区别一目了然了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
    Object.create = function (o) {
    function F() {}  //定义了一个隐式的构造函数
    F.prototype = o;
    return new F();  //其实还是通过new来实现的
    };
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HAProxy优化应用程序速度</title>
      <link>http://blog.suconghou.cn/post/use-haproxy/</link>
      <pubDate>Fri, 29 Jul 2016 14:27:54 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-haproxy/</guid>
      <description>

&lt;h2 id=&#34;haproxy&#34;&gt;HAProxy&lt;/h2&gt;

&lt;p&gt;HAProxy高性能的反向代理软件,更专注于TCP,HTTP处理,它可以基于四层或七层进行反向代理,尤其适合于高负载且需要进行七层处理的 Web 站点.&lt;/p&gt;

&lt;p&gt;单进程、事件驱动模型,通常用于超高流量的负载均衡.&lt;/p&gt;

&lt;p&gt;我们也可以使用它来作为中转站,使直连连通率不好的请求进过中转提升速度.&lt;/p&gt;

&lt;h3 id=&#34;编译安装&#34;&gt;编译安装&lt;/h3&gt;

&lt;p&gt;编译haproxy时必须制定target,不能直接make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Due to too many reports of suboptimized setups, building without
specifying the target is no longer supported. Please specify the
target OS in the TARGET variable, in the following form:

   make TARGET=xxx

Please choose the target among the following supported list :

   linux2628, linux26, linux24, linux24e, linux22, solaris
   freebsd, openbsd, cygwin, custom, generic

Use &amp;quot;generic&amp;quot; if you don&#39;t want any optimization, &amp;quot;custom&amp;quot; if you
want to precisely tweak every option, or choose the target which
matches your OS the most in order to gain the maximum performance
out of it. Please check the Makefile in case of doubts.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;linux2628 表示  内核版本&amp;gt;=2.6.28&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y wget gcc g++ make libpcre++0v5 libpcre++-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;HAPROXY_VERSION=haproxy-1.6.8
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.haproxy.org/download/1.6/src/${HAPROXY_VERSION}.tar.gz
tar zxf ${HAPROXY_VERSION}.tar.gz
cd ${HAPROXY_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
make TARGET=linux2628 ARCH=X86_64 USE_STATIC_PCRE=1 -j$CPU_NUM &amp;amp;&amp;amp; make install

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译32位版本&lt;code&gt;make TARGET=linux26 ARCH=i686 USE_STATIC_PCRE=1 -j$CPU_NUM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在64位系统下编译32位需要&lt;code&gt;apt-get install gcc-multilib g++-multilib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我编译好的haproxy version 1.6.8&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/bin/haproxy.xz&#34;&gt;http://share.suconghou.cn/bin/haproxy.xz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;32位 &lt;a href=&#34;http://share.suconghou.cn/bin/haproxy.gz&#34;&gt;http://share.suconghou.cn/bin/haproxy.gz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;使用docker版本的haproxy&#34;&gt;使用Docker版本的HAProxy&lt;/h3&gt;

&lt;p&gt;这里提供一份编译好的最新版HAProxy镜像 &lt;a href=&#34;https://hub.docker.com/r/suconghou/haproxy/&#34;&gt;https://hub.docker.com/r/suconghou/haproxy/&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;优化国外主机速度&#34;&gt;优化国外主机速度&lt;/h3&gt;

&lt;p&gt;HAProxy有多种连接模型,还有多种负载均衡算法,由于只有一台机器,我们主要侧重于使用它的反向代理.&lt;/p&gt;

&lt;p&gt;HAProxy可以一边保持与代理后端的长连接,一边又保持对客户端的连接.
这样双向保持持久连接,省去了中间反复创建连接可以在一定程度上优化速度.&lt;/p&gt;

&lt;p&gt;其只需要一个配置文件,配置主要有以下几部分功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;：用于为所有其它配置段提供默认参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frontend&lt;/code&gt;：用于定义一系列监听的套接字，这些套接字可接受客户端请求并与之建立连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backend&lt;/code&gt;：用于定义一系列后端服务器，代理将会将对应客户端的请求转发至这些服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;： 通过关联前端和后端定义了一个完整的代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置写在&lt;code&gt;haproxy.cfg&lt;/code&gt;文件中,启动的时候指定使用的配置文件.&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;haproxy -c -f /etc/haproxy/haproxy.cfg&lt;/code&gt;检查配置文件,&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg&lt;/code&gt;使用此配置文件启动&lt;/p&gt;

&lt;p&gt;一个简单的配置文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    log         127.0.0.1 local3
    pidfile     /var/run/haproxy.pid
    user        haproxy
    group       haproxy
    daemon

defaults
    mode                    http
    log                     global
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 30000

frontend http-in
    mode http
    bind 0.0.0.0:1080
    option http-keep-alive
    default_backend  servers

backend servers
	option http-keep-alive
    server myserver 192.243.115.210:80 check maxconn 6000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个在应对高并发时通常都需要改的
&lt;code&gt;ulimit -n 8192&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;重启HAProxy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg -st `cat /var/run/haproxy.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;升级-glibc-版本-最新发布-http-www-gnu-org-software-libc&#34;&gt;升级&lt;code&gt;glibc&lt;/code&gt;版本,最新发布 &lt;a href=&#34;http://www.gnu.org/software/libc/&#34;&gt;http://www.gnu.org/software/libc/&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;所有版本见&lt;code&gt;http://mirror.hust.edu.cn/gnu/libc/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;错误 &lt;code&gt;libc.so.6: version GLIBC_2.14 not found&lt;/code&gt; 表明当前系统的glibc版本较低&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strings libc.so.6 |grep GLIBC_&lt;/code&gt;可以查看当前系统支持的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://mirror.hust.edu.cn/gnu/libc/glibc-2.19.tar.xz
tar Jxf glibc-2.19.tar.xz
cd glibc-2.19
mkdir build
cd build
../configure
make -j4&amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;a href=&#34;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&#34;&gt;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&lt;/a&gt;
此编译需要较长时间&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>some dev tools</title>
      <link>http://blog.suconghou.cn/software/some-dev-tools/</link>
      <pubDate>Sun, 17 Jul 2016 20:48:49 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/some-dev-tools/</guid>
      <description>

&lt;h2 id=&#34;一些开发会用到的小工具&#34;&gt;一些开发会用到的小工具&lt;/h2&gt;

&lt;h3 id=&#34;编程字体&#34;&gt;编程字体&lt;/h3&gt;

&lt;p&gt;苹果出品的&lt;code&gt;Monaco&lt;/code&gt;,看起来十分圆润,首选推荐的编程字体&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/fonts/monaco.ttf&#34;&gt;monaco&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或许还有很多人喜欢&lt;code&gt;YaHei.Consolas&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/fonts/YaHei.Consolas.1.12.zip&#34;&gt;YaHei.Consolas.1.12.zip&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;一些从-linux-迁移到windows的东西&#34;&gt;一些从&lt;code&gt;Linux&lt;/code&gt;迁移到Windows的东西&lt;/h3&gt;

&lt;p&gt;最常用的当属&lt;code&gt;bash&lt;/code&gt;了,包含&lt;code&gt;md5sum&lt;/code&gt;,&lt;code&gt;wget&lt;/code&gt;,&lt;code&gt;curl&lt;/code&gt;,&lt;code&gt;awk&lt;/code&gt;等等.&lt;/p&gt;

&lt;p&gt;有两个比较好的项目在移植&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;unxutils&lt;/em&gt; &lt;a href=&#34;http://unxutils.sourceforge.net/&#34;&gt;http://unxutils.sourceforge.net/&lt;/a&gt;  源码 &lt;a href=&#34;https://sourceforge.net/projects/unxutils/&#34;&gt;https://sourceforge.net/projects/unxutils/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;win-bash&lt;/em&gt; &lt;a href=&#34;https://sourceforge.net/projects/win-bash/&#34;&gt;https://sourceforge.net/projects/win-bash/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;unxutils&lt;/code&gt;最后更新2014-04-03&lt;/p&gt;

&lt;p&gt;&lt;code&gt;win-bash&lt;/code&gt;最后更新2015-03-30&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sourceforge&lt;/code&gt;上速度太慢,这里提供加速下载.&lt;/p&gt;

&lt;p&gt;win-bash&lt;a href=&#34;http://share.suconghou.cn/tools/shell.w32-ix86.zip&#34;&gt;shell.w32-ix86.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的github也收集了一些&lt;code&gt;windows&lt;/code&gt;上常用的小工具&lt;code&gt;axel&lt;/code&gt;,&lt;code&gt;putty&lt;/code&gt;,&lt;code&gt;ab&lt;/code&gt;,&lt;code&gt;hugo&lt;/code&gt;,&lt;code&gt;rsync&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/suconghou/tools&#34;&gt;http://github.com/suconghou/tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Curl 官网 &lt;a href=&#34;https://curl.haxx.se/download.html&#34;&gt;https://curl.haxx.se/download.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Curl 这里可以下载windows版的
&lt;a href=&#34;http://www.paehl.com/open_source/?CURL_7.49.1&#34;&gt;http://www.paehl.com/open_source/?CURL_7.49.1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks client</title>
      <link>http://blog.suconghou.cn/software/shadowsocks-client/</link>
      <pubDate>Sun, 17 Jul 2016 20:37:31 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/shadowsocks-client/</guid>
      <description>

&lt;h2 id=&#34;shadowsocks-各平台客户端&#34;&gt;shadowsocks 各平台客户端&lt;/h2&gt;

&lt;p&gt;文件来源于&lt;code&gt;github.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;windows平台&#34;&gt;windows平台&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/shadowsocks/Shadowsocks-3.0.zip&#34;&gt;Shadowsocks-3.0&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;mac平台&#34;&gt;mac平台&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/shadowsocks/ShadowsocksX-2.6.3.dmg&#34;&gt;ShadowsocksX-2.6.3&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;android平台&#34;&gt;android平台&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/shadowsocks/shadowsocks-nightly-3.0.3.apk&#34;&gt;shadowsocks-nightly-3.0.3&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;服务端可以使用docker更方便 &lt;a href=&#34;https://hub.docker.com/r/suconghou/shadowsocks/&#34;&gt;shadowsocks docker&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>picasa photo viewer</title>
      <link>http://blog.suconghou.cn/software/picasa-photo-viewer/</link>
      <pubDate>Sun, 17 Jul 2016 20:30:43 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/picasa-photo-viewer/</guid>
      <description>

&lt;h2 id=&#34;picasaphotoviewer-图片查看器-v3-9-136-9&#34;&gt;PicasaPhotoViewer(图片查看器) v3.9.136.9&lt;/h2&gt;

&lt;p&gt;Picasa内置的图片浏览器,Google出品,此版本为独木成林提取出来的.&lt;/p&gt;

&lt;p&gt;只有1.7MB,启动速度快,十分好用,有一个缺点是可能因为版权问题未对GIF做支持.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/ImageView/PicasaPhotoViewer_3.9.136.9.exe&#34;&gt;PicasaPhotoViewerv3.9.136.9&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git for windows</title>
      <link>http://blog.suconghou.cn/software/git-for-windows/</link>
      <pubDate>Sun, 17 Jul 2016 20:11:26 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/git-for-windows/</guid>
      <description>

&lt;h2 id=&#34;git-for-windows-国内下载&#34;&gt;git for windows 国内下载&lt;/h2&gt;

&lt;p&gt;所有资源均来源于官网&lt;code&gt;http://git-scm.com/download/win&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最新版本2.9.3.2,发布于2016-08-25&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;32位资源&#34;&gt;32位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.9.3.2-32-bit.exe&#34;&gt;32位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.9.3.2-64-bit.7z.exe&#34;&gt;32位绿色版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;64位资源&#34;&gt;64位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.9.3.2-64-bit.exe&#34;&gt;64位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.9.3.2-64-bit.7z.exe&#34;&gt;64位绿色版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;版本2.9.3,发布于2016-08-13&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;32位资源-1&#34;&gt;32位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.9.3-32-bit.exe&#34;&gt;32位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.9.3-64-bit.7z.exe&#34;&gt;32位绿色版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;64位资源-1&#34;&gt;64位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.9.3-64-bit.exe&#34;&gt;64位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.9.3-64-bit.7z.exe&#34;&gt;64位绿色版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;版本2.9.2,发布于2016-7-16&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;32位资源-2&#34;&gt;32位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.9.2-32-bit.exe&#34;&gt;32位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.9.2-64-bit.7z.exe&#34;&gt;32位绿色版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;64位资源-2&#34;&gt;64位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.9.2-64-bit.exe&#34;&gt;64位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.9.2-64-bit.7z.exe&#34;&gt;64位绿色版&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>react native</title>
      <link>http://blog.suconghou.cn/post/react-native/</link>
      <pubDate>Mon, 11 Jul 2016 11:39:08 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/react-native/</guid>
      <description>

&lt;h2 id=&#34;react-native&#34;&gt;react native&lt;/h2&gt;

&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;

&lt;p&gt;前提是需要node和npm,这里不在赘述.介绍一个npm加速的.&lt;/p&gt;

&lt;p&gt;使用淘宝的npm镜像.控制台运行,或者加入你的bashrc中永久生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias cnpm=&amp;quot;npm --registry=https://registry.npm.taobao.org --cache=$HOME/.npm/.cache/cnpm --disturl=https://npm.taobao.org/dist --userconfig=$HOME/.cnpmrc&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装开发必备的一些package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install -g react-native-cli webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react-native&lt;/code&gt;也调用了&lt;code&gt;npm&lt;/code&gt;命令,所以我们可以再来个alias加速&lt;code&gt;react-native init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alias npm=&#39;cnpm&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者直接将仓库改为淘宝的NPM镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org
npm config set disturl https://npm.taobao.org/dist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在mac上还需要一些东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install flow watchman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完以后可以开始helloworld了.&lt;/p&gt;

&lt;h3 id=&#34;开始第一个例子&#34;&gt;开始第一个例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /data/tmp
react-native init HelloWorld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后正在初始化大致如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This will walk you through creating a new React Native project in /data/tmp/HelloWorld
Installing react-native package from npm...
Setting up new React Native app in /data/tmp/HelloWorld
HelloWorld@0.0.1 /data/tmp/HelloWorld
└── react@15.2.1

To run your app on iOS:
   cd /data/tmp/HelloWorld
   react-native run-ios
   - or -
   Open /data/tmp/HelloWorld/ios/HelloWorld.xcodeproj in Xcode
   Hit the Run button
To run your app on Android:
   Have an Android emulator running (quickest way to get started), or a device connected
   cd /data/tmp/HelloWorld
   react-native run-android
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;React&lt;/code&gt;类名(组件名)必须首字母大写才会被认为是一个组件,否则在JSX里只会当做普通标签&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发IOS的教程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们执行&lt;code&gt;react-native run-ios&lt;/code&gt;开始编译运行,前提是你必须安装了&lt;code&gt;xcode&lt;/code&gt;哦.&lt;/p&gt;

&lt;p&gt;执行后,出现&lt;code&gt;BUILD SUCCEEDED&lt;/code&gt;,同时自动打开新的终端运行了一个server在8081端口.&lt;/p&gt;

&lt;p&gt;模拟器中也会出现刚编译好的app的窗口,使用&lt;code&gt;cmd+r&lt;/code&gt;刷新,&lt;code&gt;cmd+d&lt;/code&gt;弹出开发菜单.&lt;/p&gt;

&lt;p&gt;我们可以修改&lt;code&gt;index.ios.js&lt;/code&gt;开始开发了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发Android的教程&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;fetch&lt;/code&gt;调用接口时,可能会出现&lt;code&gt;The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.&lt;/code&gt;错误&lt;/p&gt;

&lt;p&gt;这是IOS9要求必须使用https通信,需要修改 &lt;a href=&#34;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&#34;&gt;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;react native&lt;/code&gt;创建&lt;code&gt;Info.plist&lt;/code&gt;时就已经为我们说明了,在&lt;code&gt;NSExceptionDomains&lt;/code&gt;下面的&lt;code&gt;dict&lt;/code&gt;里添加一个排除域名就OK了.&lt;/p&gt;

&lt;p&gt;注意,不能将默认的&lt;code&gt;localhost&lt;/code&gt;去掉,否则会出现&lt;code&gt;_fbBatchedBridge is undefined&lt;/code&gt;错误.&lt;/p&gt;

&lt;h2 id=&#34;打包&#34;&gt;打包&lt;/h2&gt;

&lt;h3 id=&#34;对android项目打包&#34;&gt;对android项目打包&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;keytool&lt;/code&gt;生成签名文件,在任意目录下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -v -keystore my-release-key.keystore  -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面&lt;code&gt;my-release-key&lt;/code&gt;可以自己定义,后面的&lt;code&gt;my-key-alias&lt;/code&gt;也可以自己定义.运行后输入一下相关信息后,生成&lt;code&gt;my-release-key.keystore&lt;/code&gt;文件.&lt;/p&gt;

&lt;p&gt;其中输入的两次密码,需要记住.将这个文件移动到&lt;code&gt;android/app&lt;/code&gt;目录下,编译&lt;code&gt;android/app&lt;/code&gt;里的&lt;code&gt;build.gradle&lt;/code&gt;,添加下面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    ...
    defaultConfig { ... }
    signingConfigs {
        release {
            storeFile file(MYAPP_RELEASE_STORE_FILE)
            storePassword MYAPP_RELEASE_STORE_PASSWORD
            keyAlias MYAPP_RELEASE_KEY_ALIAS
            keyPassword MYAPP_RELEASE_KEY_PASSWORD
        }
    }
    ...
    buildTypes {
        release {
              ...
              signingConfig signingConfigs.release
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;android&lt;/code&gt;目录下运行如下命令,就可以打包,安装到自己手机上,前提是手机已usb调试连接到电脑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew assembleRelease
cd app/build/outputs/apk
adb install -r app-release.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://facebook.github.io/react-native/docs/signed-apk-android.html&#34;&gt;https://facebook.github.io/react-native/docs/signed-apk-android.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>都有哪些坑</title>
      <link>http://blog.suconghou.cn/post/some-hole/</link>
      <pubDate>Thu, 07 Jul 2016 15:46:03 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/some-hole/</guid>
      <description>

&lt;h2 id=&#34;总结一下遇到的坑&#34;&gt;总结一下遇到的坑&lt;/h2&gt;

&lt;h3 id=&#34;微信&#34;&gt;微信&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;关于横竖屏的坑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;css3可以使用媒体查询判断设备是横屏还是竖屏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//横屏时显示
@media all and (orientation : landscape) {
#screenMask{display:block}
}

//竖屏时隐藏
@media all and (orientation : portrait) {
#screenMask{display:none}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在手机浏览器中表现良好,微信中看样子也可以,但是微信网页中如果聚焦输入框,弹起键盘就有问题了.&lt;/p&gt;

&lt;p&gt;软键盘弹起后,网页可用面积减小,安卓就自动识别为横屏了,原有的页面消失了,影响非常大.IOS则没有这个问题,媒体查询判断横竖屏在IOS上工作良好.&lt;/p&gt;

&lt;p&gt;并且由此发现,css3媒体查询就是根据宽度是否比高度小来判断横竖屏的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方案1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;javascript&lt;/code&gt;的&lt;code&gt;orientation&lt;/code&gt;和&lt;code&gt;orientationchange&lt;/code&gt;判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;window.orientation   属于window对象上一个属性；共有三个值 ：0为竖屏模式（portrait）,90为向左反转变为横屏模式（landscape），-90为向右反转变为横屏模式（landscape），最后180就是设备上下互换还是竖屏模式。&lt;/li&gt;
&lt;li&gt;orientationchange    是一个event，在设备旋转时，会触发此事件，如同PC上使用的resize事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var init = function(){
        var updateOrientation = function(){
            var orientation = window.orientation;
            switch(orientation){
                case 90:
                case -90:
                    orientation = &#39;landscape&#39;;
                    break;
                default:
                    orientation = &#39;portrait&#39;;
                    break;
            }

           //do something
           //比如在html标签加一个状态
            //然后根据不同状态，显示不同大小
            document.body.parentNode.setAttribute(&#39;class&#39;,orientation);
        };

        window.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        updateOrientation();
    };

    window.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试使用JS判断能够正确得出安卓微信客户端里输入框聚焦时的横竖屏状态.&lt;/p&gt;

&lt;p&gt;orientation和orientationchange只有移动设备有这些属性和事件.&lt;/p&gt;

&lt;p&gt;在不支持这种属性和事件的设备上使用宽高比来判断做一下兼容,这样在不支持&lt;code&gt;orientation&lt;/code&gt;的设备上就相当于使用了媒体查询&lt;/p&gt;

&lt;p&gt;最终总结代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(w)
{
    var supportOrientation = (typeof w.orientation === &#39;number&#39; &amp;amp;&amp;amp; typeof w.onorientationchange === &#39;object&#39;);
    var init = function()
    {
        var htmlNode = document.body.parentNode, orientation;
        var updateOrientation = function()
        {
            if(supportOrientation)
            {
                orientation = w.orientation;
                switch(orientation)
                {
                    case 90:
                    case -90:
                        orientation = &#39;landscape&#39;;
                        break;
                    default:
                        orientation = &#39;portrait&#39;;
                        break;
                }
            }
            else
            {
                orientation = (w.innerWidth &amp;gt; w.innerHeight) ? &#39;landscape&#39; : &#39;portrait&#39;;
            }
            htmlNode.setAttribute(&#39;class&#39;,orientation);
        };
        if(supportOrientation)
        {
            w.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        }
        else
        {
            //监听resize事件
            w.addEventListener(&#39;resize&#39;,updateOrientation,false);
        }
        updateOrientation();
    };
    w.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以访问如下网址测试: /html/wx&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP最佳实践</title>
      <link>http://blog.suconghou.cn/post/php-best-way/</link>
      <pubDate>Thu, 30 Jun 2016 16:40:13 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/php-best-way/</guid>
      <description>

&lt;h2 id=&#34;性能优化&#34;&gt;性能优化&lt;/h2&gt;

&lt;h3 id=&#34;数组相关&#34;&gt;数组相关&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;in_array&lt;/code&gt;在大数据量(数万以上元素)下效率低下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在分析nginx log得出所有不重复IP时,采用&lt;code&gt;in_array&lt;/code&gt;判断,50多万的数据耗时需要五六分钟,而采用存键的方法,用&lt;code&gt;isset&lt;/code&gt;判断仅需要十几秒,效率差别非常大. [php7环境下]&lt;/p&gt;

&lt;p&gt;判断一个数组是否存在某个元素,远比查找一个键消耗的要多.前者时间复杂度O(n),而后者O(1)&lt;/p&gt;

&lt;p&gt;即时使用&lt;code&gt;in_array&lt;/code&gt;,也需要加上第三个参数,设置为严格模式,省略数据类型转化的开销,设置为&lt;code&gt;true&lt;/code&gt;比设置为&lt;code&gt;false&lt;/code&gt;性能要提升好几倍.&lt;/p&gt;

&lt;p&gt;这种情况下使用&lt;code&gt;array_search&lt;/code&gt;情况比&lt;code&gt;in_array&lt;/code&gt;更加糟糕&lt;/p&gt;

&lt;p&gt;如果条件允许使用&lt;code&gt;array_flip&lt;/code&gt;交换键值,在用&lt;code&gt;isset&lt;/code&gt;来判断要比&lt;code&gt;in_array&lt;/code&gt;好得多&lt;/p&gt;

&lt;p&gt;同时,使用&lt;code&gt;isset&lt;/code&gt;来判断数组的键,也比使用&lt;code&gt;array_key_exists&lt;/code&gt;要好&lt;/p&gt;

&lt;p&gt;而对于本题,还可以使用&lt;code&gt;array_unique&lt;/code&gt;最后去重,用空间换时间,效率仅次于用&lt;code&gt;isset&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;bugs&#34;&gt;Bugs&lt;/h2&gt;

&lt;h3 id=&#34;php-pdo-mysql-server-has-gone-away&#34;&gt;php pdo &lt;code&gt;MySQL server has gone away&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在使用PDO长连接时,执行过一次PDO初始化后,php-fpm进程会与mysql server开启一条TCP长连接,下次连接数据库就能加快速度.&lt;/p&gt;

&lt;p&gt;但是却存在一定问题,PDO维持了长连接并没有较好的检测其可用性,如果mysql server kill 掉这个连接,或者mysql重启,都会造成&lt;/p&gt;

&lt;p&gt;重新实例化PDO时得到旧的链接,导致出现&lt;code&gt;MySQL server has gone away&lt;/code&gt;,更让人郁闷的是这个错误并不是一个Exception,无法被catch捕获,即使设置&lt;code&gt;PDO::ATTR_ERRMODE=&amp;gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt;,也不行,还是直接在页面上提示.&lt;/p&gt;

&lt;p&gt;如果你使用了&lt;code&gt;set_error_handler&lt;/code&gt;,那么这个&lt;code&gt;Warning&lt;/code&gt;将会被捕捉,不会直接显示在页面上,但也改变了程序的原有执行逻辑.&lt;/p&gt;

&lt;p&gt;如果你不使用&lt;code&gt;set_error_handler&lt;/code&gt;,页面上报出&lt;code&gt;Warning&lt;/code&gt;,但其实PDO已经返回一个可用的链接了.&lt;/p&gt;

&lt;p&gt;猜测可能是PDO首先得到了不可用的然后报警告,然后又创建了一个新的.&lt;/p&gt;

&lt;p&gt;较好的解决方法是设置&lt;code&gt;set_error_handler&lt;/code&gt;若捕获了这个&lt;code&gt;MySQL server has gone away&lt;/code&gt;,则返回null,程序继续按原有逻辑执行.&lt;/p&gt;

&lt;p&gt;或者不使用PDO长连接.&lt;/p&gt;

&lt;p&gt;注意,&lt;code&gt;set_error_handler&lt;/code&gt;返回false的话,这个错误还是会被交到上一级错误程序处理的.&lt;/p&gt;

&lt;h3 id=&#34;编码转换中的若干问题&#34;&gt;编码转换中的若干问题&lt;/h3&gt;

&lt;p&gt;我们经常会遇到将utf8编码字符转化为gbk编码的字符,例如生成csv表格,在windows上的cmd窗口输出文字,以及操作windows上的有关文件路径的操作都需要使用gbk编码.&lt;/p&gt;

&lt;p&gt;常使用&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $str);&lt;/code&gt;将utf8字符转为gbk&lt;/p&gt;

&lt;p&gt;这里 utf gbk 不区分大小写,也可以混写,不区分是&lt;code&gt;utf8&lt;/code&gt;还是&lt;code&gt;utf-8&lt;/code&gt;,都能都正常使用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk//ignore&#39;, $str);&lt;/code&gt; 加上&lt;code&gt;//ignore&lt;/code&gt;使有些字符无法装换时略过.&lt;/p&gt;

&lt;p&gt;但是&lt;code&gt;//ignore&lt;/code&gt;在php5.4及以下,和个别php5.6版本上无效,任然是报NOTICE错误.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	echo iconv(&#39;UTF8&#39;, &#39;GBK//IGNORE&#39;, &#39;l l l&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;code&gt;https://3v4l.org/7vCFW&lt;/code&gt; 和 &lt;code&gt;http://www.php.net/manual/en/function.iconv.php&lt;/code&gt;第一条评论&lt;/p&gt;

&lt;p&gt;可以考虑使用&lt;code&gt;$content = mb_convert_encoding($content, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;);&lt;/code&gt; 从UTF8转为GBK&lt;/p&gt;

&lt;p&gt;这样不会报错,不能装换的被替换为?,参数也是不区分大小写,utf8和utf-8&lt;/p&gt;

&lt;h3 id=&#34;filter-var-filter-validate-url&#34;&gt;filter_var FILTER_VALIDATE_URL&lt;/h3&gt;

&lt;p&gt;filter_var FILTER_VALIDATE_URL 中不能包含中文,包含中文被判定为false&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks libev</title>
      <link>http://blog.suconghou.cn/post/shadowsocks-libev/</link>
      <pubDate>Wed, 18 May 2016 17:37:16 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/shadowsocks-libev/</guid>
      <description>

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;yum update &amp;amp;&amp;amp; yum install -y zip unzip xz curl wget git gcc make zlib zlib-devel openssl openssl-devel
git clone https://github.com/shadowsocks/shadowsocks-libev.git
cd shadowsocks-libev
./configure --enable-static=yes
export CFLAGS=&amp;quot;-O3&amp;quot;
make -j4 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;GO语言版本的也十分方便哦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里提供一个基于&lt;code&gt;docker&lt;/code&gt;的go语言版本,&lt;a href=&#34;https://hub.docker.com/r/suconghou/shadowsocks/&#34;&gt;docker go shadowsocks&lt;/a&gt;,只有3.3MB
十分方便&lt;/p&gt;

&lt;p&gt;同时也含有libev版本的可供选择&lt;/p&gt;

&lt;h2 id=&#34;网络内核参数优化&#34;&gt;网络内核参数优化&lt;/h2&gt;

&lt;p&gt;修改&lt;code&gt;ulimit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vim /etc/security/limits.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加一下两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* soft nofile 51200
* hard nofile 51200
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用tcpdump与ngrep</title>
      <link>http://blog.suconghou.cn/post/tcpdump/</link>
      <pubDate>Mon, 16 May 2016 18:21:04 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/tcpdump/</guid>
      <description>

&lt;p&gt;各版本 &lt;code&gt;http://www.tcpdump.org/release/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装依赖 &lt;code&gt;yum install -y flex gcc make byacc&lt;/code&gt; or &lt;code&gt;apt-get install flex gcc make byacc wget bzip2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
wget http://www.tcpdump.org/release/libpcap-1.7.4.tar.gz
tar zxf libpcap-1.7.4.tar.gz
cd libpcap-1.7.4
./configure --prefix=/tmp/lib
make -j4 &amp;amp;&amp;amp; make install
cd ../
wget http://www.tcpdump.org/release/tcpdump-4.7.4.tar.gz
tar zxf tcpdump-4.7.4.tar.gz
cd tcpdump-4.7.4
./configure --prefix=/tmp  --disable-ipv6 CFLAGS=&#39;-O3 -I/tmp/lib/include&#39; LDFLAGS=&#39;-L/tmp/lib/lib/libpcap.a&#39;
make -j4
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后,位于&lt;code&gt;ls -lh /tmp/sbin/tcpdump&lt;/code&gt; &lt;code&gt;ldd&lt;/code&gt;查看此文件依赖较少,可直接复制到其他Linux上使用.&lt;/p&gt;

&lt;p&gt;采用&lt;code&gt;CFLAGS=&amp;quot;-O3&amp;quot;&lt;/code&gt;编译后为1.2MB&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tcpdump -h&lt;/code&gt; 查看版本号以及用法&lt;/p&gt;

&lt;p&gt;我编译好的tcpdump version 4.7.4&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/bin/tcpdump.xz&#34;&gt;http://share.suconghou.cn/bin/tcpdump.xz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也可以直接&lt;code&gt;yum install tcpdump&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用tcpdump&#34;&gt;使用tcpdump&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;-a 　　　将网络地址和广播地址转变成名字；
-d 　　　将匹配信息包的代码以人们能够理解的汇编格式给出；
-dd 　　 将匹配信息包的代码以c语言程序段的格式给出；
-ddd 　　将匹配信息包的代码以十进制的形式给出；
-e 　　　在输出行打印出数据链路层的头部信息；
-f 　　　将外部的Internet地址以数字的形式打印出来；
-l 　　　使标准输出变为缓冲行形式；
-n 　　　不把网络地址转换成名字；
-t 　　　在输出的每一行不打印时间戳；
-v 　　　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；
-vv 　　 输出详细的报文信息；
-c 　　　在收到指定的包的数目后，tcpdump就会停止；
-F 　　　从指定的文件中读取表达式,忽略其它的表达式；
-i 　　　指定监听的网络接口；
-r 　　　从指定的文件中读取包(这些包一般通过-w选项产生)；
-w 　　　直接将包写入文件中，并不分析和打印出来；
-T 　　　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;tcpdump host 210.27.48.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-A&lt;/code&gt;和&lt;code&gt;-X&lt;/code&gt;有助于你查看详细的报文数据&lt;/p&gt;

&lt;h2 id=&#34;ngrep&#34;&gt;ngrep&lt;/h2&gt;

&lt;p&gt;ngrep 编译总是出问题,建议直接安装:&lt;code&gt;apt-get install ngrep&lt;/code&gt; &lt;code&gt;yum install ngrep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果更关注于TCP流量内容,可以使用&lt;code&gt;ngrep&lt;/code&gt;,他是grep命令的网络版,同样需要libpcap库,能识别TCP、UDP和ICMP包，理解bpf的过滤机制&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngrep -W byline -d eno1 port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;具体使用见
&lt;a href=&#34;http://man.linuxde.net/ngrep&#34;&gt;http://man.linuxde.net/ngrep&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>编译安装Apache Traffic Server</title>
      <link>http://blog.suconghou.cn/post/use-apache-traffic-server/</link>
      <pubDate>Mon, 09 May 2016 22:24:14 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-apache-traffic-server/</guid>
      <description>

&lt;h2 id=&#34;编译安装&#34;&gt;编译安装&lt;/h2&gt;

&lt;p&gt;Centos下编译安装&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;yum update -y &amp;amp;&amp;amp; yum install wget gcc g++ gcc-c++ glibc-headers perl openssl openssl-devel tcl-devel libxml2-devel pcre-devel
wget http://apache.fayea.com/trafficserver/trafficserver-6.1.1.tar.bz2
tar xvjf trafficserver-6.1.1.tar.bz2
cd trafficserver-6.1.1
./configure
make &amp;amp;&amp;amp; make install
useradd -s /sbin/nologin trafficserver
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apache镜像&lt;a href=&#34;http://archive.apache.org/dist/&#34;&gt;http://archive.apache.org/dist/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;国内Apache镜像&lt;a href=&#34;http://apache.fayea.com/&#34;&gt;http://apache.fayea.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;编译完成后,就可以使用了,默认是安装在&lt;code&gt;/usr/local/bin&lt;/code&gt;,编译后是比较大&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;total 98M
-rwxr-xr-x 1 root root 692K May  9 14:30 header_rewrite_test
-rwxr-xr-x 1 root root 520K May  9 14:30 traffic_cop
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_crashlog
-rwxr-xr-x 1 root root 259K May  9 14:30 traffic_ctl
-rwxr-xr-x 1 root root 1.9M May  9 14:30 traffic_layout
-rwxr-xr-x 1 root root  41K May  9 14:30 traffic_line
-rwxr-xr-x 1 root root 4.4M May  9 14:30 traffic_logcat
-rwxr-xr-x 1 root root 5.0M May  9 14:30 traffic_logstats
-rwxr-xr-x 1 root root 4.7M May  9 14:30 traffic_manager
-rwxr-xr-x 1 root root  37M May  9 14:30 traffic_sac
-rwxr-xr-x 1 root root  43M May  9 14:30 traffic_server
-rwxr-xr-x 1 root root  42K May  9 14:30 traffic_via
-rwxr-xr-x 1 root root  18K May  9 14:30 trafficserver
-rwxr-xr-x 1 root root 2.1K May  9 14:30 tspush
-rwxr-xr-x 1 root root 5.7K May  9 14:30 tsxs

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行&lt;code&gt;traffic_server -R 1&lt;/code&gt;执行测试,经过一系列测试后,显示&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Tests Passed: 177
Tests Failed: 0
    REGRESSION_RESULT PARENTSELECTION:                          PASSED
REGRESSION_TEST DONE: PASSED
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;全部测试通过&lt;/p&gt;

&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;

&lt;p&gt;默认的配置文件存放在&lt;code&gt;/usr/local/etc/trafficserver&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;drwxr-xr-x 3 nobody nobody 1.0K May  9 14:30 body_factory
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 cache.config
-rw-r--r-- 1 nobody nobody  657 May  9 14:30 cluster.config
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 congestion.config
-rw-r--r-- 1 nobody nobody  746 May  9 14:30 hosting.config
-rw-r--r-- 1 nobody nobody 1.8K May  9 14:30 icp.config
-rw-r--r-- 1 nobody nobody 1.2K May  9 14:30 ip_allow.config
-rw-r--r-- 1 nobody nobody  328 May  9 14:30 log_hosts.config
-rw-r--r-- 1 nobody nobody  17K May  9 14:30 logs_xml.config
-rw-r--r-- 1 nobody nobody 1.4K May  9 14:30 parent.config
-rw-r--r-- 1 nobody nobody  261 May  9 14:30 plugin.config
-rw-r--r-- 1 nobody nobody  13K May  9 14:30 records.config
-rw-r--r-- 1 nobody nobody 8.6K May  9 14:30 remap.config
-rw-r--r-- 1 nobody nobody 1.7K May  9 14:30 socks.config
-rw-r--r-- 1 nobody nobody 2.1K May  9 14:30 splitdns.config
-rw-r--r-- 1 nobody nobody 2.7K May  9 14:30 ssl_multicert.config
-rw-r--r-- 1 nobody nobody  76K May  9 14:30 stats.config.xml
-rw-r--r-- 1 nobody nobody 1.9K May  9 14:30 storage.config
-rw-r--r-- 1 root   root     19 May  9 14:30 trafficserver-release
-rw-r--r-- 1 nobody nobody  649 May  9 14:30 vaddrs.config
-rw-r--r-- 1 nobody nobody 1.3K May  9 14:30 volume.config

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;records.config&lt;/code&gt;负责大部分全局的选项设置，即主要配置文件&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;CONFIG proxy.config.reverse_proxy.enabled INT 1                           # 开启反向代理
CONFIG proxy.config.url_remap.remap_required INT 1                        # 1 代理反向代理，0代表正向+反向代理
CONFIG proxy.config.http.cache.http INT 1                                 # 打开http缓存功能
CONFIG proxy.config.cache.ram_cache.size INT 512M                         # RAM 缓存大小
CONFIG proxy.config.http.keep_alive_no_activity_timeout_out INT 120       # 当一个事务结束后同原服务器保持连接的时间
CONFIG proxy.config.cluster.ethernet_interface STRING eth0                # 修改成需要侦听的interface名称

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;remap.config&lt;/code&gt;定义映射规则，用于请求的重定向（rewrite）,反向代理即在此配置&lt;/p&gt;

&lt;p&gt;&lt;code&gt;storage.config&lt;/code&gt; 用于指定磁盘存储&lt;/p&gt;

&lt;p&gt;启动&lt;code&gt;trafficserver start&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在树莓派上使用Docker</title>
      <link>http://blog.suconghou.cn/post/use-docker-on-raspberry/</link>
      <pubDate>Sun, 08 May 2016 20:01:56 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-docker-on-raspberry/</guid>
      <description>

&lt;h2 id=&#34;安装支持docker的系统&#34;&gt;安装支持Docker的系统&lt;/h2&gt;

&lt;p&gt;树莓派官方系统并不支持Docker,需要安装.&lt;/p&gt;

&lt;p&gt;查看 &lt;a href=&#34;http://blog.hypriot.com/downloads/&#34;&gt;集成Dcoker的树莓派系统&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;aria2c -s 50 -c https://downloads.hypriot.com/hypriotos-rpi-v0.8.0.img.zip


diskutil list
diskutil unmountdisk /dev/disk2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;用以下命令前必须卸载u盘&lt;code&gt;diskutil unmountdisk /dev/disk2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sudo dd if=hypriotos-rpi-v0.8.0.img of=/dev/disk2 bs=8k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完成重启就可以啦,启动后登陆的用户是pirate,密码hypriot&lt;/p&gt;

&lt;p&gt;修改密码:执行&lt;code&gt;passwd&lt;/code&gt;,输入当前密码,输入新密码,再输入新密码,更新完成&lt;/p&gt;

&lt;p&gt;执行&lt;code&gt;exit&lt;/code&gt;退出,或者&lt;code&gt;sudo reboot&lt;/code&gt;重启&lt;/p&gt;

&lt;p&gt;创建用户:&lt;code&gt;useradd -g test -d /home/test1 -s /etc/bash -m test1&lt;/code&gt;
注解：-g 所属组 -d 家目录 -s 所用的SHELL
passwd abc&lt;/p&gt;

&lt;p&gt;获得sudo权限:编辑&lt;code&gt;/etc/sudoers&lt;/code&gt; 加入新添加的用户名&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>苏苏的博客</title>
    <link>http://blog.suconghou.cn/index.xml</link>
    <description>Recent content on 苏苏的博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 18 Oct 2016 19:18:24 +0800</lastBuildDate>
    <atom:link href="http://blog.suconghou.cn/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>use kvm</title>
      <link>http://blog.suconghou.cn/post/use-kvm/</link>
      <pubDate>Tue, 18 Oct 2016 19:18:24 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-kvm/</guid>
      <description>

&lt;h1 id=&#34;安装和配置kvm&#34;&gt;安装和配置KVM&lt;/h1&gt;

&lt;h2 id=&#34;kvm与xen区别&#34;&gt;KVM与XEN区别&lt;/h2&gt;

&lt;p&gt;OPENVZ就不说了,是半虚拟化,不能安装Windows操作系统&lt;/p&gt;

&lt;p&gt;KVM是内核模块,从2.6.20内核开始,kvm模块就包含在Linux内核中,只需加载此模块即可&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#查看宿主机CPU是否在硬件上支持虚拟化扩展特性
cat /proc/cpuinfo | grep -E &amp;quot;(vmx|svm)&amp;quot;

#加载kvm模块（Intel VT）
modprobe kvm
modprobe kvm-intel
#注意：如果加载失败，说明服务器硬件不支持或BIOS中未开启虚拟化扩展
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;运行命令&lt;code&gt;lsmod | grep kvm&lt;/code&gt;检查 KVM 模块是否成功安装&lt;/p&gt;

&lt;p&gt;XEN是一套虚拟化方案,可以直接安装,不需要先安装操作系统.&lt;/p&gt;

&lt;p&gt;KVM起步较晚,XEN起步早发展成熟,但目前KVM潜力较大.&lt;/p&gt;

&lt;h2 id=&#34;kvm-与-qemu&#34;&gt;KVM 与 qemu&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;yum install qemu-kvm libvirt virt-install bridge-utils&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;qemu-kvm 该软件包主要包含KVM内核模块和适用于KVM的QEMU模拟器。KVM模块负责CPU和内存的调度，QEMU负责虚拟机I/O设备的模拟。&lt;/p&gt;

&lt;p&gt;libvirt 提供Hypervisor和虚拟机的管理功能。&lt;/p&gt;

&lt;p&gt;virt-install 创建和克隆虚拟机的命令行工具包。&lt;/p&gt;

&lt;p&gt;bridge-utils 网桥管理工具包，负责桥接网络的创建、配置和管理等工作。&lt;/p&gt;

&lt;h2 id=&#34;激活并启动libvirtd服务&#34;&gt;激活并启动libvirtd服务&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;systemctl enable libvirtd
systemctl start libvirtd
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;安装centos7&#34;&gt;安装CentOS7&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;diskutil list&lt;/code&gt;查看所有磁盘&lt;/p&gt;

&lt;p&gt;&lt;code&gt;diskutil unmountdisk /dev/disk1&lt;/code&gt; 解除其挂载&lt;/p&gt;

&lt;p&gt;用dd将ISO文件写入&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo dd if=/data/files/iso/CentOS-7-x86_64-Minimal-1511.iso of=/dev/disk2 bs=1m&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装好系统后,更换网易的源 &lt;a href=&#34;http://mirrors.163.com/.help/centos.html&#34;&gt;http://mirrors.163.com/.help/centos.html&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
cd /etc/yum.repos.d
wget http://mirrors.163.com/.help/CentOS7-Base-163.repo
yum clean all
yum makecache
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;搜狐也有,但版本太老 &lt;a href=&#34;http://mirrors.sohu.com/help/centos.html&#34;&gt;http://mirrors.sohu.com/help/centos.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;可以使用清华大学的. &lt;a href=&#34;https://lug.ustc.edu.cn/wiki/mirrors/help/centos&#34;&gt;https://lug.ustc.edu.cn/wiki/mirrors/help/centos&lt;/a&gt; 速度都十分快.&lt;/p&gt;

&lt;h2 id=&#34;启用kvm后-需要配置网卡&#34;&gt;启用KVM后,需要配置网卡&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;cd /etc/sysconfig/network-scripts/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;桥接网卡&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl addbr br0&lt;/code&gt; 添加一个虚拟网卡&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl addif br0 em2&lt;/code&gt; 将网卡&lt;code&gt;br0&lt;/code&gt;桥接到&lt;code&gt;em2&lt;/code&gt; ,这一步将会导致em2断网,远程ssh将会断开&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl stp br0 on&lt;/code&gt; 将br0设置为启用STP协议&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ifconfig em2 0&lt;/code&gt; #将em2的IP设置为0&lt;/p&gt;

&lt;p&gt;&lt;code&gt;dhclient br0&lt;/code&gt; #将br0网络配置好&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brctl show&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后&lt;code&gt;systemctl restart network&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;route&lt;/code&gt; 查看默认网关&lt;/p&gt;

&lt;h2 id=&#34;创建虚拟机磁盘镜像文件&#34;&gt;创建虚拟机磁盘镜像文件&lt;/h2&gt;

&lt;p&gt;不能创建太小,建议5G-50G&lt;/p&gt;

&lt;p&gt;qcow2格式是kvm支持的标准格式，raw格式为虚拟磁盘文件通用格式。有测试数据表明raw格式的I/O性能略高于qcow2格式，但是在加密，容量，快照方面qcow2格式有优势&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;qemu-img create -f qcow2 test.qcow2 20G  //建立qcow2格式磁盘文件
qemu-img create -f raw test.raw 20G      //建立raw格式磁盘文件
qemu-img info test.qcow2                 //查看已经创建的虚拟磁盘文件

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建虚拟机&lt;/p&gt;

&lt;p&gt;创建 Ubuntu&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name ubuntu \
--ram 512 --vcpus 1 \
--boot network,cdrom,menu=on \
--disk path=/disk/kvm/disk1,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--nographics --accelerate \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--cdrom=/data/iso/ubuntu-16.04.1-server-amd64.iso \
--extra-args=&#39;console=tty0 console=ttyS0,115200n8 serial&#39; \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;创建CentOS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name centos \
--ram 512 --vcpus 1 \
--disk path=/disk/kvm/disk1,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--accelerate \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--location=/data/iso/CentOS-7-x86_64-Minimal-1511.iso \
--extra-args=&#39;console=tty0 console=ttyS0,115200n8 serial&#39; \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;virsh &amp;ndash;connect qemu:///system&lt;/p&gt;

&lt;p&gt;创建Debain&lt;/p&gt;

&lt;p&gt;先挂载 &lt;code&gt;sudo mount -o loop,unhide -t iso9660 -r /data/iso/debian-8.6.0-amd64-CD-1.iso /mnt/cdrom&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;需要nfs启动 &lt;code&gt;service nfs start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加&lt;code&gt;/mnt/cdrom    *(ro,insecure,all_squash)&lt;/code&gt;到文件&lt;code&gt;/etc/exports&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;并刷新&lt;code&gt;exportfs -r&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virt-install \
--name debain \
--ram 512 --vcpus 1 \
--boot network,cdrom,menu=on \
--disk path=/disk/kvm/disk4,size=10,format=qcow2,bus=virtio \
--os-type linux \
--os-variant generic \
--bridge=br0,model=virtio --keymap=en-us \
--console pty,target_type=serial \
--accelerate \
--location=/mnt/cdrom \
--extra-args=&#39;console=tty0 console=ttyS0,115200n8 serial&#39; \
--vnc --vncport=5911 --vnclisten=0.0.0.0 \
--hvm --dry-run
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;disk属性就是指虚拟机使用哪一个磁盘镜像文件作为存储地方，指定刚才创建的镜像文件位置即可，size=10,format=qcow2,bus=virtio分别是指大小，格式（跟镜像格式一致），磁盘总线类型（指Value can be ’ide’, ’scsi’, ’usb’, ’virtio’ or ’xen’，virtio是专门为kvm制定的bus，比较常用），大小需要比镜像文件大小要小，相当于镜像是容器，这个disk是里面的水，水太多就溢出了。&lt;/p&gt;

&lt;p&gt;bridge=br0,model=virtio –keymap=en-us分别指网卡使用，网卡模式即驱动模式，和键盘制式，桥接模式都使用br0，而虚拟机需要使用virtio这个驱动才能使用虚拟网卡，这个虚拟网卡驱动在linux下支持很好，在windows下支持一般，键盘制式如果不指定的话会出现键位错乱的情况，一般我们使用英式。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用&lt;code&gt;virsh&lt;/code&gt;可以管理已创建的虚拟机&lt;/p&gt;

&lt;p&gt;virsh shutdown demo 正常关闭虚拟机&lt;/p&gt;

&lt;p&gt;virsh destroy demo 直接销毁虚拟机&lt;/p&gt;

&lt;p&gt;可见 &lt;a href=&#34;http://www.cnblogs.com/lin1/p/5776280.html&#34;&gt;http://www.cnblogs.com/lin1/p/5776280.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;启动并进入虚拟机&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;virsh start 域名 --console
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;10，彻底删除虚拟机&lt;/p&gt;

&lt;p&gt;1,删除虚拟机   virsh destroy +域名&lt;/p&gt;

&lt;p&gt;2，解除标记     virsh undefine +域名&lt;/p&gt;

&lt;p&gt;3，删除虚拟机文件&lt;/p&gt;

&lt;p&gt;&lt;code&gt;virsh destroy debain &amp;amp;&amp;amp;  virsh undefine debain&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;通过virt-clone命令克隆虚拟机&lt;/p&gt;

&lt;p&gt;&lt;code&gt;virt-clone -o centos -n centos2 -f /disk/kvm/disk2&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>pc hardware</title>
      <link>http://blog.suconghou.cn/post/pc-hardware/</link>
      <pubDate>Sun, 04 Sep 2016 14:37:51 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/pc-hardware/</guid>
      <description>

&lt;h2 id=&#34;修电脑相关知识&#34;&gt;修电脑相关知识&lt;/h2&gt;

&lt;h3 id=&#34;较好的pe&#34;&gt;较好的PE&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;微PE&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.wepe.com.cn/&#34;&gt;http://www.wepe.com.cn/&lt;/a&gt; 自带刻录,可以一键安装到U盘,硬盘等,支持UEFI,CMS等多种启动方式.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;一般的BIOS里找不到UEFI/CMS的切换设置,可能是&lt;code&gt;security boot&lt;/code&gt;的配置,禁用&lt;code&gt;security boot&lt;/code&gt;试试&lt;/p&gt;

&lt;p&gt;如果在BIOS里找不到U盘,可能是&lt;code&gt;fastboot&lt;/code&gt;的问题,可以禁用fastboot,安装好系统后在开启.&lt;/p&gt;

&lt;p&gt;硬盘的设置模式里,找不到U盘或者硬盘,可以尝试切换&lt;code&gt;AHCI/IDE&lt;/code&gt;,注意安装好系统后,此选项不能够再随意切换,否知导致系统进不去.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;休眠能将现有所有工作保存到硬盘,下次开机恢复上次的会话,Windows8及以后采用了混合休眠机制&lt;/p&gt;

&lt;p&gt;你可能找不到单纯的休眠按钮.&lt;/p&gt;

&lt;p&gt;可以使用&lt;code&gt;shutdown -h&lt;/code&gt;休眠&lt;/p&gt;

&lt;p&gt;其他一些补充&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;关机计算机：shutdown.exe -s -t 00
重启计算机：shutdown.exe -r -t 00
注销计算机：shutdown.exe -l -t 00
锁定计算机：rundll32.exe user32.dll,LockWorkStation
休眠计算机：rundll32.exe powrProf.dll,SetSuspendState
睡眠计算机：rundll32.exe powrprof.dll,SetSuspendState 0,1,0,
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;性能天梯图&#34;&gt;性能天梯图&lt;/h2&gt;

&lt;p&gt;CPU天梯图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://suconghou.sinaapp.com/e7d6741f4b703c5057fa6c4f0f3cf971.jpg&#34; alt=&#34;CPU天梯图简化版&#34; /&gt;&lt;/p&gt;

&lt;p&gt;CPU天梯图详细&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://suconghou.sinaapp.com/33f41a782ceddd3a78a7f40321329777.jpg&#34; alt=&#34;CPU天梯图详细&#34; /&gt;&lt;/p&gt;

&lt;p&gt;显卡天梯图&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://suconghou.sinaapp.com/14db00815cebc3e46f9647515b384815.jpg&#34; alt=&#34;显卡天梯图&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>memcached usage</title>
      <link>http://blog.suconghou.cn/post/memcached-usage/</link>
      <pubDate>Wed, 24 Aug 2016 14:44:23 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/memcached-usage/</guid>
      <description>

&lt;h2 id=&#34;安装memcached&#34;&gt;安装memcached&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://memcached.org/downloads&#34;&gt;http://memcached.org/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;memcached所有版本见&lt;a href=&#34;http://www.memcached.org/files/&#34;&gt;http://www.memcached.org/files/&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
MEMCACHE_VERSION=memcached-1.4.31
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.memcached.org/files/${MEMCACHE_VERSION}.tar.gz
tar xzf ${MEMCACHE_VERSION}.tar.gz
cd ${MEMCACHE_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
./configure
make -j$CPU_NUM &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;docker版本见:&lt;a href=&#34;https://hub.docker.com/r/suconghou/memcached/&#34;&gt;https://hub.docker.com/r/suconghou/memcached/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;启动memcached&#34;&gt;启动Memcached&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;memcached -d -u memcached -p 11211 -m 8 -P /var/run/memcached/memcached.pid

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;说明&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;-d 以daemon方式运行&lt;/li&gt;
&lt;li&gt;-u 绑定使用指定用户运行进程(仅在以root运行的时候有效)&lt;/li&gt;
&lt;li&gt;-p 设置TCP端口号(默认11211)&lt;/li&gt;
&lt;li&gt;-m 允许最大内存用量，单位M (默认: 64 MB)&lt;/li&gt;
&lt;li&gt;-M 内存耗尽时返回错误，而不是删除项&lt;/li&gt;
&lt;li&gt;-l 是监听的服务器IP地址，默认应该是本机&lt;/li&gt;
&lt;li&gt;-P 将PID写入文件&lt;file&gt;，这样可以使得后边进行快速进程终止, 需要与-d 一起使用&lt;/li&gt;
&lt;li&gt;-c 最大同时连接数，默认是1024&lt;/li&gt;
&lt;li&gt;-t 线程数,默认为4&lt;/li&gt;
&lt;li&gt;-v 输出警告和错误信息&lt;/li&gt;
&lt;li&gt;-vv 打印客户端的请求和返回信息&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;默认情况下是不限制访问IP的,相当于是外网和内网都能访问,-l 使只有这个IP能访问&lt;/p&gt;

&lt;p&gt;尽量不要用root用户运行.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;状态查看&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用 telnet 连接 memcached
&lt;code&gt;stats settings&lt;/code&gt;可以查看所有参数设置&lt;/p&gt;

&lt;p&gt;memcached状态和性能查看&lt;/p&gt;

&lt;p&gt;stats命令&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://static.suconghou.cn/document/memcached.jpg&#34; alt=&#34;memcached stats命令&#34; /&gt;&lt;/p&gt;

&lt;p&gt;官方也提供监控工具&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/memcached/memcached/blob/master/scripts/memcached-tool&#34;&gt;https://github.com/memcached/memcached/blob/master/scripts/memcached-tool&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>javascript code snippet</title>
      <link>http://blog.suconghou.cn/post/javascript-code-snippet/</link>
      <pubDate>Thu, 11 Aug 2016 10:27:18 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-code-snippet/</guid>
      <description>

&lt;h2 id=&#34;实用的javascript代码锦集&#34;&gt;实用的Javascript代码锦集&lt;/h2&gt;

&lt;h3 id=&#34;获取查询查询字符串get参数值&#34;&gt;获取查询查询字符串get参数值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function getParam()
{
	var data = decodeURIComponent(location.href).split(&amp;quot;?&amp;quot;)[1].split(&amp;quot;&amp;amp;&amp;quot;);
	var param = {};
	for(var i = 0; i&amp;lt;data .length; i++)
	{
		param[data [i].split(&amp;quot;=&amp;quot;)[0]] = data [i].split(&amp;quot;=&amp;quot;)[1];
	}
	return param;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;类似于PHP中的&lt;code&gt;$_GET&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var $_GET = (function()
{
	var url = decodeURIComponent(location.href);
	var u = url.split( &amp;quot;?&amp;quot; );
	if ( typeof (u[1]) == &amp;quot;string&amp;quot; )
	{
		u = u[1].split( &amp;quot;&amp;amp;&amp;quot; );
		var get = {};
		for ( var i in u)
		{
			var j = u[i].split( &amp;quot;=&amp;quot; );
			get[j[0]] = j[1];
		}
		return get;
	}
	else
	{
		return {};
	}
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;给出要获取的参数,每次都会解析一遍&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getPar(par)
{
	//获取当前URL
	var local_url = decodeURIComponent(location.href);
	//获取要取得的get参数位置
	var get = local_url.indexOf(par + &amp;quot;=&amp;quot; );
	if (get == -1)
	{
		return false ;
	}
	//截取字符串
	var get_par = local_url.slice(par.length + get + 1);
	//判断截取后的字符串是否还有其他get参数
	var nextPar = get_par.indexOf( &amp;quot;&amp;amp;&amp;quot; );
	if (nextPar != -1)
	{
		get_par = get_par.slice(0, nextPar);
	}
	return get_par;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;QueryString&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function QueryString(item)
{
	var value = location.search.match(new RegExp(&#39;[\?\&amp;amp;]&#39; + item + &#39;=([^\&amp;amp;]*)(\&amp;amp;?)&#39;,&#39;i&#39;));
	return value ? value[1] : value;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;取得cookie中某个键的值&#34;&gt;取得Cookie中某个键的值&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;$.getCookie = function(name)
{
	 if(document.cookie.indexOf(name)!=-1) return document.cookie.split(name+&#39;=&#39;)[1].split(&#39;;&#39;)[0]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另一个&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function getcookie(cookieid)
{
	//获取cookie字符串
	var strCookie=document.cookie;
	//将多cookie切割为多个名/值对
	var arrCookie=strCookie.split(&amp;quot;; &amp;quot;);
	var cookieval;
	//遍历cookie数组，处理每个cookie对
	for(var i=0;i&amp;lt;arrCookie.length;i++)
	{
		var arr=arrCookie[i].split(&amp;quot;=&amp;quot;);
		//找到名称为userId的cookie，并返回它的值
		if(cookieid==arr[0])
		{
			cookieval=arr[1];
			break;
		}
	}
	return(cookieval);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;进入全屏&#34;&gt;进入全屏&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function gofull()
{
	var el=document.documentElement;
	el.webkitRequestFullScreen&amp;amp;&amp;amp;el.webkitRequestFullScreen();
	el.mozRequestFullScreen&amp;amp;&amp;amp;el.mozRequestFullScreen();
	el.requestFullscreen&amp;amp;&amp;amp;el.requestFullscreen();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字符串去空格&#34;&gt;字符串去空格&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;String.prototype.trim=function() {return this.replace(/(^\s*)|(\s*$)/g,&amp;quot;&amp;quot;); }
String.prototype.ltrim=function(){return this.replace(/(^\s*)/g,&amp;quot;&amp;quot;); }
String.prototype.rtrim=function(){return this.replace(/(\s*$)/g,&amp;quot;&amp;quot;); }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;字节格式化&#34;&gt;字节格式化&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function size(size)
{
	var name=[&#39;B&#39;,&#39;KB&#39;,&#39;MB&#39;,&#39;GB&#39;,&#39;TB&#39;,&#39;PB&#39;];
	var pos=0;
	while(size&amp;gt;=1204)
	{
	    size/=1024;
	    pos++;
	}
	return size.toFixed(2)+&amp;quot; &amp;quot;+name[pos];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一些正则验证&#34;&gt;一些正则验证&lt;/h3&gt;

&lt;p&gt;验证邮箱&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_mail(str)
{
	return(new RegExp(/^[0-9a-zA-Z]+@(([0-9a-zA-Z]+)[.])+[a-z]{2,4}$/i).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;验证手机号&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function is_tel(str)
{
	return(new RegExp(/^1[34578][0-9]{9}$/).test(str));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;base64的1x1像素间隔gif&#34;&gt;Base64的1x1像素间隔gif&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&amp;quot;data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;一个range函数&#34;&gt;一个range函数&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function range(start, count)
{
	return Array.apply(0, Array(count)).map(function (element, index)
	{
		return index + start;
	});
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;简化-console-log&#34;&gt;简化&lt;code&gt;console.log&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;var log = console.log.bind(console);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;生成较短的唯一id&#34;&gt;生成较短的唯一ID&lt;/h3&gt;

&lt;p&gt;一定年限内单线程非连续调用唯一&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function shortId()
{
	var time=Date.now()+&#39;&#39;;
	time=parseInt(time.substr(1));
	return time.toString(36);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成随机短ID,仅具备较低的不重复性&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var t=(((1+Math.random())*0x10000000)|0).toString(16);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成指定长度随机字符串&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function code($nc, $a=&#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#39;)
{
    $l=strlen($a)-1; $r=&#39;&#39;;
    while($nc--&amp;gt;0) $r.=$a{mt_rand(0,$l)};
    return $r;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;给jquery的form添加-serializeobject&#34;&gt;给jQuery的form添加&lt;code&gt;serializeObject&lt;/code&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;jQuery.prototype.serializeObject=function()
{
	var a,o,h,i,e;
	a=this.serializeArray();
	o={};
	h=o.hasOwnProperty;
	for(i=0;i&amp;lt;a.length;i++)
	{
		e=a[i];
		if(!h.call(o,e.name))
		{
			o[e.name]=e.value;
		}
	}
	return o;
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用效果如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;jQuery(&amp;quot;form&amp;quot;).serialize(); //&amp;quot;username=&amp;amp;password=&amp;quot;
jQuery(&amp;quot;form&amp;quot;).serializeArray(); //[{name:&amp;quot;username&amp;quot;,value:&amp;quot;&amp;quot;},{name:&amp;quot;password&amp;quot;,value:&amp;quot;&amp;quot;}]
jQuery(&amp;quot;form&amp;quot;).serializeObject(); //{username:&amp;quot;&amp;quot;,password:&amp;quot;&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;资源预取&#34;&gt;资源预取&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;function prefetch(url)
{
	var link = document.createElement(&amp;quot;link&amp;quot;);
	link.href = url;
	link.rel=&amp;quot;prefetch&amp;quot;;
	var s = document.getElementsByTagName(&amp;quot;head&amp;quot;)[0];
	s.appendChild(link);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;用-google-analytics-统计js错误&#34;&gt;用&lt;code&gt;Google Analytics&lt;/code&gt;统计JS错误&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;(function(i,s,o,g,r,a,m){i[&#39;GoogleAnalyticsObject&#39;]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,&#39;script&#39;,&#39;https://www.google-analytics.com/analytics.js&#39;,&#39;ga&#39;);
window.addEventListener(&#39;error&#39;, function (err)
{
	ga(&#39;create&#39;, &#39;UA-xxx-1&#39;, &#39;auto&#39;);
    var lineAndColumnInfo = err.colno ? &#39; line:&#39; + err.lineno +&#39;, column:&#39;+ err.colno : &#39; line:&#39; + err.lineno;
    ga(&#39;send&#39;, &#39;event&#39;, &#39;JavaScript Error&#39;, err.message, location.href+&#39; =&amp;gt; &#39;+err.filename + lineAndColumnInfo + &#39; -&amp;gt; &#39; +  navigator.userAgent, 0, true );
});

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;UA-xxx-1&lt;/code&gt;使用自己的统计ID&lt;/p&gt;

&lt;h3 id=&#34;fetch跨域带cookie&#34;&gt;Fetch跨域带cookie&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;fetch(url, {credentials: &#39;include&#39;})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;jQuery ajax 跨域带 cookie&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$.ajaxSetup({xhrFields: {withCredentials: true }});
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>javascript senior</title>
      <link>http://blog.suconghou.cn/post/javascript-senior/</link>
      <pubDate>Tue, 09 Aug 2016 21:27:39 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/javascript-senior/</guid>
      <description>

&lt;h2 id=&#34;javascript-参数传递&#34;&gt;Javascript 参数传递&lt;/h2&gt;

&lt;p&gt;说起参数传递,首先需要弄清楚javascript里的数据类型&lt;/p&gt;

&lt;p&gt;原始数据类型
&lt;code&gt;Undefined&lt;/code&gt; &lt;code&gt;Null&lt;/code&gt; &lt;code&gt;Boolean&lt;/code&gt; &lt;code&gt;Number&lt;/code&gt; &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;引用数据类型&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Object&lt;/code&gt; &lt;code&gt;Array&lt;/code&gt; &lt;code&gt;Function&lt;/code&gt; &lt;code&gt;Date&lt;/code&gt; 等&lt;/p&gt;

&lt;p&gt;原始数据类型存储在栈的简单数据段,他们的值直接存储在变量访问的位置(因原始数据类型占据的空间是固定的,可以存储在较小的内存区域&lt;code&gt;栈&lt;/code&gt;中)&lt;/p&gt;

&lt;p&gt;引用数据类型是存储在堆中的对象,存储在变量处的值只是一个指针,指向存储对象的内存地址,这是因为引用类型的大小会改变.&lt;/p&gt;

&lt;p&gt;不同的内存分配机制带来不同的访问机制&lt;/p&gt;

&lt;p&gt;在JavaScript中,是不允许直接访问保存在堆内存中的对象的,访问对象时必须取得对象在堆内存中的地址,然后按地址去取得对象中的值.&lt;/p&gt;

&lt;p&gt;这便是传说中的按引用访问.&lt;/p&gt;

&lt;p&gt;而原始类型则是直接访问到的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;复制变量时的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;会将原始值的副本赋值给新变量.此后两个变量完全独立.&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;会把内存地址赋值给新变量,也就是说两个变量都指向堆内存中的同一个对象.
他们中任何一个改变都会反映到另一个身上.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参数传递的不同&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;最重要的一点:&lt;code&gt;ECMAScript&lt;/code&gt;中所有函数的参数都是按值传递的.&lt;/p&gt;

&lt;p&gt;但原始值和引用值仍会造成不同的后果.&lt;/p&gt;

&lt;p&gt;原始值:&lt;/p&gt;

&lt;p&gt;把变量里的值传递给参数,之后两个变量互不影响.(就是把实参复制给形参的过程)&lt;/p&gt;

&lt;p&gt;引用值:&lt;/p&gt;

&lt;p&gt;任然是将实参里面的值复制到形参,但是注意&lt;em&gt;对象变量它里面的值是这个对象的堆内存地址&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;也就是说形参和实参都是指向同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;但是也要记住另外一点:如果形参被赋值为另外一个对象时,那么这个形参将会丢弃对上次指向的堆内存地址,而指向新对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;此时,形参和实参相互脱离,互不影响,原先的实参任然指向原先对象的堆内存地址.&lt;/p&gt;

&lt;p&gt;如果是添加修改形参的属性,那么就是修改堆内存中的对象,形参和实参将同时得到反映,因为他们指向的是同一个堆内存对象.&lt;/p&gt;

&lt;p&gt;这种传递方式被称为&lt;code&gt;Call By Sharing&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function box(obj)
{
	obj.name=&#39;hello&#39;;
	var obj=new Object();
	obj.name=&#39;world&#39;;
}
var obj=new Object();
box(obj);
console.log(obj.name);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意两点:
1. &lt;code&gt;var obj=new Object()&lt;/code&gt; 声明提升&lt;/p&gt;

&lt;p&gt;变为&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var obj;
obj.name=&#39;hello&#39;;
obj=new Object();
obj.name=&#39;world&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;函数的已存在一个变量形参&lt;code&gt;obj&lt;/code&gt;,再次的变量申明会忽略&lt;/p&gt;

&lt;p&gt;2.&lt;code&gt;obj=new Object()&lt;/code&gt; 时,obj的修改就不会影响外层obj变量了,因为他此时已经脱离执行那个堆内存对象了.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;参考 &lt;a href=&#34;http://www.zhihu.com/question/27114726&#34;&gt;http://www.zhihu.com/question/27114726&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;object-create&#34;&gt;Object.create&lt;/h2&gt;

&lt;p&gt;简单来讲，new Object()是一种通过构造函数来创建object的方式，而Object.create(proto, [ propertiesObject ])
不需要通过构造函数就可以创建一个object，Object.create()的第一个参数是必须要的，第二个参数可选。其实Object.create()内部依然是通过new一个构造函数的方式来实现的，它有构造函数，不过这个构造函数是隐式存在的，看一下使老旧浏览器支持Object.create方法的“polyfill”就可以对它们之间的区别一目了然了：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (!Object.create) {
    Object.create = function (o) {
    function F() {}  //定义了一个隐式的构造函数
    F.prototype = o;
    return new F();  //其实还是通过new来实现的
    };
  }
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>HAProxy优化应用程序速度</title>
      <link>http://blog.suconghou.cn/post/use-haproxy/</link>
      <pubDate>Fri, 29 Jul 2016 14:27:54 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/use-haproxy/</guid>
      <description>

&lt;h2 id=&#34;haproxy&#34;&gt;HAProxy&lt;/h2&gt;

&lt;p&gt;HAProxy高性能的反向代理软件,更专注于TCP,HTTP处理,它可以基于四层或七层进行反向代理,尤其适合于高负载且需要进行七层处理的 Web 站点.&lt;/p&gt;

&lt;p&gt;单进程、事件驱动模型,通常用于超高流量的负载均衡.&lt;/p&gt;

&lt;p&gt;我们也可以使用它来作为中转站,使直连连通率不好的请求进过中转提升速度.&lt;/p&gt;

&lt;h3 id=&#34;编译安装&#34;&gt;编译安装&lt;/h3&gt;

&lt;p&gt;编译haproxy时必须制定target,不能直接make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Due to too many reports of suboptimized setups, building without
specifying the target is no longer supported. Please specify the
target OS in the TARGET variable, in the following form:

   make TARGET=xxx

Please choose the target among the following supported list :

   linux2628, linux26, linux24, linux24e, linux22, solaris
   freebsd, openbsd, cygwin, custom, generic

Use &amp;quot;generic&amp;quot; if you don&#39;t want any optimization, &amp;quot;custom&amp;quot; if you
want to precisely tweak every option, or choose the target which
matches your OS the most in order to gain the maximum performance
out of it. Please check the Makefile in case of doubts.

&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;linux2628 表示  内核版本&amp;gt;=2.6.28&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;apt-get update &amp;amp;&amp;amp; apt-get install -y wget gcc g++ make libpcre++0v5 libpcre++-dev
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;HAPROXY_VERSION=haproxy-1.6.9
CPU_NUM=`cat /proc/cpuinfo | grep processor | wc -l`
wget http://www.haproxy.org/download/1.6/src/${HAPROXY_VERSION}.tar.gz
tar zxf ${HAPROXY_VERSION}.tar.gz
cd ${HAPROXY_VERSION}
export CFLAGS=&amp;quot;-O3&amp;quot;
make TARGET=linux2628 ARCH=X86_64 USE_STATIC_PCRE=1 -j$CPU_NUM &amp;amp;&amp;amp; make install

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;编译32位版本&lt;code&gt;make TARGET=linux26 ARCH=i686 USE_STATIC_PCRE=1 -j$CPU_NUM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;在64位系统下编译32位需要&lt;code&gt;apt-get install gcc-multilib g++-multilib&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;我编译好的haproxy version 1.6.8&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/bin/haproxy.xz&#34;&gt;http://share.suconghou.cn/bin/haproxy.xz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;32位 &lt;a href=&#34;http://share.suconghou.cn/bin/haproxy.gz&#34;&gt;http://share.suconghou.cn/bin/haproxy.gz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;使用docker版本的haproxy&#34;&gt;使用Docker版本的HAProxy&lt;/h3&gt;

&lt;p&gt;这里提供一份编译好的最新版HAProxy镜像 &lt;a href=&#34;https://hub.docker.com/r/suconghou/haproxy/&#34;&gt;https://hub.docker.com/r/suconghou/haproxy/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;useradd -M -s /sbin/nologin haproxy&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;-M：不创建家目录&lt;/p&gt;

&lt;p&gt;-s：指定用户登陆时使用的shell，nologin就是登陆不了&lt;/p&gt;

&lt;h3 id=&#34;优化国外主机速度&#34;&gt;优化国外主机速度&lt;/h3&gt;

&lt;p&gt;HAProxy有多种连接模型,还有多种负载均衡算法,由于只有一台机器,我们主要侧重于使用它的反向代理.&lt;/p&gt;

&lt;p&gt;HAProxy可以一边保持与代理后端的长连接,一边又保持对客户端的连接.
这样双向保持持久连接,省去了中间反复创建连接可以在一定程度上优化速度.&lt;/p&gt;

&lt;p&gt;其只需要一个配置文件,配置主要有以下几部分功能&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default&lt;/code&gt;：用于为所有其它配置段提供默认参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;frontend&lt;/code&gt;：用于定义一系列监听的套接字，这些套接字可接受客户端请求并与之建立连接&lt;/li&gt;
&lt;li&gt;&lt;code&gt;backend&lt;/code&gt;：用于定义一系列后端服务器，代理将会将对应客户端的请求转发至这些服务器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listen&lt;/code&gt;： 通过关联前端和后端定义了一个完整的代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;配置写在&lt;code&gt;haproxy.cfg&lt;/code&gt;文件中,启动的时候指定使用的配置文件.&lt;/p&gt;

&lt;p&gt;如&lt;code&gt;haproxy -c -f /etc/haproxy/haproxy.cfg&lt;/code&gt;检查配置文件,&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg&lt;/code&gt;使用此配置文件启动&lt;/p&gt;

&lt;p&gt;一个简单的配置文件如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;global
    pidfile     /var/run/haproxy.pid
    user        haproxy
    group       haproxy
    daemon

defaults
    mode                    http
    log                     global
    retries                 3
    timeout http-request    10s
    timeout queue           1m
    timeout connect         10s
    timeout client          1m
    timeout server          1m
    timeout http-keep-alive 10s
    timeout check           10s
    maxconn                 30000

frontend http-in
    mode http
    bind 0.0.0.0:1080
    option http-keep-alive
    default_backend  servers

backend servers
	option http-keep-alive
    server myserver 192.243.115.210:80 check maxconn 6000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还有一个在应对高并发时通常都需要改的
&lt;code&gt;ulimit -n 8192&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-st&lt;/code&gt; 是立即结束原有进程(SIGTERM,立即重启)&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-sf&lt;/code&gt; 是原有进程执行完后退出(SIGUSR1,平滑重启)&lt;/p&gt;

&lt;p&gt;重启HAProxy&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg -st `cat /var/run/haproxy.pid`

# 不能放入.bashrc,``会立即执行的
# haproxy-reload
haproxy -f /etc/haproxy/haproxy.cfg -st `cat /var/run/haproxy.pid`
# haproxy-hot-reload
haproxy -f /etc/haproxy/haproxy.cfg -sf `cat /var/run/haproxy.pid`
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;/etc/rc.local&lt;/code&gt;(软连接到&lt;code&gt;/etc/rc.d/rc.local&lt;/code&gt;)是开机后自动执行的脚本&lt;/p&gt;

&lt;p&gt;可以加入&lt;code&gt;haproxy -f /etc/haproxy/haproxy.cfg&lt;/code&gt;到其中实现开机启动.&lt;/p&gt;

&lt;p&gt;配置文件参考 &lt;a href=&#34;https://github.com/chenzhiwei/linux/tree/master/haproxy&#34;&gt;https://github.com/chenzhiwei/linux/tree/master/haproxy&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;升级-glibc-版本-最新发布-http-www-gnu-org-software-libc&#34;&gt;升级&lt;code&gt;glibc&lt;/code&gt;版本,最新发布 &lt;a href=&#34;http://www.gnu.org/software/libc/&#34;&gt;http://www.gnu.org/software/libc/&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;所有版本见&lt;code&gt;http://mirror.hust.edu.cn/gnu/libc/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;错误 &lt;code&gt;libc.so.6: version GLIBC_2.14 not found&lt;/code&gt; 表明当前系统的glibc版本较低&lt;/p&gt;

&lt;p&gt;&lt;code&gt;strings libc.so.6 |grep GLIBC_&lt;/code&gt;可以查看当前系统支持的版本&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;wget http://mirror.hust.edu.cn/gnu/libc/glibc-2.19.tar.xz
tar Jxf glibc-2.19.tar.xz
cd glibc-2.19
mkdir build
cd build
../configure
make -j4&amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;a href=&#34;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&#34;&gt;https://cnodejs.org/topic/56dc21f1502596633dc2c3dc&lt;/a&gt;
此编译需要较长时间&lt;/p&gt;

&lt;h2 id=&#34;dog-tunnel端口映射&#34;&gt;dog-tunnel端口映射&lt;/h2&gt;

&lt;p&gt;开启服务器端(须有外网IP)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dtunnel_lite -service 0.0.0.0:1234 -v -tcp -xor 121333 &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;开启客户端(任意一台可联网的机器)&lt;/p&gt;

&lt;p&gt;反向映射客户机22端口到服务器的30222端口,代理ssh建议使用tcp,pipe通道为1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dtunnel_lite -service 服务器端IP:1234 -v -action 127.0.0.1:22 -encrypt -tcp -xor 121333 -local 172.168.1.99:30222 -r &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1 &amp;amp;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使用客户端连接多个服务器,将22端口映射到多个服务器端.&lt;/p&gt;

&lt;p&gt;用&lt;code&gt;crontab&lt;/code&gt;守护进程,每5分钟检查一次&lt;/p&gt;

&lt;p&gt;&lt;code&gt;*/5 * * * * sh /data/bin/connect.sh &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
echo &amp;quot;`date` start shell process &amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
if test $( pgrep -f dtunnel_lite | wc -l ) -eq 0
then
    while true
    do
        echo &amp;quot;`date` dtunnel_lite process is starting...&amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
        touch /run/connect.lock
        dtunnel_lite -service 114.242.25.173:1234 -v -action 127.0.0.1:22 -encrypt -tcp -xor 121333 -local 172.168.1.99:30222  -r
        echo &amp;quot;`date` dtunnel_lite process killed,todo restart &amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
        sleep 5
    done
else
    touch /run/connect.lock
    echo &amp;quot;`date` dtunnel_lite process is already running &amp;quot;&amp;gt;&amp;gt; /tmp/connect.log
fi

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先手动启动一次 &lt;code&gt;sh /data/bin/connect.sh &amp;gt; /tmp/dog.log 2&amp;gt;&amp;amp;1 &amp;amp;&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>some dev tools</title>
      <link>http://blog.suconghou.cn/software/some-dev-tools/</link>
      <pubDate>Sun, 17 Jul 2016 20:48:49 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/some-dev-tools/</guid>
      <description>

&lt;h2 id=&#34;一些开发会用到的小工具&#34;&gt;一些开发会用到的小工具&lt;/h2&gt;

&lt;h3 id=&#34;编程字体&#34;&gt;编程字体&lt;/h3&gt;

&lt;p&gt;苹果出品的&lt;code&gt;Monaco&lt;/code&gt;,看起来十分圆润,首选推荐的编程字体&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/fonts/monaco.ttf&#34;&gt;monaco&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;或许还有很多人喜欢&lt;code&gt;YaHei.Consolas&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/fonts/YaHei.Consolas.1.12.zip&#34;&gt;YaHei.Consolas.1.12.zip&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;一些从-linux-迁移到windows的东西&#34;&gt;一些从&lt;code&gt;Linux&lt;/code&gt;迁移到Windows的东西&lt;/h3&gt;

&lt;p&gt;最常用的当属&lt;code&gt;bash&lt;/code&gt;了,包含&lt;code&gt;md5sum&lt;/code&gt;,&lt;code&gt;wget&lt;/code&gt;,&lt;code&gt;curl&lt;/code&gt;,&lt;code&gt;awk&lt;/code&gt;等等.&lt;/p&gt;

&lt;p&gt;有两个比较好的项目在移植&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;unxutils&lt;/em&gt; &lt;a href=&#34;http://unxutils.sourceforge.net/&#34;&gt;http://unxutils.sourceforge.net/&lt;/a&gt;  源码 &lt;a href=&#34;https://sourceforge.net/projects/unxutils/&#34;&gt;https://sourceforge.net/projects/unxutils/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;win-bash&lt;/em&gt; &lt;a href=&#34;https://sourceforge.net/projects/win-bash/&#34;&gt;https://sourceforge.net/projects/win-bash/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;unxutils&lt;/code&gt;最后更新2014-04-03&lt;/p&gt;

&lt;p&gt;&lt;code&gt;win-bash&lt;/code&gt;最后更新2015-03-30&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sourceforge&lt;/code&gt;上速度太慢,这里提供加速下载.&lt;/p&gt;

&lt;p&gt;win-bash下载&lt;a href=&#34;http://share.suconghou.cn/Windows/shell.w32-ix86.zip&#34;&gt;shell.w32-ix86.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我的github也收集了一些&lt;code&gt;windows&lt;/code&gt;上常用的小工具&lt;code&gt;axel&lt;/code&gt;,&lt;code&gt;putty&lt;/code&gt;,&lt;code&gt;ab&lt;/code&gt;,&lt;code&gt;hugo&lt;/code&gt;,&lt;code&gt;rsync&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://github.com/suconghou/tools&#34;&gt;http://github.com/suconghou/tools&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Curl 官网 &lt;a href=&#34;https://curl.haxx.se/download.html&#34;&gt;https://curl.haxx.se/download.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Curl 这里可以下载windows版的
&lt;a href=&#34;http://www.paehl.com/open_source/?CURL_7.49.1&#34;&gt;http://www.paehl.com/open_source/?CURL_7.49.1&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks client</title>
      <link>http://blog.suconghou.cn/software/shadowsocks-client/</link>
      <pubDate>Sun, 17 Jul 2016 20:37:31 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/shadowsocks-client/</guid>
      <description>

&lt;h2 id=&#34;shadowsocks-各平台客户端&#34;&gt;shadowsocks 各平台客户端&lt;/h2&gt;

&lt;p&gt;文件来源于&lt;code&gt;github.com&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;windows平台&#34;&gt;windows平台&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/shadowsocks/Shadowsocks-3.3.4.zip&#34;&gt;Shadowsocks-3.3.4&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;mac平台&#34;&gt;mac平台&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/shadowsocks/ShadowsocksX-2.6.3.dmg&#34;&gt;ShadowsocksX-2.6.3&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;android平台&#34;&gt;android平台&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/shadowsocks/shadowsocks-nightly-3.2.7.apk&#34;&gt;shadowsocks-nightly-3.2.7&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;服务端可以使用docker更方便 &lt;a href=&#34;https://hub.docker.com/r/suconghou/shadowsocks/&#34;&gt;shadowsocks docker&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>picasa photo viewer</title>
      <link>http://blog.suconghou.cn/software/picasa-photo-viewer/</link>
      <pubDate>Sun, 17 Jul 2016 20:30:43 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/picasa-photo-viewer/</guid>
      <description>

&lt;h2 id=&#34;picasaphotoviewer-图片查看器-v3-9-136-9&#34;&gt;PicasaPhotoViewer(图片查看器) v3.9.136.9&lt;/h2&gt;

&lt;p&gt;Picasa内置的图片浏览器,Google出品,此版本为独木成林提取出来的.&lt;/p&gt;

&lt;p&gt;只有1.7MB,启动速度快,十分好用,有一个缺点是可能因为版权问题未对GIF做支持.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/ImageView/PicasaPhotoViewer_3.9.136.9.exe&#34;&gt;PicasaPhotoViewerv3.9.136.9&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>git for windows</title>
      <link>http://blog.suconghou.cn/software/git-for-windows/</link>
      <pubDate>Sun, 17 Jul 2016 20:11:26 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/software/git-for-windows/</guid>
      <description>

&lt;h2 id=&#34;git-for-windows-国内下载&#34;&gt;git for windows 国内下载&lt;/h2&gt;

&lt;p&gt;所有资源均来源于官网&lt;code&gt;http://git-scm.com/download/win&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最新版本2.10.2,发布于2016-11-02&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;32位资源&#34;&gt;32位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.10.2-32-bit.exe&#34;&gt;32位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.10.2-64-bit.7z.exe&#34;&gt;32位绿色版&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;64位资源&#34;&gt;64位资源&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/Git-2.10.2-64-bit.exe&#34;&gt;64位安装版&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://share.suconghou.cn/git/PortableGit-2.10.2-64-bit.7z.exe&#34;&gt;64位绿色版&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>react native</title>
      <link>http://blog.suconghou.cn/post/react-native/</link>
      <pubDate>Mon, 11 Jul 2016 11:39:08 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/react-native/</guid>
      <description>

&lt;h2 id=&#34;react-native&#34;&gt;react native&lt;/h2&gt;

&lt;h3 id=&#34;环境准备&#34;&gt;环境准备&lt;/h3&gt;

&lt;p&gt;前提是需要node和npm,这里不在赘述.介绍一个npm加速的.&lt;/p&gt;

&lt;p&gt;使用淘宝的npm镜像.控制台运行,或者加入你的bashrc中永久生效&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias cnpm=&amp;quot;npm --registry=https://registry.npm.taobao.org --cache=$HOME/.npm/.cache/cnpm --disturl=https://npm.taobao.org/dist --userconfig=$HOME/.cnpmrc&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装开发必备的一些package&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cnpm install -g react-native-cli webpack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;react-native&lt;/code&gt;也调用了&lt;code&gt;npm&lt;/code&gt;命令,所以我们可以再来个alias加速&lt;code&gt;react-native init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;alias npm=&#39;cnpm&#39;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;或者直接将仓库改为淘宝的NPM镜像&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;npm config set registry https://registry.npm.taobao.org
npm config set disturl https://npm.taobao.org/dist
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在mac上还需要一些东西&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;brew install flow watchman
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装完以后可以开始helloworld了.&lt;/p&gt;

&lt;h3 id=&#34;开始第一个例子&#34;&gt;开始第一个例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;cd /data/tmp
react-native init HelloWorld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后正在初始化大致如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;This will walk you through creating a new React Native project in /data/tmp/HelloWorld
Installing react-native package from npm...
Setting up new React Native app in /data/tmp/HelloWorld
HelloWorld@0.0.1 /data/tmp/HelloWorld
└── react@15.2.1

To run your app on iOS:
   cd /data/tmp/HelloWorld
   react-native run-ios
   - or -
   Open /data/tmp/HelloWorld/ios/HelloWorld.xcodeproj in Xcode
   Hit the Run button
To run your app on Android:
   Have an Android emulator running (quickest way to get started), or a device connected
   cd /data/tmp/HelloWorld
   react-native run-android
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;React&lt;/code&gt;类名(组件名)必须首字母大写才会被认为是一个组件,否则在JSX里只会当做普通标签&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发IOS的教程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们执行&lt;code&gt;react-native run-ios&lt;/code&gt;开始编译运行,前提是你必须安装了&lt;code&gt;xcode&lt;/code&gt;哦.&lt;/p&gt;

&lt;p&gt;执行后,出现&lt;code&gt;BUILD SUCCEEDED&lt;/code&gt;,同时自动打开新的终端运行了一个server在8081端口.&lt;/p&gt;

&lt;p&gt;模拟器中也会出现刚编译好的app的窗口,使用&lt;code&gt;cmd+r&lt;/code&gt;刷新,&lt;code&gt;cmd+d&lt;/code&gt;弹出开发菜单.&lt;/p&gt;

&lt;p&gt;我们可以修改&lt;code&gt;index.ios.js&lt;/code&gt;开始开发了.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;下面是一些针对开发Android的教程&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;问题&#34;&gt;问题&lt;/h3&gt;

&lt;p&gt;在使用&lt;code&gt;fetch&lt;/code&gt;调用接口时,可能会出现&lt;code&gt;The resource could not be loaded because the App Transport Security policy requires the use of a secure connection.&lt;/code&gt;错误&lt;/p&gt;

&lt;p&gt;这是IOS9要求必须使用https通信,需要修改 &lt;a href=&#34;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&#34;&gt;http://stackoverflow.com/questions/30731785/how-do-i-load-an-http-url-with-app-transport-security-enabled-in-ios-9&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;其实&lt;code&gt;react native&lt;/code&gt;创建&lt;code&gt;Info.plist&lt;/code&gt;时就已经为我们说明了,在&lt;code&gt;NSExceptionDomains&lt;/code&gt;下面的&lt;code&gt;dict&lt;/code&gt;里添加一个排除域名就OK了.&lt;/p&gt;

&lt;p&gt;注意,不能将默认的&lt;code&gt;localhost&lt;/code&gt;去掉,否则会出现&lt;code&gt;_fbBatchedBridge is undefined&lt;/code&gt;错误.&lt;/p&gt;

&lt;h2 id=&#34;打包&#34;&gt;打包&lt;/h2&gt;

&lt;h3 id=&#34;对android项目打包&#34;&gt;对android项目打包&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;keytool&lt;/code&gt;生成签名文件,在任意目录下执行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;keytool -genkey -v -keystore my-release-key.keystore  -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面&lt;code&gt;my-release-key&lt;/code&gt;可以自己定义,后面的&lt;code&gt;my-key-alias&lt;/code&gt;也可以自己定义.运行后输入一下相关信息后,生成&lt;code&gt;my-release-key.keystore&lt;/code&gt;文件.&lt;/p&gt;

&lt;p&gt;其中输入的两次密码,需要记住.将这个文件移动到&lt;code&gt;android/app&lt;/code&gt;目录下,编译&lt;code&gt;android/app&lt;/code&gt;里的&lt;code&gt;build.gradle&lt;/code&gt;,添加下面的内容&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;android {
    ...
    defaultConfig { ... }
    signingConfigs {
        release {
            storeFile file(MYAPP_RELEASE_STORE_FILE)
            storePassword MYAPP_RELEASE_STORE_PASSWORD
            keyAlias MYAPP_RELEASE_KEY_ALIAS
            keyPassword MYAPP_RELEASE_KEY_PASSWORD
        }
    }
    ...
    buildTypes {
        release {
              ...
              signingConfig signingConfigs.release
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;android&lt;/code&gt;目录下运行如下命令,就可以打包,安装到自己手机上,前提是手机已usb调试连接到电脑&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;./gradlew assembleRelease
cd app/build/outputs/apk
adb install -r app-release.apk
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;参考 &lt;a href=&#34;https://facebook.github.io/react-native/docs/signed-apk-android.html&#34;&gt;https://facebook.github.io/react-native/docs/signed-apk-android.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>都有哪些坑</title>
      <link>http://blog.suconghou.cn/post/some-hole/</link>
      <pubDate>Thu, 07 Jul 2016 15:46:03 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/some-hole/</guid>
      <description>

&lt;h2 id=&#34;总结一下遇到的坑&#34;&gt;总结一下遇到的坑&lt;/h2&gt;

&lt;h3 id=&#34;微信&#34;&gt;微信&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;关于横竖屏的坑&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;css3可以使用媒体查询判断设备是横屏还是竖屏&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//横屏时显示
@media all and (orientation : landscape) {
#screenMask{display:block}
}

//竖屏时隐藏
@media all and (orientation : portrait) {
#screenMask{display:none}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在手机浏览器中表现良好,微信中看样子也可以,但是微信网页中如果聚焦输入框,弹起键盘就有问题了.&lt;/p&gt;

&lt;p&gt;软键盘弹起后,网页可用面积减小,安卓就自动识别为横屏了,原有的页面消失了,影响非常大.IOS则没有这个问题,媒体查询判断横竖屏在IOS上工作良好.&lt;/p&gt;

&lt;p&gt;并且由此发现,css3媒体查询就是根据宽度是否比高度小来判断横竖屏的.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;解决方案1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;javascript&lt;/code&gt;的&lt;code&gt;orientation&lt;/code&gt;和&lt;code&gt;orientationchange&lt;/code&gt;判断&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;window.orientation   属于window对象上一个属性；共有三个值 ：0为竖屏模式（portrait）,90为向左反转变为横屏模式（landscape），-90为向右反转变为横屏模式（landscape），最后180就是设备上下互换还是竖屏模式。&lt;/li&gt;
&lt;li&gt;orientationchange    是一个event，在设备旋转时，会触发此事件，如同PC上使用的resize事件。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;(function(){
    var init = function(){
        var updateOrientation = function(){
            var orientation = window.orientation;
            switch(orientation){
                case 90:
                case -90:
                    orientation = &#39;landscape&#39;;
                    break;
                default:
                    orientation = &#39;portrait&#39;;
                    break;
            }

           //do something
           //比如在html标签加一个状态
            //然后根据不同状态，显示不同大小
            document.body.parentNode.setAttribute(&#39;class&#39;,orientation);
        };

        window.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        updateOrientation();
    };

    window.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经测试使用JS判断能够正确得出安卓微信客户端里输入框聚焦时的横竖屏状态.&lt;/p&gt;

&lt;p&gt;orientation和orientationchange只有移动设备有这些属性和事件.&lt;/p&gt;

&lt;p&gt;在不支持这种属性和事件的设备上使用宽高比来判断做一下兼容,这样在不支持&lt;code&gt;orientation&lt;/code&gt;的设备上就相当于使用了媒体查询&lt;/p&gt;

&lt;p&gt;最终总结代码如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(function(w)
{
    var supportOrientation = (typeof w.orientation === &#39;number&#39; &amp;amp;&amp;amp; typeof w.onorientationchange === &#39;object&#39;);
    var init = function()
    {
        var htmlNode = document.body.parentNode, orientation;
        var updateOrientation = function()
        {
            if(supportOrientation)
            {
                orientation = w.orientation;
                switch(orientation)
                {
                    case 90:
                    case -90:
                        orientation = &#39;landscape&#39;;
                        break;
                    default:
                        orientation = &#39;portrait&#39;;
                        break;
                }
            }
            else
            {
                orientation = (w.innerWidth &amp;gt; w.innerHeight) ? &#39;landscape&#39; : &#39;portrait&#39;;
            }
            htmlNode.setAttribute(&#39;class&#39;,orientation);
        };
        if(supportOrientation)
        {
            w.addEventListener(&#39;orientationchange&#39;,updateOrientation,false);
        }
        else
        {
            //监听resize事件
            w.addEventListener(&#39;resize&#39;,updateOrientation,false);
        }
        updateOrientation();
    };
    w.addEventListener(&#39;DOMContentLoaded&#39;,init,false);
})(window);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以访问如下网址测试: /html/wx&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>PHP最佳实践</title>
      <link>http://blog.suconghou.cn/post/php-best-way/</link>
      <pubDate>Thu, 30 Jun 2016 16:40:13 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/php-best-way/</guid>
      <description>

&lt;h2 id=&#34;性能优化&#34;&gt;性能优化&lt;/h2&gt;

&lt;h3 id=&#34;数组相关&#34;&gt;数组相关&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;in_array&lt;/code&gt;在大数据量(数万以上元素)下效率低下&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在分析nginx log得出所有不重复IP时,采用&lt;code&gt;in_array&lt;/code&gt;判断,50多万的数据耗时需要五六分钟,而采用存键的方法,用&lt;code&gt;isset&lt;/code&gt;判断仅需要十几秒,效率差别非常大. [php7环境下]&lt;/p&gt;

&lt;p&gt;判断一个数组是否存在某个元素,远比查找一个键消耗的要多.前者时间复杂度O(n),而后者O(1)&lt;/p&gt;

&lt;p&gt;即时使用&lt;code&gt;in_array&lt;/code&gt;,也需要加上第三个参数,设置为严格模式,省略数据类型转化的开销,设置为&lt;code&gt;true&lt;/code&gt;比设置为&lt;code&gt;false&lt;/code&gt;性能要提升好几倍.&lt;/p&gt;

&lt;p&gt;这种情况下使用&lt;code&gt;array_search&lt;/code&gt;情况比&lt;code&gt;in_array&lt;/code&gt;更加糟糕&lt;/p&gt;

&lt;p&gt;如果条件允许使用&lt;code&gt;array_flip&lt;/code&gt;交换键值,在用&lt;code&gt;isset&lt;/code&gt;来判断要比&lt;code&gt;in_array&lt;/code&gt;好得多&lt;/p&gt;

&lt;p&gt;同时,使用&lt;code&gt;isset&lt;/code&gt;来判断数组的键,也比使用&lt;code&gt;array_key_exists&lt;/code&gt;要好&lt;/p&gt;

&lt;p&gt;而对于本题,还可以使用&lt;code&gt;array_unique&lt;/code&gt;最后去重,用空间换时间,效率仅次于用&lt;code&gt;isset&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;bugs&#34;&gt;Bugs&lt;/h2&gt;

&lt;h3 id=&#34;php-pdo-mysql-server-has-gone-away&#34;&gt;php pdo &lt;code&gt;MySQL server has gone away&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;在使用PDO长连接时,执行过一次PDO初始化后,php-fpm进程会与mysql server开启一条TCP长连接,下次连接数据库就能加快速度.&lt;/p&gt;

&lt;p&gt;但是却存在一定问题,PDO维持了长连接并没有较好的检测其可用性,如果mysql server kill 掉这个连接,或者mysql重启,都会造成&lt;/p&gt;

&lt;p&gt;重新实例化PDO时得到旧的链接,导致出现&lt;code&gt;MySQL server has gone away&lt;/code&gt;,更让人郁闷的是这个错误并不是一个Exception,无法被catch捕获,即使设置&lt;code&gt;PDO::ATTR_ERRMODE=&amp;gt;PDO::ERRMODE_EXCEPTION&lt;/code&gt;,也不行,还是直接在页面上提示.&lt;/p&gt;

&lt;p&gt;如果你使用了&lt;code&gt;set_error_handler&lt;/code&gt;,那么这个&lt;code&gt;Warning&lt;/code&gt;将会被捕捉,不会直接显示在页面上,但也改变了程序的原有执行逻辑.&lt;/p&gt;

&lt;p&gt;如果你不使用&lt;code&gt;set_error_handler&lt;/code&gt;,页面上报出&lt;code&gt;Warning&lt;/code&gt;,但其实PDO已经返回一个可用的链接了.&lt;/p&gt;

&lt;p&gt;猜测可能是PDO首先得到了不可用的然后报警告,然后又创建了一个新的.&lt;/p&gt;

&lt;p&gt;较好的解决方法是设置&lt;code&gt;set_error_handler&lt;/code&gt;若捕获了这个&lt;code&gt;MySQL server has gone away&lt;/code&gt;,则返回null,程序继续按原有逻辑执行.&lt;/p&gt;

&lt;p&gt;或者不使用PDO长连接.&lt;/p&gt;

&lt;p&gt;注意,&lt;code&gt;set_error_handler&lt;/code&gt;返回false的话,这个错误还是会被交到上一级错误程序处理的.&lt;/p&gt;

&lt;h3 id=&#34;编码转换中的若干问题&#34;&gt;编码转换中的若干问题&lt;/h3&gt;

&lt;p&gt;我们经常会遇到将utf8编码字符转化为gbk编码的字符,例如生成csv表格,在windows上的cmd窗口输出文字,以及操作windows上的有关文件路径的操作都需要使用gbk编码.&lt;/p&gt;

&lt;p&gt;常使用&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk&#39;, $str);&lt;/code&gt;将utf8字符转为gbk&lt;/p&gt;

&lt;p&gt;这里 utf gbk 不区分大小写,也可以混写,不区分是&lt;code&gt;utf8&lt;/code&gt;还是&lt;code&gt;utf-8&lt;/code&gt;,都能都正常使用&lt;/p&gt;

&lt;p&gt;&lt;code&gt;iconv(&#39;utf-8&#39;, &#39;gbk//ignore&#39;, $str);&lt;/code&gt; 加上&lt;code&gt;//ignore&lt;/code&gt;使有些字符无法装换时略过.&lt;/p&gt;

&lt;p&gt;但是&lt;code&gt;//ignore&lt;/code&gt;在php5.4及以下,和个别php5.6版本上无效,任然是报NOTICE错误.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?php
	echo iconv(&#39;UTF8&#39;, &#39;GBK//IGNORE&#39;, &#39;l l l&#39;);
?&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;见 &lt;code&gt;https://3v4l.org/7vCFW&lt;/code&gt; 和 &lt;code&gt;http://www.php.net/manual/en/function.iconv.php&lt;/code&gt;第一条评论&lt;/p&gt;

&lt;p&gt;可以考虑使用&lt;code&gt;$content = mb_convert_encoding($content, &amp;quot;GBK&amp;quot;,&amp;quot;UTF-8&amp;quot;);&lt;/code&gt; 从UTF8转为GBK&lt;/p&gt;

&lt;p&gt;这样不会报错,不能装换的被替换为?,参数也是不区分大小写,utf8和utf-8&lt;/p&gt;

&lt;h3 id=&#34;filter-var-filter-validate-url&#34;&gt;filter_var FILTER_VALIDATE_URL&lt;/h3&gt;

&lt;p&gt;filter_var FILTER_VALIDATE_URL 中不能包含中文,包含中文被判定为false&lt;/p&gt;

&lt;h3 id=&#34;内存是拷贝还是内存引用&#34;&gt;内存是拷贝还是内存引用&lt;/h3&gt;

&lt;p&gt;例1&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
echo intval(memory_get_usage()/1024);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
$b=$a;
$c=$a;
$d=$a;
echo intval(memory_get_usage()/1024);

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例3&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$a=str_repeat(&#39;hello world&#39;,81920);
$b=$a.&#39;&#39;;
$c=$a.&#39;&#39;;
$d=$a.&#39;&#39;;
echo intval(memory_get_usage()/1024);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例1与例2,内存差距基本不大,例2与例3有较大差距,例3约为例2的3倍,但小于3倍&lt;/p&gt;

&lt;p&gt;一般数据类型&lt;/p&gt;

&lt;p&gt;php在内存上是写时拷贝,一个变量复制多份内存不会占用多份,只有变量被改变时才会新申请一份内存给此变量.&lt;/p&gt;

&lt;h3 id=&#34;memcached-中的问题&#34;&gt;Memcached 中的问题&lt;/h3&gt;

&lt;p&gt;如果你安装了php的&lt;code&gt;memcached&lt;/code&gt;扩展,但是&lt;code&gt;igbinary&lt;/code&gt;扩展没有被启用,&lt;/p&gt;

&lt;p&gt;会使得memcache存储简单数据类型没有问题,但是存储复杂数据类型,如数组等,便会出现问题,&lt;/p&gt;

&lt;p&gt;对一个复杂数据类型的set将会导致php worker进程崩溃,类似&lt;code&gt;[pool www] child 4573 exited on signal 5 (SIGTRAP) after 20.831438 seconds from start&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;nginx将会收到类似&lt;code&gt;upstream prematurely closed connection while reading response header from upstream&lt;/code&gt;,用户看到的将是502错误.&lt;/p&gt;

&lt;p&gt;故启用&lt;code&gt;memcached&lt;/code&gt;时最好启用&lt;code&gt;igbinary&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;php-worker&#34;&gt;php worker&lt;/h3&gt;

&lt;p&gt;python 简单的空worker 消耗内存比php空worker更少,但是随着python&lt;code&gt;import&lt;/code&gt;的模块增加,消耗的内存也随之上升,&lt;/p&gt;

&lt;p&gt;&lt;code&gt;import&lt;/code&gt;大多数常用模块后,内存消耗较php稍大,php进程只有业务处理会波动内存,python的CPU占用明显比php高.&lt;/p&gt;

&lt;p&gt;但python有多线程,多线程下内存消耗也较少,都适合写一些worker,相比之下,node的worker占用较多内存,引入常用模块后内存更是占用更大,CPU占用也比PHP多,优点是异步可以媲美多线程&lt;/p&gt;

&lt;h3 id=&#34;domdocument-loadhtml-内存泄漏&#34;&gt;DOMDocument loadHTML 内存泄漏&lt;/h3&gt;

&lt;p&gt;在大量使用DOMDocument的loadHTML后,php的进程占用内存不断增长,最终内存泄漏被强行杀死.&lt;/p&gt;

&lt;p&gt;其实这是&lt;code&gt;libxml_use_internal_errors&lt;/code&gt;所引起的问题,&lt;code&gt;loadHTML&lt;/code&gt;产生的警告被内部收集,但没有清除,所以一直堆积.&lt;/p&gt;

&lt;p&gt;见 &lt;a href=&#34;http://stackoverflow.com/questions/8379829/domdocument-php-memory-leak&#34;&gt;http://stackoverflow.com/questions/8379829/domdocument-php-memory-leak&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;php-gzip-压缩&#34;&gt;php gzip 压缩&lt;/h3&gt;

&lt;p&gt;压缩函数：gzcompress gzdeflate gzencode&lt;/p&gt;

&lt;p&gt;解压函数：gzuncompress gzinflate gzdecode&lt;/p&gt;

&lt;p&gt;他们都有第三个参数,并且第三个参数相同时,产生的结果也相同,其实他们都是使用了DEFLATE压缩算法,第三个参数控制他们压缩后添加的一些其他信息,只不过默认参数不同.&lt;/p&gt;

&lt;p&gt;ZLIB_ENCODING_RAW 对应于纯DEFLATE格式；
ZLIB_ENCODING_GZIP 对应于GZIP格式；
ZLIB_ENCODING_DEFLATE 对应于ZLIB格式（注意不是纯DEFLATE格式）&lt;/p&gt;

&lt;p&gt;默认配置下压缩后大小 gzdeflate &amp;lt; gzcompress &amp;lt; gzencode&lt;/p&gt;

&lt;p&gt;大小差别是6字节,12字节,18字节&lt;/p&gt;

&lt;p&gt;函数 &lt;code&gt;readgzfile&lt;/code&gt;类似于&lt;code&gt;readfile&lt;/code&gt;但是可以在输出之前解压然后输出&lt;/p&gt;

&lt;p&gt;Content-Encoding:deflate  对应于 gzdeflate&lt;/p&gt;

&lt;h2 id=&#34;foreach-vs-array-filter&#34;&gt;foreach vs array_filter&lt;/h2&gt;

&lt;p&gt;大数据量下,使用foreach过滤数组控制不如用array_filter,array_filter不加第二个参数,默认就是返回值,&lt;/p&gt;

&lt;p&gt;array_filter加上array_values也要比foreach快,在php7下更加明显&lt;/p&gt;

&lt;h2 id=&#34;php5-与-php7&#34;&gt;php5 与 php7&lt;/h2&gt;

&lt;p&gt;php5下关键字&lt;code&gt;list&lt;/code&gt;既不能作为一个函数也不能作为一个方法,也不能作为一个类.&lt;/p&gt;

&lt;p&gt;在php7下有了改善,能作为一个类中的方法了.&lt;/p&gt;

&lt;h2 id=&#34;array-merge-vs-array-array&#34;&gt;array_merge vs array+array&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://stackoverflow.com/questions/7059721/array-merge-versus&#34;&gt;http://stackoverflow.com/questions/7059721/array-merge-versus&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;正则-w匹不匹配中文&#34;&gt;正则\w匹不匹配中文&lt;/h2&gt;

&lt;p&gt;\w在ASCII下等价于[A-Za-z0-9_],在Unicode下表示字符(包括汉字)和数字和下划线.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/\w+/u&lt;/code&gt; 不添加u修饰符是不能匹配汉字的.&lt;/p&gt;

&lt;p&gt;匹配全是汉字的正则&lt;code&gt;/^[\x{4e00}-\x{9fa5}]+$/u&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Unicode的中文字范围是u4e00-u9fa5，4e00对应的字是&amp;rdquo;一&amp;rdquo;,9fa5对应的汉字是&amp;rdquo;龥&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/[\x{4e00}-\x{9fa5}]/u&lt;/code&gt; 等同于 &lt;code&gt;/[一-龥]/u&lt;/code&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>shadowsocks libev</title>
      <link>http://blog.suconghou.cn/post/shadowsocks-libev/</link>
      <pubDate>Wed, 18 May 2016 17:37:16 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/shadowsocks-libev/</guid>
      <description>

&lt;h2 id=&#34;编译&#34;&gt;编译&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;yum update &amp;amp;&amp;amp; yum install -y zip unzip xz curl wget git gcc make zlib zlib-devel openssl openssl-devel
git clone https://github.com/shadowsocks/shadowsocks-libev.git
cd shadowsocks-libev
./configure --enable-static=yes
export CFLAGS=&amp;quot;-O3&amp;quot;
make -j4 &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;GO语言版本的也十分方便哦&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里提供一个基于&lt;code&gt;docker&lt;/code&gt;的go语言版本,&lt;a href=&#34;https://hub.docker.com/r/suconghou/shadowsocks/&#34;&gt;docker go shadowsocks&lt;/a&gt;,只有3.3MB
十分方便&lt;/p&gt;

&lt;p&gt;同时也含有libev版本的可供选择&lt;/p&gt;

&lt;h2 id=&#34;网络内核参数优化&#34;&gt;网络内核参数优化&lt;/h2&gt;

&lt;p&gt;修改&lt;code&gt;ulimit&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ulimit -n&lt;/code&gt; 可以查看当前的&lt;/p&gt;

&lt;p&gt;&lt;code&gt;vim /etc/security/limits.conf&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;添加一下两行&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* soft nofile 51200
* hard nofile 51200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;KVM 和 XEN 可以修改内核,明显提升网络环境差的情况下的表现,使用&lt;code&gt;hybla&lt;/code&gt;控制算法,效果明显,能提速30%&lt;/p&gt;

&lt;p&gt;&lt;code&gt;/etc/sysctl.conf&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.core.somaxconn = 4096
net.netfilter.nf_conntrack_max = 64000
fs.file-max = 51200
#提高整个系统的文件限制
net.ipv4.tcp_syncookies = 1
#表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1
#表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_recycle = 0
#表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭；
#为了对NAT设备更友好，建议设置为0。
net.ipv4.tcp_fin_timeout = 30
#修改系統默认的 TIMEOUT 时间。
net.ipv4.tcp_keepalive_time = 1200
#表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为20分钟。
net.ipv4.ip_local_port_range = 10000 65000 #表示用于向外连接的端口范围。缺省情况下很小：32768到61000，改为10000到65000。（注意：这里不要将最低值设的太低，否则可能会占用掉正常的端口！）
net.ipv4.tcp_max_syn_backlog = 8192
#表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数。
net.ipv4.tcp_max_tw_buckets = 5000
#表示系统同时保持TIME_WAIT的最大数量，如果超过这个数字，TIME_WAIT将立刻被清除并打印警告信息。
#额外的，对于内核版本新于**3.7.1**的，我们可以开启tcp_fastopen：
net.ipv4.tcp_fastopen = 3

#increase TCP max buffer size settable using setsockopt()
net.core.rmem_max = 67108864
net.core.wmem_max = 67108864
#increase Linux autotuning TCP buffer limit
net.ipv4.tcp_rmem = 4096 87380 67108864
net.ipv4.tcp_wmem = 4096 65536 67108864
#increase the length of the processor input queue
net.core.netdev_max_backlog = 250000
#recommended for hosts with jumbo frames enabled
net.ipv4.tcp_mtu_probing=1
#使用拥塞算法Hybla
net.ipv4.tcp_congestion_control = hybla
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后&lt;code&gt;sysctl -p&lt;/code&gt;使之生效&lt;/p&gt;

&lt;p&gt;OPENVZ只能修改&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;net.core.somaxconn = 4096
net.ipv4.tcp_syncookies = 1
net.netfilter.nf_conntrack_max = 64000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用kcptun加速&lt;/p&gt;

&lt;p&gt;服务器上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias kcptun_start=&#39;server_linux_amd64 -t 127.0.0.1:443 -l :4433 -sndwnd 2048 -rcvwnd 2048 -mode fast2 &amp;gt; /var/log/kcptun.log 2&amp;gt;&amp;amp;1 &amp;amp; &#39;

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;客户机上&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias kcptun_start=&#39;kcptun_client -r 192.243.115.210:4433 -l :4433 -sndwnd 2048 -rcvwnd 2048 -mode fast2 &amp;gt; /var/log/kcptun.log 2&amp;gt;&amp;amp;1 &amp;amp;&#39;

&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>使用tcpdump与ngrep</title>
      <link>http://blog.suconghou.cn/post/tcpdump/</link>
      <pubDate>Mon, 16 May 2016 18:21:04 +0800</pubDate>
      
      <guid>http://blog.suconghou.cn/post/tcpdump/</guid>
      <description>

&lt;p&gt;各版本 &lt;code&gt;http://www.tcpdump.org/release/&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;安装依赖 &lt;code&gt;yum install -y flex gcc make byacc&lt;/code&gt; or &lt;code&gt;apt-get install flex gcc make byacc wget bzip2&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;cd /tmp
wget http://www.tcpdump.org/release/libpcap-1.7.4.tar.gz
tar zxf libpcap-1.7.4.tar.gz
cd libpcap-1.7.4
./configure --prefix=/tmp/lib
make -j4 &amp;amp;&amp;amp; make install
cd ../
wget http://www.tcpdump.org/release/tcpdump-4.7.4.tar.gz
tar zxf tcpdump-4.7.4.tar.gz
cd tcpdump-4.7.4
./configure --prefix=/tmp  --disable-ipv6 CFLAGS=&#39;-O3 -I/tmp/lib/include&#39; LDFLAGS=&#39;-L/tmp/lib/lib/libpcap.a&#39;
make -j4
make install
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安装成功后,位于&lt;code&gt;ls -lh /tmp/sbin/tcpdump&lt;/code&gt; &lt;code&gt;ldd&lt;/code&gt;查看此文件依赖较少,可直接复制到其他Linux上使用.&lt;/p&gt;

&lt;p&gt;采用&lt;code&gt;CFLAGS=&amp;quot;-O3&amp;quot;&lt;/code&gt;编译后为1.2MB&lt;/p&gt;

&lt;p&gt;&lt;code&gt;tcpdump -h&lt;/code&gt; 查看版本号以及用法&lt;/p&gt;

&lt;p&gt;我编译好的tcpdump version 4.7.4&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;64位 &lt;a href=&#34;http://share.suconghou.cn/bin/tcpdump.xz&#34;&gt;http://share.suconghou.cn/bin/tcpdump.xz&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;也可以直接&lt;code&gt;yum install tcpdump&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;使用tcpdump&#34;&gt;使用tcpdump&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;-a 　　　将网络地址和广播地址转变成名字；&lt;/p&gt;

&lt;p&gt;-d 　　　将匹配信息包的代码以人们能够理解的汇编格式给出；&lt;/p&gt;

&lt;p&gt;-dd 　　 将匹配信息包的代码以c语言程序段的格式给出；&lt;/p&gt;

&lt;p&gt;-ddd 　　将匹配信息包的代码以十进制的形式给出；&lt;/p&gt;

&lt;p&gt;-e 　　　在输出行打印出数据链路层的头部信息；&lt;/p&gt;

&lt;p&gt;-f 　　　将外部的Internet地址以数字的形式打印出来；&lt;/p&gt;

&lt;p&gt;-l 　　　使标准输出变为缓冲行形式；&lt;/p&gt;

&lt;p&gt;-n 　　　不把网络地址转换成名字；&lt;/p&gt;

&lt;p&gt;-t 　　　在输出的每一行不打印时间戳；&lt;/p&gt;

&lt;p&gt;-v 　　　输出一个稍微详细的信息，例如在ip包中可以包括ttl和服务类型的信息；&lt;/p&gt;

&lt;p&gt;-vv 　　 输出详细的报文信息；&lt;/p&gt;

&lt;p&gt;-c 　　　在收到指定的包的数目后，tcpdump就会停止；&lt;/p&gt;

&lt;p&gt;-F 　　　从指定的文件中读取表达式,忽略其它的表达式；&lt;/p&gt;

&lt;p&gt;-i 　　　指定监听的网络接口；&lt;/p&gt;

&lt;p&gt;-r 　　　从指定的文件中读取包(这些包一般通过-w选项产生)；&lt;/p&gt;

&lt;p&gt;-w 　　　直接将包写入文件中，并不分析和打印出来；&lt;/p&gt;

&lt;p&gt;-T 　　　将监听到的包直接解释为指定的类型的报文，常见的类型有rpc （远程过程调用）和snmp（简单网络管理协议；&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;tcpdump host 210.27.48.1&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;-A&lt;/code&gt;和&lt;code&gt;-X&lt;/code&gt;有助于你查看详细的报文数据&lt;/p&gt;

&lt;h2 id=&#34;ngrep&#34;&gt;ngrep&lt;/h2&gt;

&lt;p&gt;ngrep 编译总是出问题,建议直接安装:&lt;code&gt;apt-get install ngrep&lt;/code&gt; &lt;code&gt;yum install ngrep&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果更关注于TCP流量内容,可以使用&lt;code&gt;ngrep&lt;/code&gt;,他是grep命令的网络版,同样需要libpcap库,能识别TCP、UDP和ICMP包，理解bpf的过滤机制&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ngrep -W byline -d eno1 port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;用-d指定网卡,使用&lt;code&gt;ifconfig&lt;/code&gt;可以查看网卡信息&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;-e ：显示空数据包
-i ：忽略大小写
-v ：反转匹配
-R ：don&#39;t do privilege revocation logic
-x ：以16进制格式显示
-X ：以16进制格式匹配
-w ：整字匹配
-p ：不使用混杂模式
-l ：make stdout line buffered
-D ：replay pcap_dumps with their recorded time intervals
-t ：在每个匹配的包之前显示时间戳
-T ：显示上一个匹配的数据包之间的时间间隔
-M ：仅进行单行匹配
-I ：从文件中读取数据进行匹配
-O ：将匹配的数据保存到文件
-n ：仅捕获指定数目的数据包进行查看
-A ：匹配到数据包后dump随后的指定数目的数据包
-s ：set the bpf caplen
-S ：set the limitlen on matched packets
-W ：设置显示格式byline将解析包中的换行符
-c ：强制显示列的宽度
-q ：is be quiet (don’t print packet reception hash marks)静默模式，如果没有此开关，未匹配的数据包都以&amp;quot;#&amp;quot;显示
-P ：set the non-printable display char to what is specified
-F ：使用文件中定义的bpf(Berkeley Packet Filter)
-N ：显示由IANA定义的子协议号
-d ：使用哪个网卡，可以用-L选项查询
-L ：查询网卡接口

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果需要匹配关键字可以在-d参数之后, port 参数之前添加字符串匹配&lt;/p&gt;

&lt;p&gt;同时可以使用-i忽略大小写,-w整字匹配等&lt;/p&gt;

&lt;p&gt;&lt;code&gt;sudo ngrep  -W byline -d en0 -iw &amp;quot;easy&amp;quot;  port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;还可以使用这种过滤 &lt;code&gt;host www.google.com and port 80&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;具体使用见
&lt;a href=&#34;http://man.linuxde.net/ngrep&#34;&gt;http://man.linuxde.net/ngrep&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>